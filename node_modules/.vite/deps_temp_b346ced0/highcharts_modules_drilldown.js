import {
  __commonJS
} from "./chunk-DFKQJ226.js";

// node_modules/highcharts/modules/drilldown.js
var require_drilldown = __commonJS({
  "node_modules/highcharts/modules/drilldown.js"(exports, module) {
    (function(b) {
      "object" === typeof module && module.exports ? (b["default"] = b, module.exports = b) : "function" === typeof define && define.amd ? define("highcharts/modules/drilldown", ["highcharts"], function(q) {
        b(q);
        b.Highcharts = q;
        return b;
      }) : b("undefined" !== typeof Highcharts ? Highcharts : void 0);
    })(function(b) {
      function q(b2, g, l, q2) {
        b2.hasOwnProperty(g) || (b2[g] = q2.apply(null, l), "function" === typeof CustomEvent && window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: g, module: b2[g] } })));
      }
      b = b ? b._modules : {};
      q(b, "Extensions/Breadcrumbs/BreadcrumbsDefaults.js", [], function() {
        return { lang: { mainBreadcrumb: "Main" }, options: { buttonTheme: { fill: "none", height: 18, padding: 2, "stroke-width": 0, zIndex: 7, states: { select: { fill: "none" } }, style: { color: "#334eff" } }, buttonSpacing: 5, floating: false, format: void 0, relativeTo: "plotBox", rtl: false, position: { align: "left", verticalAlign: "top", x: 0, y: void 0 }, separator: { text: "/", style: { color: "#666666", fontSize: "0.8em" } }, showFullPath: true, style: {}, useHTML: false, zIndex: 7 } };
      });
      q(
        b,
        "Extensions/Breadcrumbs/Breadcrumbs.js",
        [b["Extensions/Breadcrumbs/BreadcrumbsDefaults.js"], b["Core/Chart/Chart.js"], b["Core/FormatUtilities.js"], b["Core/Utilities.js"]],
        function(b2, g, l, q2) {
          function H() {
            if (this.breadcrumbs) {
              const f = this.resetZoomButton && this.resetZoomButton.getBBox(), d = this.breadcrumbs.options;
              f && "right" === d.position.align && "plotBox" === d.relativeTo && this.breadcrumbs.alignBreadcrumbsGroup(-f.width - d.buttonSpacing);
            }
          }
          function I() {
            this.breadcrumbs && (this.breadcrumbs.destroy(), this.breadcrumbs = void 0);
          }
          function J() {
            const f = this.breadcrumbs;
            if (f && !f.options.floating && f.level) {
              var d = f.options, h = d.buttonTheme;
              h = (h.height || 0) + 2 * (h.padding || 0) + d.buttonSpacing;
              d = d.position.verticalAlign;
              "bottom" === d ? (this.marginBottom = (this.marginBottom || 0) + h, f.yOffset = h) : "middle" !== d ? (this.plotTop += h, f.yOffset = -h) : f.yOffset = void 0;
            }
          }
          function z() {
            this.breadcrumbs && this.breadcrumbs.redraw();
          }
          function D(f) {
            true === f.resetSelection && this.breadcrumbs && this.breadcrumbs.alignBreadcrumbsGroup();
          }
          const { format: x } = l, {
            addEvent: A,
            defined: E,
            extend: B,
            fireEvent: F,
            isString: O,
            merge: y,
            objectEach: G,
            pick: k
          } = q2, v = [];
          class p {
            static compose(f, d) {
              q2.pushUnique(v, f) && (A(g, "destroy", I), A(g, "afterShowResetZoom", H), A(g, "getMargins", J), A(g, "redraw", z), A(g, "selection", D));
              q2.pushUnique(v, d) && B(d.lang, b2.lang);
            }
            constructor(f, d) {
              this.elementList = {};
              this.isDirty = true;
              this.level = 0;
              this.list = [];
              d = y(f.options.drilldown && f.options.drilldown.drillUpButton, p.defaultOptions, f.options.navigation && f.options.navigation.breadcrumbs, d);
              this.chart = f;
              this.options = d || {};
            }
            updateProperties(f) {
              this.setList(f);
              this.setLevel();
              this.isDirty = true;
            }
            setList(f) {
              this.list = f;
            }
            setLevel() {
              this.level = this.list.length && this.list.length - 1;
            }
            getLevel() {
              return this.level;
            }
            getButtonText(f) {
              const d = this.chart, h = this.options;
              var b3 = d.options.lang;
              const g2 = k(h.format, h.showFullPath ? "{level.name}" : "← {level.name}");
              b3 = b3 && k(b3.drillUpText, b3.mainBreadcrumb);
              f = h.formatter && h.formatter(f) || x(g2, { level: f.levelOptions }, d) || "";
              (O(f) && !f.length || "← " === f) && E(b3) && (f = h.showFullPath ? b3 : "← " + b3);
              return f;
            }
            redraw() {
              this.isDirty && this.render();
              this.group && this.group.align();
              this.isDirty = false;
            }
            render() {
              const f = this.chart, d = this.options;
              !this.group && d && (this.group = f.renderer.g("breadcrumbs-group").addClass("highcharts-no-tooltip highcharts-breadcrumbs").attr({ zIndex: d.zIndex }).add());
              d.showFullPath ? this.renderFullPathButtons() : this.renderSingleButton();
              this.alignBreadcrumbsGroup();
            }
            renderFullPathButtons() {
              this.destroySingleButton();
              this.resetElementListState();
              this.updateListElements();
              this.destroyListElements();
            }
            renderSingleButton() {
              const f = this.chart;
              var d = this.list;
              const b3 = this.options.buttonSpacing;
              this.destroyListElements();
              const K = this.group ? this.group.getBBox().width : b3;
              d = d[d.length - 2];
              !f.drillUpButton && 0 < this.level ? f.drillUpButton = this.renderButton(d, K, b3) : f.drillUpButton && (0 < this.level ? this.updateSingleButton() : this.destroySingleButton());
            }
            alignBreadcrumbsGroup(f) {
              if (this.group) {
                var d = this.options;
                const h = d.buttonTheme, g2 = d.position, l2 = "chart" === d.relativeTo || "spacingBox" === d.relativeTo ? void 0 : "scrollablePlotBox";
                var b3 = this.group.getBBox();
                d = 2 * (h.padding || 0) + d.buttonSpacing;
                g2.width = b3.width + d;
                g2.height = b3.height + d;
                b3 = y(g2);
                f && (b3.x += f);
                this.options.rtl && (b3.x += g2.width);
                b3.y = k(b3.y, this.yOffset, 0);
                this.group.align(b3, true, l2);
              }
            }
            renderButton(f, d, b3) {
              const h = this, g2 = this.chart, k2 = h.options, l2 = y(k2.buttonTheme);
              d = g2.renderer.button(h.getButtonText(f), d, b3, function(d2) {
                const b4 = k2.events && k2.events.click;
                let c;
                b4 && (c = b4.call(h, d2, f));
                false !== c && (d2.newLevel = k2.showFullPath ? f.level : h.level - 1, F(h, "up", d2));
              }, l2).addClass("highcharts-breadcrumbs-button").add(h.group);
              g2.styledMode || d.attr(k2.style);
              return d;
            }
            renderSeparator(f, d) {
              const b3 = this.chart, g2 = this.options.separator;
              f = b3.renderer.label(g2.text, f, d, void 0, void 0, void 0, false).addClass("highcharts-breadcrumbs-separator").add(this.group);
              b3.styledMode || f.css(g2.style);
              return f;
            }
            update(f) {
              y(true, this.options, f);
              this.destroy();
              this.isDirty = true;
            }
            updateSingleButton() {
              const f = this.chart, b3 = this.list[this.level - 1];
              f.drillUpButton && f.drillUpButton.attr({ text: this.getButtonText(b3) });
            }
            destroy() {
              this.destroySingleButton();
              this.destroyListElements(true);
              this.group && this.group.destroy();
              this.group = void 0;
            }
            destroyListElements(b3) {
              const f = this.elementList;
              G(f, (d, g2) => {
                if (b3 || !f[g2].updated)
                  d = f[g2], d.button && d.button.destroy(), d.separator && d.separator.destroy(), delete d.button, delete d.separator, delete f[g2];
              });
              b3 && (this.elementList = {});
            }
            destroySingleButton() {
              this.chart.drillUpButton && (this.chart.drillUpButton.destroy(), this.chart.drillUpButton = void 0);
            }
            resetElementListState() {
              G(this.elementList, (b3) => {
                b3.updated = false;
              });
            }
            updateListElements() {
              const b3 = this.elementList, d = this.options.buttonSpacing, g2 = this.list, k2 = this.options.rtl, l2 = k2 ? -1 : 1, p2 = function(a, c2) {
                return l2 * a.getBBox().width + l2 * c2;
              }, q3 = function(a, c2, m) {
                a.translate(c2 - a.getBBox().width, m);
              };
              let t = this.group ? p2(this.group, d) : d, u, c;
              for (let a = 0, e = g2.length; a < e; ++a) {
                const m = a === e - 1;
                let r, f;
                c = g2[a];
                b3[c.level] ? (u = b3[c.level], r = u.button, u.separator || m ? u.separator && m && (u.separator.destroy(), delete u.separator) : (t += l2 * d, u.separator = this.renderSeparator(t, d), k2 && q3(u.separator, t, d), t += p2(u.separator, d)), b3[c.level].updated = true) : (r = this.renderButton(
                  c,
                  t,
                  d
                ), k2 && q3(r, t, d), t += p2(r, d), m || (f = this.renderSeparator(t, d), k2 && q3(f, t, d), t += p2(f, d)), b3[c.level] = { button: r, separator: f, updated: true });
                r && r.setState(m ? 2 : 0);
              }
            }
          }
          p.defaultOptions = b2.options;
          "";
          return p;
        }
      );
      q(b, "Extensions/Drilldown.js", [
        b["Core/Animation/AnimationUtilities.js"],
        b["Core/Axis/Axis.js"],
        b["Core/Chart/Chart.js"],
        b["Core/Color/Color.js"],
        b["Series/Column/ColumnSeries.js"],
        b["Core/Globals.js"],
        b["Core/Defaults.js"],
        b["Core/Series/Point.js"],
        b["Core/Series/Series.js"],
        b["Core/Series/SeriesRegistry.js"],
        b["Core/Renderer/SVG/SVGRenderer.js"],
        b["Core/Axis/Tick.js"],
        b["Core/Utilities.js"],
        b["Extensions/Breadcrumbs/Breadcrumbs.js"]
      ], function(b2, g, l, q2, C, I, J, z, D, x, A, E, B, F) {
        function H(c) {
          const a = y(this.chart.options.drilldown.animation);
          c && (c.hide(), L(function() {
            c && c.added && c.fadeIn();
          }, Math.max(a.duration - 50, 0)));
        }
        const { animObject: y } = b2, { noop: G } = I;
        ({ defaultOptions: b2 } = J);
        ({ seriesTypes: x } = x);
        const { addEvent: k, extend: v, fireEvent: p, merge: f, objectEach: d, pick: h, removeEvent: K, syncTimeout: L } = B;
        B = x.pie;
        x = x.map;
        let M = 1;
        v(b2.lang, {});
        b2.drilldown = { activeAxisLabelStyle: { cursor: "pointer", color: "#0022ff", fontWeight: "bold", textDecoration: "underline" }, activeDataLabelStyle: { cursor: "pointer", color: "#0022ff", fontWeight: "bold", textDecoration: "underline" }, animation: { duration: 500 }, drillUpButton: { position: { align: "right", x: -10, y: 10 } }, mapZooming: true };
        A.prototype.Element.prototype.fadeIn = function(c) {
          this.attr({ opacity: 0.1, visibility: "inherit" }).animate({ opacity: h(this.newOpacity, 1) }, c || { duration: 250 });
        };
        l.prototype.addSeriesAsDrilldown = function(c, a) {
          const e = this;
          if (e.mapView)
            if (c.series.isDrilling = true, c.series.options.inactiveOtherPoints = true, e.options.drilldown && e.options.drilldown.animation && e.options.drilldown.mapZooming) {
              c.series.dataLabelsGroup && (c.series.dataLabelsGroup.destroy(), delete c.series.dataLabelsGroup);
              e.mapView.allowTransformAnimation = true;
              const m = y(e.options.drilldown.animation);
              if ("boolean" !== typeof m) {
                const b3 = m.complete, f2 = function(b4) {
                  b4 && b4.applyDrilldown && e.mapView && (e.addSingleSeriesAsDrilldown(c, a), e.applyDrilldown(), e.mapView.allowTransformAnimation = false);
                };
                m.complete = function() {
                  b3 && b3.apply(this, arguments);
                  f2.apply(this, arguments);
                };
              }
              c.zoomTo(m);
            } else
              e.addSingleSeriesAsDrilldown(c, a), e.applyDrilldown();
          else
            e.addSingleSeriesAsDrilldown(c, a), e.applyDrilldown();
        };
        l.prototype.addSingleSeriesAsDrilldown = function(c, a) {
          let e = c.series, b3 = e.xAxis, r = e.yAxis, d2, g2 = [], k2 = [], w, n, l2;
          l2 = this.styledMode ? { colorIndex: h(c.colorIndex, e.colorIndex) } : { color: c.color || e.color };
          this.drilldownLevels || (this.drilldownLevels = []);
          w = e.options._levelNumber || 0;
          (n = this.drilldownLevels[this.drilldownLevels.length - 1]) && n.levelNumber !== w && (n = void 0);
          a = v(v({ _ddSeriesId: M++ }, l2), a);
          d2 = e.points.indexOf(c);
          e.chart.series.forEach(function(a2) {
            a2.xAxis === b3 && (a2.options._ddSeriesId = a2.options._ddSeriesId || M++, a2.options._colorIndex = a2.userOptions._colorIndex, a2.options._levelNumber = a2.options._levelNumber || w, n ? (g2 = n.levelSeries, k2 = n.levelSeriesOptions) : (g2.push(a2), a2.purgedOptions = f(
              { _ddSeriesId: a2.options._ddSeriesId, _levelNumber: a2.options._levelNumber, selected: a2.options.selected },
              a2.userOptions
            ), k2.push(a2.purgedOptions)));
          });
          c = v({ levelNumber: w, seriesOptions: e.options, seriesPurgedOptions: e.purgedOptions, levelSeriesOptions: k2, levelSeries: g2, shapeArgs: c.shapeArgs, bBox: c.graphic ? c.graphic.getBBox() : {}, color: c.isNull ? q2.parse(l2.color).setOpacity(0).get() : l2.color, lowerSeriesOptions: a, pointOptions: e.options.data[d2], pointIndex: d2, oldExtremes: { xMin: b3 && b3.userMin, xMax: b3 && b3.userMax, yMin: r && r.userMin, yMax: r && r.userMax }, resetZoomButton: n && n.levelNumber === w ? void 0 : this.resetZoomButton }, l2);
          this.drilldownLevels.push(c);
          b3 && b3.names && (b3.names.length = 0);
          a = c.lowerSeries = this.addSeries(a, false);
          a.options._levelNumber = w + 1;
          b3 && (b3.oldPos = b3.pos, b3.userMin = b3.userMax = null, r.userMin = r.userMax = null);
          a.isDrilling = true;
          e.type === a.type && (a.animate = a.animateDrilldown || G, a.options.animation = true);
        };
        l.prototype.applyDrilldown = function() {
          const c = this, a = this.drilldownLevels;
          let e;
          a && 0 < a.length && (e = a[a.length - 1].levelNumber, this.drilldownLevels.forEach(function(a2) {
            c.mapView && c.options.drilldown && c.options.drilldown.mapZooming && (c.redraw(), a2.lowerSeries.isDrilling = false, c.mapView.fitToBounds(a2.lowerSeries.bounds), a2.lowerSeries.isDrilling = true);
            a2.levelNumber === e && a2.levelSeries.forEach(function(a3, b3) {
              c.mapView ? a3.options && a3.options._levelNumber === e && a3.group && (b3 = {}, c.options.drilldown && (b3 = c.options.drilldown.animation), a3.group.animate({ opacity: 0 }, b3, function() {
                a3.remove(false);
                c.resetZoomButton && (c.resetZoomButton.hide(), delete c.resetZoomButton);
                c.pointer.reset();
                p(c, "afterDrilldown");
                c.mapView && (c.series.forEach((a4) => {
                  a4.isDirtyData = true;
                }), c.mapView.setView(void 0, 1));
                c.series.forEach((a4) => {
                  a4.isDrilling = false;
                });
                p(c, "afterApplyDrilldown");
              })) : a3.options && a3.options._levelNumber === e && a3.remove(false);
            });
          }));
          c.mapView || (this.resetZoomButton && (this.resetZoomButton.hide(), delete this.resetZoomButton), this.pointer.reset(), p(this, "afterDrilldown"), this.redraw(), p(this, "afterApplyDrilldown"));
        };
        const N = function(c) {
          const a = [];
          (c = c.drilldownLevels) && c.length && (a[0] || a.push({ level: 0, levelOptions: c[0].seriesOptions }), c.forEach(function(c2, b3) {
            c2.levelNumber + 1 > a[a.length - 1].level && a.push({
              level: c2.levelNumber + 1,
              levelOptions: f({ name: c2.lowerSeries.name }, c2.pointOptions)
            });
          }));
          return a;
        };
        l.prototype.drillUp = function(c) {
          if (this.drilldownLevels && 0 !== this.drilldownLevels.length) {
            p(this, "beforeDrillUp");
            for (var a = this, b3 = a.drilldownLevels, d2 = b3[b3.length - 1].levelNumber, f2 = a.series, g2 = a.drilldownLevels.length, k2 = function(c2, b4) {
              let e;
              f2.forEach(function(a2) {
                a2.options._ddSeriesId === c2._ddSeriesId && (e = a2);
              });
              e = e || a.addSeries(c2, false);
              e.type === b4.type && e.animateDrillupTo && (e.animate = e.animateDrillupTo);
              if (c2 === h2.seriesPurgedOptions)
                return e;
            }, l2 = (c2) => {
              c2.remove(false);
              a.series.forEach((a2) => {
                a2.colorAxis && (a2.isDirtyData = true);
                a2.options.inactiveOtherPoints = false;
              });
              a.redraw();
            }, w = b3.length, n, h2; w--; ) {
              let e, m;
              h2 = b3[w];
              if (h2.levelNumber === d2) {
                b3.pop();
                e = h2.lowerSeries;
                if (!e.chart) {
                  for (n = f2.length; n--; )
                    if (f2[n].options.id === h2.lowerSeriesOptions.id && f2[n].options._levelNumber === d2 + 1) {
                      e = f2[n];
                      break;
                    }
                }
                e.xData = [];
                e.xAxis && e.xAxis.names && (0 === g2 || w === g2) && (e.xAxis.names.length = 0);
                h2.levelSeriesOptions.forEach((a2) => {
                  m = k2(a2, e);
                });
                p(a, "drillup", { seriesOptions: h2.seriesPurgedOptions || h2.seriesOptions });
                m && (m.type === e.type && (m.drilldownLevel = h2, m.options.animation = a.options.drilldown.animation, e.animateDrillupFrom && e.chart && e.animateDrillupFrom(h2)), m.options._levelNumber = d2);
                n = e;
                a.mapView || n.remove(false);
                m && m.xAxis && (n = h2.oldExtremes, m.xAxis.setExtremes(n.xMin, n.xMax, false), m.yAxis.setExtremes(n.yMin, n.yMax, false));
                h2.resetZoomButton && (a.resetZoomButton = h2.resetZoomButton);
                this.mapView ? (n = a.options.drilldown && a.options.drilldown.animation && a.options.drilldown.mapZooming, h2.levelNumber === d2 && c ? e.remove(false) : (e.dataLabelsGroup && (e.dataLabelsGroup.destroy(), delete e.dataLabelsGroup), a.mapView && m && (n && (e.isDrilling = true, m.isDrilling = true, a.redraw(false), a.mapView.fitToBounds(e.bounds, void 0, true, false)), a.mapView.allowTransformAnimation = true, p(a, "afterDrillUp", { seriesOptions: m ? m.userOptions : void 0 }), n ? a.mapView.setView(void 0, 1, true, { complete: function() {
                  Object.prototype.hasOwnProperty.call(this, "complete") && l2(e);
                } }) : (a.mapView.allowTransformAnimation = false, e.group ? e.group.animate({ opacity: 0 }, a.options.drilldown.animation, function() {
                  l2(e);
                  a.mapView && (a.mapView.allowTransformAnimation = true);
                }) : (l2(e), a.mapView.allowTransformAnimation = true)), m.isDrilling = false, a.ddDupes && (a.ddDupes.length = 0), p(a, "drillupall")))) : (p(a, "afterDrillUp"), this.redraw(), this.ddDupes && (this.ddDupes.length = 0), p(a, "drillupall"));
              }
            }
          }
        };
        k(l, "afterInit", function() {
          const c = this;
          c.drilldown = { chart: c, fadeInGroup: H, update: function(a, e) {
            f(true, c.options.drilldown, a);
            h(e, true) && c.redraw();
          } };
        });
        k(l, "render", function() {
          (this.xAxis || []).forEach(function(c) {
            c.ddPoints = {};
            c.series.forEach(function(a) {
              let e, b3 = a.xData || [], f2 = a.points;
              for (e = 0; e < b3.length; e++) {
                var d2 = a.options.data[e];
                "number" !== typeof d2 && (d2 = a.pointClass.prototype.optionsToObject.call({ series: a }, d2), d2.drilldown && (c.ddPoints[b3[e]] || (c.ddPoints[b3[e]] = []), d2 = e - (a.cropStart || 0), c.ddPoints[b3[e]].push(f2 && 0 <= d2 && d2 < f2.length ? f2[d2] : true)));
              }
            });
            d(c.ticks, E.prototype.drillable);
          });
        });
        k(F, "up", function(c) {
          const a = this.chart;
          c = this.getLevel() - c.newLevel;
          let e = 1 < c;
          for (let b3 = 0; b3 < c; b3++)
            b3 === c - 1 && (e = false), a.drillUp(e);
        });
        k(l, "afterDrilldown", function() {
          var c = this.options.drilldown;
          c = c && c.breadcrumbs;
          this.breadcrumbs || (this.breadcrumbs = new F(this, c));
          this.breadcrumbs.updateProperties(N(this));
        });
        k(l, "afterDrillUp", function() {
          this.breadcrumbs && this.breadcrumbs.updateProperties(N(this));
        });
        k(l, "update", function(c) {
          const a = this.breadcrumbs, e = c.options.drilldown && c.options.drilldown.breadcrumbs;
          a && e && a.update(c.options.drilldown.breadcrumbs);
        });
        C.prototype.animateDrillupTo = function(c) {
          if (!c) {
            const a = this, c2 = a.drilldownLevel;
            this.points.forEach(function(a2) {
              const c3 = a2.dataLabel;
              a2.graphic && a2.graphic.hide();
              c3 && (c3.hidden = "hidden" === c3.attr("visibility"), c3.hidden || (c3.hide(), a2.connector && a2.connector.hide()));
            });
            L(function() {
              if (a.points) {
                let b3 = [];
                a.data.forEach(function(a2) {
                  b3.push(a2);
                });
                a.nodes && (b3 = b3.concat(a.nodes));
                b3.forEach(function(a2, b4) {
                  b4 = b4 === (c2 && c2.pointIndex) ? "show" : "fadeIn";
                  const e = "show" === b4 ? true : void 0, d2 = a2.dataLabel;
                  if (a2.graphic && a2.visible)
                    a2.graphic[b4](e);
                  d2 && !d2.hidden && (d2.fadeIn(), a2.connector && a2.connector.fadeIn());
                });
              }
            }, Math.max(this.chart.options.drilldown.animation.duration - 50, 0));
            delete this.animate;
          }
        };
        C.prototype.animateDrilldown = function(c) {
          let a = this, b3 = this.chart, d2 = b3.drilldownLevels, f2, g2 = y(b3.options.drilldown.animation), k2 = this.xAxis, l2 = b3.styledMode;
          c || (d2.forEach(function(c2) {
            a.options._ddSeriesId === c2.lowerSeriesOptions._ddSeriesId && (f2 = c2.shapeArgs, l2 || (f2.fill = c2.color));
          }), f2.x += h(k2.oldPos, k2.pos) - k2.pos, this.points.forEach(function(c2) {
            const b4 = c2.shapeArgs;
            l2 || (b4.fill = c2.color);
            c2.graphic && c2.graphic.attr(f2).animate(v(c2.shapeArgs, { fill: c2.color || a.color }), g2);
          }), b3.drilldown && b3.drilldown.fadeInGroup(this.dataLabelsGroup), delete this.animate);
        };
        C.prototype.animateDrillupFrom = function(c) {
          let a = y(this.chart.options.drilldown.animation), b3 = this.group, d2 = b3 !== this.chart.columnGroup, g2 = this;
          g2.trackerGroups.forEach(function(a2) {
            if (g2[a2])
              g2[a2].on("mouseover");
          });
          d2 && delete this.group;
          this.points.forEach(function(e) {
            const m = e.graphic, h2 = c.shapeArgs, k2 = function() {
              m.destroy();
              b3 && d2 && (b3 = b3.destroy());
            };
            m && h2 && (delete e.graphic, g2.chart.styledMode || (h2.fill = c.color), a.duration ? m.animate(h2, f(a, { complete: k2 })) : (m.attr(h2), k2()));
          });
        };
        B && v(
          B.prototype,
          { animateDrillupTo: C.prototype.animateDrillupTo, animateDrillupFrom: C.prototype.animateDrillupFrom, animateDrilldown: function(c) {
            const a = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1], b3 = this.chart.options.drilldown.animation;
            this.is("item") && (b3.duration = 0);
            if (this.center) {
              const e = a.shapeArgs, d2 = e.start, g2 = (e.end - d2) / this.points.length, h2 = this.chart.styledMode;
              c || (this.points.forEach(function(c2, m) {
                const k2 = c2.shapeArgs;
                h2 || (e.fill = a.color, k2.fill = c2.color);
                if (c2.graphic)
                  c2.graphic.attr(f(e, { start: d2 + m * g2, end: d2 + (m + 1) * g2 }))[b3 ? "animate" : "attr"](k2, b3);
              }), this.chart.drilldown && this.chart.drilldown.fadeInGroup(this.dataLabelsGroup), delete this.animate);
            }
          } }
        );
        x && v(x.prototype, { animateDrilldown(c) {
          const a = this, b3 = this.chart, d2 = this.group;
          b3 && d2 && a.options && (c && b3.mapView ? (d2.attr({ opacity: 0.01 }), b3.mapView.allowTransformAnimation = false, a.options.inactiveOtherPoints = true, a.options.enableMouseTracking = false) : (d2.animate({ opacity: 1 }, b3.options.drilldown.animation, function() {
            a.options && (a.options.inactiveOtherPoints = false, a.options.enableMouseTracking = h(a.userOptions && a.userOptions.enableMouseTracking, true));
          }), b3.drilldown && b3.drilldown.fadeInGroup(this.dataLabelsGroup)));
        }, animateDrillupFrom() {
          const c = this.chart;
          c && c.mapView && (c.mapView.allowTransformAnimation = false);
          this.options && (this.options.inactiveOtherPoints = true);
        }, animateDrillupTo(c) {
          const a = this.chart, b3 = this.group;
          a && b3 && (c ? (b3.attr({ opacity: 0.01 }), this.options && (this.options.inactiveOtherPoints = true)) : (b3.animate({ opacity: 1 }, a.options.drilldown.animation), a.drilldown && a.drilldown.fadeInGroup(this.dataLabelsGroup)));
        } });
        z.prototype.doDrilldown = function() {
          this.runDrilldown();
        };
        z.prototype.runDrilldown = function(c, a, b3) {
          const e = this.series.chart, d2 = e.options.drilldown;
          let f2 = (d2.series || []).length, g2;
          e.ddDupes || (e.ddDupes = []);
          for (; f2-- && !g2; )
            d2.series[f2].id === this.drilldown && -1 === e.ddDupes.indexOf(this.drilldown) && (g2 = d2.series[f2], e.ddDupes.push(this.drilldown));
          p(e, "drilldown", { point: this, seriesOptions: g2, category: a, originalEvent: b3, points: "undefined" !== typeof a && this.series.xAxis.getDDPoints(a).slice(0) }, function(a2) {
            const b4 = a2.point.series && a2.point.series.chart, e2 = a2.seriesOptions;
            b4 && e2 && (c ? b4.addSingleSeriesAsDrilldown(a2.point, e2) : b4.addSeriesAsDrilldown(a2.point, e2));
          });
        };
        g.prototype.drilldownCategory = function(c, a) {
          this.getDDPoints(c).forEach(function(b3) {
            b3 && b3.series && b3.series.visible && b3.runDrilldown && b3.runDrilldown(true, c, a);
          });
          this.chart.applyDrilldown();
        };
        g.prototype.getDDPoints = function(b3) {
          return this.ddPoints && this.ddPoints[b3] || [];
        };
        E.prototype.drillable = function() {
          const b3 = this.pos, a = this.label, e = this.axis, d2 = "xAxis" === e.coll && e.getDDPoints, g2 = d2 && e.getDDPoints(b3), h2 = e.chart.styledMode;
          d2 && (a && g2 && g2.length ? (a.drillable = true, a.basicStyles || h2 || (a.basicStyles = f(a.styles)), a.addClass("highcharts-drilldown-axis-label"), a.removeOnDrillableClick && K(a.element, "click"), a.removeOnDrillableClick = k(a.element, "click", function(a2) {
            a2.preventDefault();
            e.drilldownCategory(b3, a2);
          }), h2 || a.css(e.chart.options.drilldown.activeAxisLabelStyle)) : a && a.drillable && a.removeOnDrillableClick && (h2 || (a.styles = {}, a.element.removeAttribute("style"), a.css(a.basicStyles)), a.removeOnDrillableClick(), a.removeClass("highcharts-drilldown-axis-label")));
        };
        k(z, "afterInit", function() {
          this.drilldown && !this.unbindDrilldownClick && (this.unbindDrilldownClick = k(this, "click", t));
          return this;
        });
        k(z, "update", function(b3) {
          b3 = b3.options || {};
          b3.drilldown && !this.unbindDrilldownClick ? this.unbindDrilldownClick = k(this, "click", t) : !b3.drilldown && void 0 !== b3.drilldown && this.unbindDrilldownClick && (this.unbindDrilldownClick = this.unbindDrilldownClick());
        });
        const t = function(b3) {
          const a = this.series;
          a.xAxis && false === a.chart.options.drilldown.allowPointDrilldown ? a.xAxis.drilldownCategory(this.x, b3) : this.runDrilldown(void 0, void 0, b3);
        };
        k(D, "afterDrawDataLabels", function() {
          const b3 = this.chart.options.drilldown.activeDataLabelStyle, a = this.chart.renderer, e = this.chart.styledMode;
          this.points.forEach(
            function(c) {
              const d2 = c.options.dataLabels, f2 = h(c.dlOptions, d2 && d2.style, {});
              c.drilldown && c.dataLabel && ("contrast" !== b3.color || e || (f2.color = a.getContrast(c.color || this.color)), d2 && d2.color && (f2.color = d2.color), c.dataLabel.addClass("highcharts-drilldown-data-label"), e || c.dataLabel.css(b3).css(f2));
            },
            this
          );
        });
        const u = function(b3, a, d2, f2) {
          b3[d2 ? "addClass" : "removeClass"]("highcharts-drilldown-point");
          f2 || b3.css({ cursor: a });
        };
        k(D, "afterDrawTracker", function() {
          const b3 = this.chart.styledMode;
          this.points.forEach(function(a) {
            a.drilldown && a.graphic && u(a.graphic, "pointer", true, b3);
          });
        });
        k(z, "afterSetState", function() {
          const b3 = this.series.chart.styledMode;
          this.drilldown && this.series.halo && "hover" === this.state ? u(this.series.halo, "pointer", true, b3) : this.series.halo && u(this.series.halo, "auto", false, b3);
        });
        k(l, "drillup", function() {
          this.resetZoomButton && (this.resetZoomButton = this.resetZoomButton.destroy());
        });
        k(l, "drillupall", function() {
          this.resetZoomButton && this.showResetZoom();
        });
      });
      q(b, "masters/modules/drilldown.src.js", [b["Core/Globals.js"], b["Extensions/Breadcrumbs/Breadcrumbs.js"]], function(b2, g) {
        b2.Breadcrumbs = g;
        g.compose(b2.Chart, b2.defaultOptions);
      });
    });
  }
});
export default require_drilldown();
//# sourceMappingURL=highcharts_modules_drilldown.js.map
