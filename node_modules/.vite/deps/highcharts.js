import {
  __commonJS
} from "./chunk-DFKQJ226.js";

// node_modules/highcharts/highcharts.js
var require_highcharts = __commonJS({
  "node_modules/highcharts/highcharts.js"(exports, module) {
    (function(T, M) {
      "object" === typeof module && module.exports ? (M["default"] = M, module.exports = T.document ? M(T) : M) : "function" === typeof define && define.amd ? define("highcharts/highcharts", function() {
        return M(T);
      }) : (T.Highcharts && T.Highcharts.error(16, true), T.Highcharts = M(T));
    })("undefined" !== typeof window ? window : exports, function(T) {
      function M(a2, y, H, K) {
        a2.hasOwnProperty(y) || (a2[y] = K.apply(null, H), "function" === typeof CustomEvent && T.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: y, module: a2[y] } })));
      }
      var a = {};
      M(a, "Core/Globals.js", [], function() {
        var a2;
        (function(a3) {
          a3.SVG_NS = "http://www.w3.org/2000/svg";
          a3.product = "Highcharts";
          a3.version = "11.0.0";
          a3.win = "undefined" !== typeof T ? T : {};
          a3.doc = a3.win.document;
          a3.svg = a3.doc && a3.doc.createElementNS && !!a3.doc.createElementNS(a3.SVG_NS, "svg").createSVGRect;
          a3.userAgent = a3.win.navigator && a3.win.navigator.userAgent || "";
          a3.isChrome = -1 !== a3.userAgent.indexOf("Chrome");
          a3.isFirefox = -1 !== a3.userAgent.indexOf("Firefox");
          a3.isMS = /(edge|msie|trident)/i.test(a3.userAgent) && !a3.win.opera;
          a3.isSafari = !a3.isChrome && -1 !== a3.userAgent.indexOf("Safari");
          a3.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a3.userAgent);
          a3.isWebKit = -1 !== a3.userAgent.indexOf("AppleWebKit");
          a3.deg2rad = 2 * Math.PI / 360;
          a3.hasBidiBug = a3.isFirefox && 4 > parseInt(a3.userAgent.split("Firefox/")[1], 10);
          a3.hasTouch = !!a3.win.TouchEvent;
          a3.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];
          a3.noop = function() {
          };
          a3.supportsPassiveEvents = function() {
            let w = false;
            if (!a3.isMS) {
              const y = Object.defineProperty({}, "passive", { get: function() {
                w = true;
              } });
              a3.win.addEventListener && a3.win.removeEventListener && (a3.win.addEventListener("testPassive", a3.noop, y), a3.win.removeEventListener("testPassive", a3.noop, y));
            }
            return w;
          }();
          a3.charts = [];
          a3.dateFormats = {};
          a3.seriesTypes = {};
          a3.symbolSizes = {};
          a3.chartCount = 0;
        })(a2 || (a2 = {}));
        "";
        return a2;
      });
      M(a, "Core/Utilities.js", [a["Core/Globals.js"]], function(a2) {
        function w(b, c2, l, e2) {
          const p = c2 ? "Highcharts error" : "Highcharts warning";
          32 === b && (b = `${p}: Deprecated member`);
          const O = v(b);
          let q2 = O ? `${p} #${b}: www.highcharts.com/errors/${b}/` : b.toString();
          if ("undefined" !== typeof e2) {
            let b2 = "";
            O && (q2 += "?");
            I(e2, function(c3, p2) {
              b2 += `
 - ${p2}: ${c3}`;
              O && (q2 += encodeURI(p2) + "=" + encodeURI(c3));
            });
            q2 += b2;
          }
          z(a2, "displayError", { chart: l, code: b, message: q2, params: e2 }, function() {
            if (c2)
              throw Error(q2);
            d.console && -1 === w.messages.indexOf(q2) && console.warn(q2);
          });
          w.messages.push(q2);
        }
        function H(b, c2) {
          const p = {};
          I(b, function(l, d2) {
            if (C(b[d2], true) && !b.nodeType && c2[d2])
              l = H(b[d2], c2[d2]), Object.keys(l).length && (p[d2] = l);
            else if (C(b[d2]) || b[d2] !== c2[d2] || d2 in b && !(d2 in c2))
              p[d2] = b[d2];
          });
          return p;
        }
        function K(b, c2) {
          return parseInt(b, c2 || 10);
        }
        function B(b) {
          return "string" === typeof b;
        }
        function E(b) {
          b = Object.prototype.toString.call(b);
          return "[object Array]" === b || "[object Array Iterator]" === b;
        }
        function C(b, c2) {
          return !!b && "object" === typeof b && (!c2 || !E(b));
        }
        function A(b) {
          return C(b) && "number" === typeof b.nodeType;
        }
        function u(b) {
          const c2 = b && b.constructor;
          return !(!C(b, true) || A(b) || !c2 || !c2.name || "Object" === c2.name);
        }
        function v(b) {
          return "number" === typeof b && !isNaN(b) && Infinity > b && -Infinity < b;
        }
        function f(b) {
          return "undefined" !== typeof b && null !== b;
        }
        function h(b, c2, l) {
          const p = B(c2) && !f(l);
          let d2;
          const e2 = (c3, l2) => {
            f(c3) ? b.setAttribute(l2, c3) : p ? (d2 = b.getAttribute(l2)) || "class" !== l2 || (d2 = b.getAttribute(l2 + "Name")) : b.removeAttribute(l2);
          };
          B(c2) ? e2(l, c2) : I(c2, e2);
          return d2;
        }
        function r(b, c2) {
          let l;
          b || (b = {});
          for (l in c2)
            b[l] = c2[l];
          return b;
        }
        function m() {
          const b = arguments, c2 = b.length;
          for (let l = 0; l < c2; l++) {
            const c3 = b[l];
            if ("undefined" !== typeof c3 && null !== c3)
              return c3;
          }
        }
        function n(b, c2) {
          a2.isMS && !a2.svg && c2 && f(c2.opacity) && (c2.filter = `alpha(opacity=${100 * c2.opacity})`);
          r(
            b.style,
            c2
          );
        }
        function k(b) {
          return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));
        }
        function g(b, c2) {
          return 1e14 < b ? b : parseFloat(b.toPrecision(c2 || 14));
        }
        function I(b, c2, l) {
          for (const p in b)
            Object.hasOwnProperty.call(b, p) && c2.call(l || b[p], b[p], p, b);
        }
        function F(b, c2, l) {
          function p(c3, l2) {
            const p2 = b.removeEventListener;
            p2 && p2.call(b, c3, l2, false);
          }
          function d2(l2) {
            let d3, e3;
            b.nodeName && (c2 ? (d3 = {}, d3[c2] = true) : d3 = l2, I(d3, function(b2, c3) {
              if (l2[c3])
                for (e3 = l2[c3].length; e3--; )
                  p(c3, l2[c3][e3].fn);
            }));
          }
          var e2 = "function" === typeof b && b.prototype || b;
          if (Object.hasOwnProperty.call(
            e2,
            "hcEvents"
          )) {
            const b2 = e2.hcEvents;
            c2 ? (e2 = b2[c2] || [], l ? (b2[c2] = e2.filter(function(b3) {
              return l !== b3.fn;
            }), p(c2, l)) : (d2(b2), b2[c2] = [])) : (d2(b2), delete e2.hcEvents);
          }
        }
        function z(b, c2, l, d2) {
          l = l || {};
          if (t.createEvent && (b.dispatchEvent || b.fireEvent && b !== a2)) {
            var p = t.createEvent("Events");
            p.initEvent(c2, true, true);
            l = r(p, l);
            b.dispatchEvent ? b.dispatchEvent(l) : b.fireEvent(c2, l);
          } else if (b.hcEvents) {
            l.target || r(l, { preventDefault: function() {
              l.defaultPrevented = true;
            }, target: b, type: c2 });
            p = [];
            let d3 = b, e2 = false;
            for (; d3.hcEvents; )
              Object.hasOwnProperty.call(
                d3,
                "hcEvents"
              ) && d3.hcEvents[c2] && (p.length && (e2 = true), p.unshift.apply(p, d3.hcEvents[c2])), d3 = Object.getPrototypeOf(d3);
            e2 && p.sort((b2, c3) => b2.order - c3.order);
            p.forEach((c3) => {
              false === c3.fn.call(b, l) && l.preventDefault();
            });
          }
          d2 && !l.defaultPrevented && d2.call(b, l);
        }
        const { charts: e, doc: t, win: d } = a2;
        (w || (w = {})).messages = [];
        Math.easeInOutSine = function(b) {
          return -0.5 * (Math.cos(Math.PI * b) - 1);
        };
        var q = Array.prototype.find ? function(b, c2) {
          return b.find(c2);
        } : function(b, c2) {
          let l;
          const p = b.length;
          for (l = 0; l < p; l++)
            if (c2(b[l], l))
              return b[l];
        };
        I({
          map: "map",
          each: "forEach",
          grep: "filter",
          reduce: "reduce",
          some: "some"
        }, function(b, c2) {
          a2[c2] = function(l) {
            w(32, false, void 0, { [`Highcharts.${c2}`]: `use Array.${b}` });
            return Array.prototype[b].apply(l, [].slice.call(arguments, 1));
          };
        });
        let x;
        const c = function() {
          const b = Math.random().toString(36).substring(2, 9) + "-";
          let c2 = 0;
          return function() {
            return "highcharts-" + (x ? "" : b) + c2++;
          };
        }();
        d.jQuery && (d.jQuery.fn.highcharts = function() {
          const b = [].slice.call(arguments);
          if (this[0])
            return b[0] ? (new a2[B(b[0]) ? b.shift() : "Chart"](
              this[0],
              b[0],
              b[1]
            ), this) : e[h(this[0], "data-highcharts-chart")];
        });
        q = { addEvent: function(b, c2, l, d2 = {}) {
          var p = "function" === typeof b && b.prototype || b;
          Object.hasOwnProperty.call(p, "hcEvents") || (p.hcEvents = {});
          p = p.hcEvents;
          a2.Point && b instanceof a2.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = true);
          const e2 = b.addEventListener;
          e2 && e2.call(b, c2, l, a2.supportsPassiveEvents ? { passive: void 0 === d2.passive ? -1 !== c2.indexOf("touch") : d2.passive, capture: false } : false);
          p[c2] || (p[c2] = []);
          p[c2].push({ fn: l, order: "number" === typeof d2.order ? d2.order : Infinity });
          p[c2].sort((b2, c3) => b2.order - c3.order);
          return function() {
            F(b, c2, l);
          };
        }, arrayMax: function(b) {
          let c2 = b.length, l = b[0];
          for (; c2--; )
            b[c2] > l && (l = b[c2]);
          return l;
        }, arrayMin: function(b) {
          let c2 = b.length, l = b[0];
          for (; c2--; )
            b[c2] < l && (l = b[c2]);
          return l;
        }, attr: h, clamp: function(b, c2, l) {
          return b > c2 ? b < l ? b : l : c2;
        }, cleanRecursively: H, clearTimeout: function(b) {
          f(b) && clearTimeout(b);
        }, correctFloat: g, createElement: function(b, c2, l, d2, e2) {
          b = t.createElement(b);
          c2 && r(b, c2);
          e2 && n(b, { padding: "0", border: "none", margin: "0" });
          l && n(b, l);
          d2 && d2.appendChild(b);
          return b;
        }, css: n, defined: f, destroyObjectProperties: function(b, c2) {
          I(b, function(l, d2) {
            l && l !== c2 && l.destroy && l.destroy();
            delete b[d2];
          });
        }, discardElement: function(b) {
          b && b.parentElement && b.parentElement.removeChild(b);
        }, erase: function(b, c2) {
          let l = b.length;
          for (; l--; )
            if (b[l] === c2) {
              b.splice(l, 1);
              break;
            }
        }, error: w, extend: r, extendClass: function(b, c2) {
          const l = function() {
          };
          l.prototype = new b();
          r(l.prototype, c2);
          return l;
        }, find: q, fireEvent: z, getMagnitude: k, getNestedProperty: function(b, c2) {
          for (b = b.split("."); b.length && f(c2); ) {
            const l = b.shift();
            if ("undefined" === typeof l || "__proto__" === l)
              return;
            c2 = c2[l];
            if (!f(c2) || "function" === typeof c2 || "number" === typeof c2.nodeType || c2 === d)
              return;
          }
          return c2;
        }, getStyle: function(b, c2, l) {
          const e2 = a2.getStyle;
          let p;
          if ("width" === c2)
            return c2 = Math.min(b.offsetWidth, b.scrollWidth), l = b.getBoundingClientRect && b.getBoundingClientRect().width, l < c2 && l >= c2 - 1 && (c2 = Math.floor(l)), Math.max(0, c2 - (e2(b, "padding-left", true) || 0) - (e2(b, "padding-right", true) || 0));
          if ("height" === c2)
            return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - (e2(
              b,
              "padding-top",
              true
            ) || 0) - (e2(b, "padding-bottom", true) || 0));
          if (b = d.getComputedStyle(b, void 0))
            p = b.getPropertyValue(c2), m(l, "opacity" !== c2) && (p = K(p));
          return p;
        }, inArray: function(b, c2, l) {
          w(32, false, void 0, { "Highcharts.inArray": "use Array.indexOf" });
          return c2.indexOf(b, l);
        }, isArray: E, isClass: u, isDOMElement: A, isFunction: function(b) {
          return "function" === typeof b;
        }, isNumber: v, isObject: C, isString: B, keys: function(b) {
          w(32, false, void 0, { "Highcharts.keys": "use Object.keys" });
          return Object.keys(b);
        }, merge: function() {
          let b, c2 = arguments, l = {};
          const d2 = function(b2, c3) {
            "object" !== typeof b2 && (b2 = {});
            I(c3, function(l2, e3) {
              "__proto__" !== e3 && "constructor" !== e3 && (!C(l2, true) || u(l2) || A(l2) ? b2[e3] = c3[e3] : b2[e3] = d2(b2[e3] || {}, l2));
            });
            return b2;
          };
          true === c2[0] && (l = c2[1], c2 = Array.prototype.slice.call(c2, 2));
          const e2 = c2.length;
          for (b = 0; b < e2; b++)
            l = d2(l, c2[b]);
          return l;
        }, normalizeTickInterval: function(b, c2, l, d2, e2) {
          let p = b;
          l = m(l, k(b));
          const q2 = b / l;
          c2 || (c2 = e2 ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], false === d2 && (1 === l ? c2 = c2.filter(function(b2) {
            return 0 === b2 % 1;
          }) : 0.1 >= l && (c2 = [1 / l])));
          for (d2 = 0; d2 < c2.length && !(p = c2[d2], e2 && p * l >= b || !e2 && q2 <= (c2[d2] + (c2[d2 + 1] || c2[d2])) / 2); d2++)
            ;
          return p = g(p * l, -Math.round(Math.log(1e-3) / Math.LN10));
        }, objectEach: I, offset: function(b) {
          const c2 = t.documentElement;
          b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : { top: 0, left: 0, width: 0, height: 0 };
          return { top: b.top + (d.pageYOffset || c2.scrollTop) - (c2.clientTop || 0), left: b.left + (d.pageXOffset || c2.scrollLeft) - (c2.clientLeft || 0), width: b.width, height: b.height };
        }, pad: function(b, c2, l) {
          return Array((c2 || 2) + 1 - String(b).replace("-", "").length).join(l || "0") + b;
        }, pick: m, pInt: K, pushUnique: function(b, c2) {
          return 0 > b.indexOf(c2) && !!b.push(c2);
        }, relativeLength: function(b, c2, l) {
          return /%$/.test(b) ? c2 * parseFloat(b) / 100 + (l || 0) : parseFloat(b);
        }, removeEvent: F, splat: function(b) {
          return E(b) ? b : [b];
        }, stableSort: function(b, c2) {
          const l = b.length;
          let d2, e2;
          for (e2 = 0; e2 < l; e2++)
            b[e2].safeI = e2;
          b.sort(function(b2, l2) {
            d2 = c2(b2, l2);
            return 0 === d2 ? b2.safeI - l2.safeI : d2;
          });
          for (e2 = 0; e2 < l; e2++)
            delete b[e2].safeI;
        }, syncTimeout: function(b, c2, l) {
          if (0 < c2)
            return setTimeout(b, c2, l);
          b.call(0, l);
          return -1;
        }, timeUnits: {
          millisecond: 1,
          second: 1e3,
          minute: 6e4,
          hour: 36e5,
          day: 864e5,
          week: 6048e5,
          month: 24192e5,
          year: 314496e5
        }, uniqueKey: c, useSerialIds: function(b) {
          return x = m(b, x);
        }, wrap: function(b, c2, l) {
          const d2 = b[c2];
          b[c2] = function() {
            const b2 = arguments, c3 = this;
            return l.apply(this, [function() {
              return d2.apply(c3, arguments.length ? arguments : b2);
            }].concat([].slice.call(arguments)));
          };
        } };
        "";
        return q;
      });
      M(a, "Core/Chart/ChartDefaults.js", [], function() {
        return {
          alignThresholds: false,
          panning: { enabled: false, type: "x" },
          styledMode: false,
          borderRadius: 0,
          colorCount: 10,
          allowMutatingData: true,
          ignoreHiddenSeries: true,
          spacing: [10, 10, 15, 10],
          resetZoomButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } },
          reflow: true,
          type: "line",
          zoomBySingleTouch: false,
          zooming: { singleTouch: false, resetButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } } },
          width: null,
          height: null,
          borderColor: "#334eff",
          backgroundColor: "#ffffff",
          plotBorderColor: "#cccccc"
        };
      });
      M(a, "Core/Color/Color.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, y) {
        const { isNumber: w, merge: K, pInt: B } = y;
        class E {
          static parse(a3) {
            return a3 ? new E(a3) : E.None;
          }
          constructor(w2) {
            this.rgba = [NaN, NaN, NaN, NaN];
            this.input = w2;
            const A = a2.Color;
            if (A && A !== E)
              return new A(w2);
            this.init(w2);
          }
          init(a3) {
            let A;
            let u;
            if ("object" === typeof a3 && "undefined" !== typeof a3.stops)
              this.stops = a3.stops.map((f2) => new E(f2[1]));
            else if ("string" === typeof a3) {
              this.input = a3 = E.names[a3.toLowerCase()] || a3;
              if ("#" === a3.charAt(0)) {
                var v = a3.length;
                var f = parseInt(a3.substr(1), 16);
                7 === v ? A = [(f & 16711680) >> 16, (f & 65280) >> 8, f & 255, 1] : 4 === v && (A = [(f & 3840) >> 4 | (f & 3840) >> 8, (f & 240) >> 4 | f & 240, (f & 15) << 4 | f & 15, 1]);
              }
              if (!A)
                for (f = E.parsers.length; f-- && !A; )
                  u = E.parsers[f], (v = u.regex.exec(a3)) && (A = u.parse(v));
            }
            A && (this.rgba = A);
          }
          get(a3) {
            const A = this.input, u = this.rgba;
            if ("object" === typeof A && "undefined" !== typeof this.stops) {
              const v = K(A);
              v.stops = [].slice.call(v.stops);
              this.stops.forEach((f, h) => {
                v.stops[h] = [v.stops[h][0], f.get(a3)];
              });
              return v;
            }
            return u && w(u[0]) ? "rgb" === a3 || !a3 && 1 === u[3] ? "rgb(" + u[0] + "," + u[1] + "," + u[2] + ")" : "a" === a3 ? `${u[3]}` : "rgba(" + u.join(",") + ")" : A;
          }
          brighten(a3) {
            const A = this.rgba;
            if (this.stops)
              this.stops.forEach(function(u) {
                u.brighten(a3);
              });
            else if (w(a3) && 0 !== a3)
              for (let u = 0; 3 > u; u++)
                A[u] += B(255 * a3), 0 > A[u] && (A[u] = 0), 255 < A[u] && (A[u] = 255);
            return this;
          }
          setOpacity(a3) {
            this.rgba[3] = a3;
            return this;
          }
          tweenTo(a3, A) {
            const u = this.rgba, v = a3.rgba;
            if (!w(u[0]) || !w(v[0]))
              return a3.input || "none";
            a3 = 1 !== v[3] || 1 !== u[3];
            return (a3 ? "rgba(" : "rgb(") + Math.round(v[0] + (u[0] - v[0]) * (1 - A)) + "," + Math.round(v[1] + (u[1] - v[1]) * (1 - A)) + "," + Math.round(v[2] + (u[2] - v[2]) * (1 - A)) + (a3 ? "," + (v[3] + (u[3] - v[3]) * (1 - A)) : "") + ")";
          }
        }
        E.names = { white: "#ffffff", black: "#000000" };
        E.parsers = [{
          regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
          parse: function(a3) {
            return [B(a3[1]), B(a3[2]), B(a3[3]), parseFloat(a3[4], 10)];
          }
        }, { regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, parse: function(a3) {
          return [B(a3[1]), B(a3[2]), B(a3[3]), 1];
        } }];
        E.None = new E("");
        "";
        return E;
      });
      M(a, "Core/Color/Palettes.js", [], function() {
        return { colors: "#2caffe #544fc5 #00e272 #fe6a35 #6b8abc #d568fb #2ee0ca #fa4b42 #feb56a #91e8e1".split(" ") };
      });
      M(a, "Core/Time.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, y) {
        const { win: w } = a2, {
          defined: K,
          error: B,
          extend: E,
          isObject: C,
          merge: A,
          objectEach: u,
          pad: v,
          pick: f,
          splat: h,
          timeUnits: r
        } = y, m = a2.isSafari && w.Intl && w.Intl.DateTimeFormat.prototype.formatRange, n = a2.isSafari && w.Intl && !w.Intl.DateTimeFormat.prototype.formatRange;
        class k {
          constructor(g) {
            this.options = {};
            this.variableTimezone = this.useUTC = false;
            this.Date = w.Date;
            this.getTimezoneOffset = this.timezoneOffsetFunction();
            this.update(g);
          }
          get(g, m2) {
            if (this.variableTimezone || this.timezoneOffset) {
              const k2 = m2.getTime(), f2 = k2 - this.getTimezoneOffset(m2);
              m2.setTime(f2);
              g = m2["getUTC" + g]();
              m2.setTime(k2);
              return g;
            }
            return this.useUTC ? m2["getUTC" + g]() : m2["get" + g]();
          }
          set(g, k2, f2) {
            if (this.variableTimezone || this.timezoneOffset) {
              if ("Milliseconds" === g || "Seconds" === g || "Minutes" === g && 0 === this.getTimezoneOffset(k2) % 36e5)
                return k2["setUTC" + g](f2);
              var z = this.getTimezoneOffset(k2);
              z = k2.getTime() - z;
              k2.setTime(z);
              k2["setUTC" + g](f2);
              g = this.getTimezoneOffset(k2);
              z = k2.getTime() + g;
              return k2.setTime(z);
            }
            return this.useUTC || m && "FullYear" === g ? k2["setUTC" + g](f2) : k2["set" + g](f2);
          }
          update(g = {}) {
            const k2 = f(g.useUTC, true);
            this.options = g = A(
              true,
              this.options,
              g
            );
            this.Date = g.Date || w.Date || Date;
            this.timezoneOffset = (this.useUTC = k2) && g.timezoneOffset || void 0;
            this.getTimezoneOffset = this.timezoneOffsetFunction();
            this.variableTimezone = k2 && !(!g.getTimezoneOffset && !g.timezone);
          }
          makeTime(g, k2, m2, z, e, t) {
            let d, q, x;
            this.useUTC ? (d = this.Date.UTC.apply(0, arguments), q = this.getTimezoneOffset(d), d += q, x = this.getTimezoneOffset(d), q !== x ? d += x - q : q - 36e5 !== this.getTimezoneOffset(d - 36e5) || n || (d -= 36e5)) : d = new this.Date(g, k2, f(m2, 1), f(z, 0), f(e, 0), f(t, 0)).getTime();
            return d;
          }
          timezoneOffsetFunction() {
            const g = this, k2 = this.options, m2 = k2.getTimezoneOffset, f2 = k2.moment || w.moment;
            if (!this.useUTC)
              return function(e) {
                return 6e4 * new Date(e.toString()).getTimezoneOffset();
              };
            if (k2.timezone) {
              if (f2)
                return function(e) {
                  return 6e4 * -f2.tz(e, k2.timezone).utcOffset();
                };
              B(25);
            }
            return this.useUTC && m2 ? function(e) {
              return 6e4 * m2(e.valueOf());
            } : function() {
              return 6e4 * (g.timezoneOffset || 0);
            };
          }
          dateFormat(g, k2, m2) {
            if (!K(k2) || isNaN(k2))
              return a2.defaultOptions.lang && a2.defaultOptions.lang.invalidDate || "";
            g = f(g, "%Y-%m-%d %H:%M:%S");
            const n2 = this;
            var e = new this.Date(k2);
            const t = this.get("Hours", e), d = this.get("Day", e), q = this.get("Date", e), x = this.get("Month", e), c = this.get("FullYear", e), b = a2.defaultOptions.lang, p = b && b.weekdays, l = b && b.shortWeekdays;
            e = E({ a: l ? l[d] : p[d].substr(0, 3), A: p[d], d: v(q), e: v(q, 2, " "), w: d, b: b.shortMonths[x], B: b.months[x], m: v(x + 1), o: x + 1, y: c.toString().substr(2, 2), Y: c, H: v(t), k: t, I: v(t % 12 || 12), l: t % 12 || 12, M: v(this.get("Minutes", e)), p: 12 > t ? "AM" : "PM", P: 12 > t ? "am" : "pm", S: v(e.getSeconds()), L: v(Math.floor(k2 % 1e3), 3) }, a2.dateFormats);
            u(e, function(b2, c2) {
              for (; -1 !== g.indexOf("%" + c2); )
                g = g.replace("%" + c2, "function" === typeof b2 ? b2.call(n2, k2) : b2);
            });
            return m2 ? g.substr(0, 1).toUpperCase() + g.substr(1) : g;
          }
          resolveDTLFormat(g) {
            return C(g, true) ? g : (g = h(g), { main: g[0], from: g[1], to: g[2] });
          }
          getTimeTicks(g, k2, m2, n2) {
            const e = this, t = [], d = {};
            var q = new e.Date(k2);
            const x = g.unitRange, c = g.count || 1;
            let b;
            n2 = f(n2, 1);
            if (K(k2)) {
              e.set("Milliseconds", q, x >= r.second ? 0 : c * Math.floor(e.get("Milliseconds", q) / c));
              x >= r.second && e.set("Seconds", q, x >= r.minute ? 0 : c * Math.floor(e.get("Seconds", q) / c));
              x >= r.minute && e.set("Minutes", q, x >= r.hour ? 0 : c * Math.floor(e.get("Minutes", q) / c));
              x >= r.hour && e.set("Hours", q, x >= r.day ? 0 : c * Math.floor(e.get("Hours", q) / c));
              x >= r.day && e.set("Date", q, x >= r.month ? 1 : Math.max(1, c * Math.floor(e.get("Date", q) / c)));
              if (x >= r.month) {
                e.set("Month", q, x >= r.year ? 0 : c * Math.floor(e.get("Month", q) / c));
                var p = e.get("FullYear", q);
              }
              x >= r.year && e.set("FullYear", q, p - p % c);
              x === r.week && (p = e.get("Day", q), e.set("Date", q, e.get("Date", q) - p + n2 + (p < n2 ? -7 : 0)));
              p = e.get("FullYear", q);
              n2 = e.get("Month", q);
              const l = e.get(
                "Date",
                q
              ), g2 = e.get("Hours", q);
              k2 = q.getTime();
              !e.variableTimezone && e.useUTC || !K(m2) || (b = m2 - k2 > 4 * r.month || e.getTimezoneOffset(k2) !== e.getTimezoneOffset(m2));
              k2 = q.getTime();
              for (q = 1; k2 < m2; )
                t.push(k2), k2 = x === r.year ? e.makeTime(p + q * c, 0) : x === r.month ? e.makeTime(p, n2 + q * c) : !b || x !== r.day && x !== r.week ? b && x === r.hour && 1 < c ? e.makeTime(p, n2, l, g2 + q * c) : k2 + x * c : e.makeTime(p, n2, l + q * c * (x === r.day ? 1 : 7)), q++;
              t.push(k2);
              x <= r.hour && 1e4 > t.length && t.forEach(function(b2) {
                0 === b2 % 18e5 && "000000000" === e.dateFormat("%H%M%S%L", b2) && (d[b2] = "day");
              });
            }
            t.info = E(g, {
              higherRanks: d,
              totalRange: x * c
            });
            return t;
          }
          getDateFormat(g, k2, m2, f2) {
            const e = this.dateFormat("%m-%d %H:%M:%S.%L", k2), t = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 };
            let d, q = "millisecond";
            for (d in r) {
              if (g === r.week && +this.dateFormat("%w", k2) === m2 && "00:00:00.000" === e.substr(6)) {
                d = "week";
                break;
              }
              if (r[d] > g) {
                d = q;
                break;
              }
              if (t[d] && e.substr(t[d]) !== "01-01 00:00:00.000".substr(t[d]))
                break;
              "week" !== d && (q = d);
            }
            return this.resolveDTLFormat(f2[d]).main;
          }
        }
        "";
        return k;
      });
      M(a, "Core/Defaults.js", [
        a["Core/Chart/ChartDefaults.js"],
        a["Core/Color/Color.js"],
        a["Core/Globals.js"],
        a["Core/Color/Palettes.js"],
        a["Core/Time.js"],
        a["Core/Utilities.js"]
      ], function(a2, y, H, K, B, E) {
        const { isTouchDevice: w, svg: A } = H, { merge: u } = E, v = { colors: K.colors, symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: {
          loading: "Loading...",
          months: "January February March April May June July August September October November December".split(" "),
          shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
          weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
          decimalPoint: ".",
          numericSymbols: "kMGTPE".split(""),
          resetZoom: "Reset zoom",
          resetZoomTitle: "Reset zoom level 1:1",
          thousandsSep: " "
        }, global: {}, time: { Date: void 0, getTimezoneOffset: void 0, timezone: void 0, timezoneOffset: 0, useUTC: true }, chart: a2, title: { text: "Chart title", align: "center", margin: 15, widthAdjust: -44 }, subtitle: { text: "", align: "center", widthAdjust: -44 }, caption: { margin: 15, text: "", align: "left", verticalAlign: "bottom" }, plotOptions: {}, legend: {
          enabled: true,
          align: "center",
          alignColumns: true,
          className: "highcharts-no-tooltip",
          layout: "horizontal",
          itemMarginBottom: 2,
          itemMarginTop: 2,
          labelFormatter: function() {
            return this.name;
          },
          borderColor: "#999999",
          borderRadius: 0,
          navigation: { style: { fontSize: "0.8em" }, activeColor: "#0022ff", inactiveColor: "#cccccc" },
          itemStyle: { color: "#333333", cursor: "pointer", fontSize: "0.8em", textDecoration: "none", textOverflow: "ellipsis" },
          itemHoverStyle: { color: "#000000" },
          itemHiddenStyle: { color: "#666666", textDecoration: "line-through" },
          shadow: false,
          itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" },
          squareSymbol: true,
          symbolPadding: 5,
          verticalAlign: "bottom",
          x: 0,
          y: 0,
          title: { style: { fontSize: "0.8em", fontWeight: "bold" } }
        }, loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "45%" }, style: { position: "absolute", backgroundColor: "#ffffff", opacity: 0.5, textAlign: "center" } }, tooltip: { enabled: true, animation: A, borderRadius: 3, dateTimeLabelFormats: {
          millisecond: "%A, %e %b, %H:%M:%S.%L",
          second: "%A, %e %b, %H:%M:%S",
          minute: "%A, %e %b, %H:%M",
          hour: "%A, %e %b, %H:%M",
          day: "%A, %e %b %Y",
          week: "Week from %A, %e %b %Y",
          month: "%B %Y",
          year: "%Y"
        }, footerFormat: "", headerShape: "callout", hideDelay: 500, padding: 8, shape: "callout", shared: false, snap: w ? 25 : 10, headerFormat: '<span style="font-size: 0.8em">{point.key}</span><br/>', pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>', backgroundColor: "#ffffff", borderWidth: void 0, shadow: true, stickOnContact: false, style: { color: "#333333", cursor: "default", fontSize: "0.8em" }, useHTML: false }, credits: { enabled: true, href: "https://www.highcharts.com?credits", position: {
          align: "right",
          x: -10,
          verticalAlign: "bottom",
          y: -5
        }, style: { cursor: "pointer", color: "#999999", fontSize: "0.6em" }, text: "Highcharts.com" } };
        v.chart.styledMode = false;
        "";
        const f = new B(v.time);
        a2 = { defaultOptions: v, defaultTime: f, getOptions: function() {
          return v;
        }, setOptions: function(h) {
          u(true, v, h);
          if (h.time || h.global)
            H.time ? H.time.update(u(v.global, v.time, h.global, h.time)) : H.time = f;
          return v;
        } };
        "";
        return a2;
      });
      M(a, "Core/Animation/Fx.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, y, H) {
        const { parse: w } = a2, { win: B } = y, { isNumber: E, objectEach: C } = H;
        class A {
          constructor(a3, v, f) {
            this.pos = NaN;
            this.options = v;
            this.elem = a3;
            this.prop = f;
          }
          dSetter() {
            var a3 = this.paths;
            const v = a3 && a3[0];
            a3 = a3 && a3[1];
            const f = this.now || 0;
            let h = [];
            if (1 !== f && v && a3)
              if (v.length === a3.length && 1 > f)
                for (let r = 0; r < a3.length; r++) {
                  const m = v[r], n = a3[r], k = [];
                  for (let g = 0; g < n.length; g++) {
                    const a4 = m[g], h2 = n[g];
                    E(a4) && E(h2) && ("A" !== n[0] || 4 !== g && 5 !== g) ? k[g] = a4 + f * (h2 - a4) : k[g] = h2;
                  }
                  h.push(k);
                }
              else
                h = a3;
            else
              h = this.toD || [];
            this.elem.attr("d", h, void 0, true);
          }
          update() {
            const a3 = this.elem, v = this.prop, f = this.now, h = this.options.step;
            if (this[v + "Setter"])
              this[v + "Setter"]();
            else
              a3.attr ? a3.element && a3.attr(v, f, null, true) : a3.style[v] = f + this.unit;
            h && h.call(a3, f, this);
          }
          run(a3, v, f) {
            const h = this, r = h.options, m = function(g) {
              return m.stopped ? false : h.step(g);
            }, n = B.requestAnimationFrame || function(g) {
              setTimeout(g, 13);
            }, k = function() {
              for (let g = 0; g < A.timers.length; g++)
                A.timers[g]() || A.timers.splice(g--, 1);
              A.timers.length && n(k);
            };
            a3 !== v || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +/* @__PURE__ */ new Date(), this.start = a3, this.end = v, this.unit = f, this.now = this.start, this.pos = 0, m.elem = this.elem, m.prop = this.prop, m() && 1 === A.timers.push(m) && n(k)) : (delete r.curAnim[this.prop], r.complete && 0 === Object.keys(r.curAnim).length && r.complete.call(this.elem));
          }
          step(a3) {
            const v = +/* @__PURE__ */ new Date(), f = this.options, h = this.elem, r = f.complete, m = f.duration, n = f.curAnim;
            let k;
            h.attr && !h.element ? a3 = false : a3 || v >= m + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), k = n[this.prop] = true, C(n, function(g) {
              true !== g && (k = false);
            }), k && r && r.call(h), a3 = false) : (this.pos = f.easing((v - this.startTime) / m), this.now = this.start + (this.end - this.start) * this.pos, this.update(), a3 = true);
            return a3;
          }
          initPath(a3, v, f) {
            function h(e, t) {
              for (; e.length < F; ) {
                var d = e[0];
                const q = t[F - e.length];
                q && "M" === d[0] && (e[0] = "C" === q[0] ? ["C", d[1], d[2], d[1], d[2], d[1], d[2]] : ["L", d[1], d[2]]);
                e.unshift(d);
                k && (d = e.pop(), e.push(e[e.length - 1], d));
              }
            }
            function r(e, t) {
              for (; e.length < F; )
                if (t = e[Math.floor(e.length / g) - 1].slice(), "C" === t[0] && (t[1] = t[5], t[2] = t[6]), k) {
                  const d = e[Math.floor(e.length / g)].slice();
                  e.splice(e.length / 2, 0, t, d);
                } else
                  e.push(t);
            }
            const m = a3.startX, n = a3.endX;
            f = f.slice();
            const k = a3.isArea, g = k ? 2 : 1;
            let I, F, z;
            v = v && v.slice();
            if (!v)
              return [f, f];
            if (m && n && n.length) {
              for (a3 = 0; a3 < m.length; a3++)
                if (m[a3] === n[0]) {
                  I = a3;
                  break;
                } else if (m[0] === n[n.length - m.length + a3]) {
                  I = a3;
                  z = true;
                  break;
                } else if (m[m.length - 1] === n[n.length - m.length + a3]) {
                  I = m.length - a3;
                  break;
                }
              "undefined" === typeof I && (v = []);
            }
            v.length && E(I) && (F = f.length + I * g, z ? (h(v, f), r(f, v)) : (h(f, v), r(v, f)));
            return [v, f];
          }
          fillSetter() {
            A.prototype.strokeSetter.apply(this, arguments);
          }
          strokeSetter() {
            this.elem.attr(this.prop, w(this.start).tweenTo(
              w(this.end),
              this.pos
            ), void 0, true);
          }
        }
        A.timers = [];
        return A;
      });
      M(a, "Core/Animation/AnimationUtilities.js", [a["Core/Animation/Fx.js"], a["Core/Utilities.js"]], function(a2, y) {
        function w(a3) {
          return u(a3) ? v({ duration: 500, defer: 0 }, a3) : { duration: a3 ? 500 : 0, defer: 0 };
        }
        function K(f2, m) {
          let n = a2.timers.length;
          for (; n--; )
            a2.timers[n].elem !== f2 || m && m !== a2.timers[n].prop || (a2.timers[n].stopped = true);
        }
        const { defined: B, getStyle: E, isArray: C, isNumber: A, isObject: u, merge: v, objectEach: f, pick: h } = y;
        return { animate: function(h2, m, n) {
          let k, g = "", r, F, z;
          u(n) || (z = arguments, n = { duration: z[2], easing: z[3], complete: z[4] });
          A(n.duration) || (n.duration = 400);
          n.easing = "function" === typeof n.easing ? n.easing : Math[n.easing] || Math.easeInOutSine;
          n.curAnim = v(m);
          f(m, function(e, t) {
            K(h2, t);
            F = new a2(h2, n, t);
            r = void 0;
            "d" === t && C(m.d) ? (F.paths = F.initPath(h2, h2.pathArray, m.d), F.toD = m.d, k = 0, r = 1) : h2.attr ? k = h2.attr(t) : (k = parseFloat(E(h2, t)) || 0, "opacity" !== t && (g = "px"));
            r || (r = e);
            "string" === typeof r && r.match("px") && (r = r.replace(/px/g, ""));
            F.run(k, r, g);
          });
        }, animObject: w, getDeferredAnimation: function(a3, m, f2) {
          const k = w(m);
          let g = 0, n = 0;
          (f2 ? [f2] : a3.series).forEach((a4) => {
            a4 = w(a4.options.animation);
            g = m && B(m.defer) ? k.defer : Math.max(g, a4.duration + a4.defer);
            n = Math.min(k.duration, a4.duration);
          });
          a3.renderer.forExport && (g = 0);
          return { defer: Math.max(0, g - n), duration: Math.min(g, n) };
        }, setAnimation: function(a3, m) {
          m.renderer.globalAnimation = h(a3, m.options.chart.animation, true);
        }, stop: K };
      });
      M(a, "Core/Renderer/HTML/AST.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, y) {
        const { SVG_NS: w, win: K } = a2, {
          attr: B,
          createElement: E,
          css: C,
          error: A,
          isFunction: u,
          isString: v,
          objectEach: f,
          splat: h
        } = y;
        ({ trustedTypes: y } = K);
        const r = y && u(y.createPolicy) && y.createPolicy("highcharts", { createHTML: (g) => g });
        y = r ? r.createHTML("") : "";
        try {
          var m = !!new DOMParser().parseFromString(y, "text/html");
        } catch (g) {
          m = false;
        }
        const n = m;
        class k {
          static filterUserAttributes(g) {
            f(g, (a3, m2) => {
              let f2 = true;
              -1 === k.allowedAttributes.indexOf(m2) && (f2 = false);
              -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(m2) && (f2 = v(a3) && k.allowedReferences.some((e) => 0 === a3.indexOf(e)));
              f2 || (A(
                33,
                false,
                void 0,
                { "Invalid attribute in config": `${m2}` }
              ), delete g[m2]);
              v(a3) && g[m2] && (g[m2] = a3.replace(/</g, "&lt;"));
            });
            return g;
          }
          static parseStyle(g) {
            return g.split(";").reduce((g2, k2) => {
              k2 = k2.split(":").map((e) => e.trim());
              const a3 = k2.shift();
              a3 && k2.length && (g2[a3.replace(/-([a-z])/g, (e) => e[1].toUpperCase())] = k2.join(":"));
              return g2;
            }, {});
          }
          static setElementHTML(g, a3) {
            g.innerHTML = k.emptyHTML;
            a3 && new k(a3).addToDOM(g);
          }
          constructor(g) {
            this.nodes = "string" === typeof g ? this.parseMarkup(g) : g;
          }
          addToDOM(g) {
            function m2(g2, n2) {
              let e;
              h(g2).forEach(function(t) {
                var d = t.tagName;
                const q = t.textContent ? a2.doc.createTextNode(t.textContent) : void 0, g3 = k.bypassHTMLFiltering;
                let c;
                if (d)
                  if ("#text" === d)
                    c = q;
                  else if (-1 !== k.allowedTags.indexOf(d) || g3) {
                    d = a2.doc.createElementNS("svg" === d ? w : n2.namespaceURI || w, d);
                    const b = t.attributes || {};
                    f(t, function(c2, l) {
                      "tagName" !== l && "attributes" !== l && "children" !== l && "style" !== l && "textContent" !== l && (b[l] = c2);
                    });
                    B(d, g3 ? b : k.filterUserAttributes(b));
                    t.style && C(d, t.style);
                    q && d.appendChild(q);
                    m2(t.children || [], d);
                    c = d;
                  } else
                    A(33, false, void 0, { "Invalid tagName in config": d });
                c && n2.appendChild(c);
                e = c;
              });
              return e;
            }
            return m2(this.nodes, g);
          }
          parseMarkup(g) {
            const a3 = [];
            g = g.trim().replace(/ style=(["'])/g, " data-style=$1");
            if (n)
              g = new DOMParser().parseFromString(r ? r.createHTML(g) : g, "text/html");
            else {
              const k2 = E("div");
              k2.innerHTML = g;
              g = { body: k2 };
            }
            const m2 = (g2, e) => {
              var t = g2.nodeName.toLowerCase();
              const d = { tagName: t };
              "#text" === t && (d.textContent = g2.textContent || "");
              if (t = g2.attributes) {
                const e2 = {};
                [].forEach.call(t, (q) => {
                  "data-style" === q.name ? d.style = k.parseStyle(q.value) : e2[q.name] = q.value;
                });
                d.attributes = e2;
              }
              if (g2.childNodes.length) {
                const e2 = [];
                [].forEach.call(g2.childNodes, (d2) => {
                  m2(d2, e2);
                });
                e2.length && (d.children = e2);
              }
              e.push(d);
            };
            [].forEach.call(g.body.childNodes, (g2) => m2(g2, a3));
            return a3;
          }
        }
        k.allowedAttributes = "alt aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill flood-color flood-opacity height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align text-anchor textAnchor textLength title type valign width x x1 x2 xlink:href y y1 y2 zIndex".split(" ");
        k.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
        k.allowedTags = "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feDropShadow feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text textPath thead title tbody tspan td th tr u ul #text".split(" ");
        k.emptyHTML = y;
        k.bypassHTMLFiltering = false;
        "";
        return k;
      });
      M(a, "Core/FormatUtilities.js", [a["Core/Defaults.js"], a["Core/Utilities.js"]], function(a2, y) {
        function w(a3, f, h, r) {
          a3 = +a3 || 0;
          f = +f;
          const m = K.lang;
          var n = (a3.toString().split(".")[1] || "").split("e")[0].length;
          const k = a3.toString().split("e"), g = f;
          if (-1 === f)
            f = Math.min(n, 20);
          else if (!C(f))
            f = 2;
          else if (f && k[1] && 0 > k[1]) {
            var v = f + +k[1];
            0 <= v ? (k[0] = (+k[0]).toExponential(v).split("e")[0], f = v) : (k[0] = k[0].split(".")[0] || 0, a3 = 20 > f ? (k[0] * Math.pow(10, k[1])).toFixed(f) : 0, k[1] = 0);
          }
          v = (Math.abs(k[1] ? k[0] : a3) + Math.pow(
            10,
            -Math.max(f, n) - 1
          )).toFixed(f);
          n = String(u(v));
          const F = 3 < n.length ? n.length % 3 : 0;
          h = A(h, m.decimalPoint);
          r = A(r, m.thousandsSep);
          a3 = (0 > a3 ? "-" : "") + (F ? n.substr(0, F) + r : "");
          a3 = 0 > +k[1] && !g ? "0" : a3 + n.substr(F).replace(/(\d{3})(?=\d)/g, "$1" + r);
          f && (a3 += h + v.slice(-f));
          k[1] && 0 !== +a3 && (a3 += "e" + k[1]);
          return a3;
        }
        const { defaultOptions: K, defaultTime: B } = a2, { getNestedProperty: E, isNumber: C, pick: A, pInt: u } = y;
        return { dateFormat: function(a3, f, h) {
          return B.dateFormat(a3, f, h);
        }, format: function(a3, f, h) {
          var r = "{";
          let m = false;
          let n;
          const k = /f$/, g = /\.([0-9])/, v = K.lang, F = h && h.time || B;
          h = h && h.numberFormatter || w;
          const z = [];
          for (; a3; ) {
            n = a3.indexOf(r);
            if (-1 === n)
              break;
            var e = a3.slice(0, n);
            if (m) {
              e = e.split(":");
              r = E(e.shift() || "", f);
              if (e.length && "number" === typeof r)
                if (e = e.join(":"), k.test(e)) {
                  const t = parseInt((e.match(g) || ["", "-1"])[1], 10);
                  null !== r && (r = h(r, t, v.decimalPoint, -1 < e.indexOf(",") ? v.thousandsSep : ""));
                } else
                  r = F.dateFormat(e, r);
              z.push(r);
            } else
              z.push(e);
            a3 = a3.slice(n + 1);
            r = (m = !m) ? "}" : "{";
          }
          z.push(a3);
          return z.join("");
        }, numberFormat: w };
      });
      M(
        a,
        "Core/Renderer/RendererUtilities.js",
        [a["Core/Utilities.js"]],
        function(a2) {
          const { clamp: w, pick: H, stableSort: K } = a2;
          var B;
          (function(a3) {
            function y(a4, u, v) {
              const f = a4;
              var h = f.reducedLen || u, r = (a5, g2) => (g2.rank || 0) - (a5.rank || 0);
              const m = (a5, g2) => a5.target - g2.target;
              let n, k = true, g = [], I = 0;
              for (n = a4.length; n--; )
                I += a4[n].size;
              if (I > h) {
                K(a4, r);
                for (I = n = 0; I <= h; )
                  I += a4[n].size, n++;
                g = a4.splice(n - 1, a4.length);
              }
              K(a4, m);
              for (a4 = a4.map((a5) => ({ size: a5.size, targets: [a5.target], align: H(a5.align, 0.5) })); k; ) {
                for (n = a4.length; n--; )
                  h = a4[n], r = (Math.min.apply(0, h.targets) + Math.max.apply(0, h.targets)) / 2, h.pos = w(r - h.size * h.align, 0, u - h.size);
                n = a4.length;
                for (k = false; n--; )
                  0 < n && a4[n - 1].pos + a4[n - 1].size > a4[n].pos && (a4[n - 1].size += a4[n].size, a4[n - 1].targets = a4[n - 1].targets.concat(a4[n].targets), a4[n - 1].align = 0.5, a4[n - 1].pos + a4[n - 1].size > u && (a4[n - 1].pos = u - a4[n - 1].size), a4.splice(n, 1), k = true);
              }
              f.push.apply(f, g);
              n = 0;
              a4.some((a5) => {
                let g2 = 0;
                return (a5.targets || []).some(() => {
                  f[n].pos = a5.pos + g2;
                  if ("undefined" !== typeof v && Math.abs(f[n].pos - f[n].target) > v)
                    return f.slice(0, n + 1).forEach((e) => delete e.pos), f.reducedLen = (f.reducedLen || u) - 0.1 * u, f.reducedLen > 0.1 * u && y(f, u, v), true;
                  g2 += f[n].size;
                  n++;
                  return false;
                });
              });
              K(f, m);
              return f;
            }
            a3.distribute = y;
          })(B || (B = {}));
          return B;
        }
      );
      M(a, "Core/Renderer/SVG/SVGElement.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, y, H, K) {
        const { animate: w, animObject: E, stop: C } = a2, { deg2rad: A, doc: u, svg: v, SVG_NS: f, win: h } = H, {
          addEvent: r,
          attr: m,
          createElement: n,
          css: k,
          defined: g,
          erase: I,
          extend: F,
          fireEvent: z,
          isArray: e,
          isFunction: t,
          isObject: d,
          isString: q,
          merge: x,
          objectEach: c,
          pick: b,
          pInt: p,
          syncTimeout: l,
          uniqueKey: L
        } = K;
        class N {
          constructor() {
            this.element = void 0;
            this.onEvents = {};
            this.opacity = 1;
            this.renderer = void 0;
            this.SVG_NS = f;
          }
          _defaultGetter(c2) {
            c2 = b(this[c2 + "Value"], this[c2], this.element ? this.element.getAttribute(c2) : null, 0);
            /^[\-0-9\.]+$/.test(c2) && (c2 = parseFloat(c2));
            return c2;
          }
          _defaultSetter(b2, c2, l2) {
            l2.setAttribute(c2, b2);
          }
          add(b2) {
            const c2 = this.renderer, l2 = this.element;
            let d2;
            b2 && (this.parentGroup = b2);
            "undefined" !== typeof this.textStr && "text" === this.element.nodeName && c2.buildText(this);
            this.added = true;
            if (!b2 || b2.handleZ || this.zIndex)
              d2 = this.zIndexSetter();
            d2 || (b2 ? b2.element : c2.box).appendChild(l2);
            if (this.onAdd)
              this.onAdd();
            return this;
          }
          addClass(b2, c2) {
            const l2 = c2 ? "" : this.attr("class") || "";
            b2 = (b2 || "").split(/ /g).reduce(function(b3, c3) {
              -1 === l2.indexOf(c3) && b3.push(c3);
              return b3;
            }, l2 ? [l2] : []).join(" ");
            b2 !== l2 && this.attr("class", b2);
            return this;
          }
          afterSetters() {
            this.doTransform && (this.updateTransform(), this.doTransform = false);
          }
          align(c2, l2, d2) {
            const e2 = {};
            var G = this.renderer, p2 = G.alignedObjects, a3;
            let g2, t2;
            if (c2) {
              if (this.alignOptions = c2, this.alignByTranslate = l2, !d2 || q(d2))
                this.alignTo = a3 = d2 || "renderer", I(p2, this), p2.push(this), d2 = void 0;
            } else
              c2 = this.alignOptions, l2 = this.alignByTranslate, a3 = this.alignTo;
            d2 = b(d2, G[a3], "scrollablePlotBox" === a3 ? G.plotBox : void 0, G);
            a3 = c2.align;
            const D = c2.verticalAlign;
            G = (d2.x || 0) + (c2.x || 0);
            p2 = (d2.y || 0) + (c2.y || 0);
            "right" === a3 ? g2 = 1 : "center" === a3 && (g2 = 2);
            g2 && (G += (d2.width - (c2.width || 0)) / g2);
            e2[l2 ? "translateX" : "x"] = Math.round(G);
            "bottom" === D ? t2 = 1 : "middle" === D && (t2 = 2);
            t2 && (p2 += (d2.height - (c2.height || 0)) / t2);
            e2[l2 ? "translateY" : "y"] = Math.round(p2);
            this[this.placed ? "animate" : "attr"](e2);
            this.placed = true;
            this.alignAttr = e2;
            return this;
          }
          alignSetter(b2) {
            const c2 = { left: "start", center: "middle", right: "end" };
            c2[b2] && (this.alignValue = b2, this.element.setAttribute("text-anchor", c2[b2]));
          }
          animate(d2, e2, p2) {
            const q2 = E(b(e2, this.renderer.globalAnimation, true));
            e2 = q2.defer;
            u.hidden && (q2.duration = 0);
            0 !== q2.duration ? (p2 && (q2.complete = p2), l(() => {
              this.element && w(this, d2, q2);
            }, e2)) : (this.attr(d2, void 0, p2 || q2.complete), c(d2, function(b2, c2) {
              q2.step && q2.step.call(this, b2, { prop: c2, pos: 1, elem: this });
            }, this));
            return this;
          }
          applyTextOutline(b2) {
            const c2 = this.element;
            -1 !== b2.indexOf("contrast") && (b2 = b2.replace(/contrast/g, this.renderer.getContrast(c2.style.fill)));
            var d2 = b2.split(" ");
            b2 = d2[d2.length - 1];
            if ((d2 = d2[0]) && "none" !== d2 && H.svg) {
              this.fakeTS = true;
              d2 = d2.replace(/(^[\d\.]+)(.*?)$/g, function(b3, c3, d3) {
                return 2 * Number(c3) + d3;
              });
              this.removeTextOutline();
              const l2 = u.createElementNS(f, "tspan");
              m(l2, { "class": "highcharts-text-outline", fill: b2, stroke: b2, "stroke-width": d2, "stroke-linejoin": "round" });
              b2 = c2.querySelector("textPath") || c2;
              [].forEach.call(
                b2.childNodes,
                (b3) => {
                  const c3 = b3.cloneNode(true);
                  c3.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach((b4) => c3.removeAttribute(b4));
                  l2.appendChild(c3);
                }
              );
              let e2 = 0;
              [].forEach.call(b2.querySelectorAll("text tspan"), (b3) => {
                e2 += Number(b3.getAttribute("dy"));
              });
              d2 = u.createElementNS(f, "tspan");
              d2.textContent = "​";
              m(d2, { x: Number(c2.getAttribute("x")), dy: -e2 });
              l2.appendChild(d2);
              b2.insertBefore(l2, b2.firstChild);
            }
          }
          attr(b2, d2, l2, e2) {
            const G = this.element, p2 = N.symbolCustomAttribs;
            let q2, a3, g2 = this, D, t2;
            "string" === typeof b2 && "undefined" !== typeof d2 && (q2 = b2, b2 = {}, b2[q2] = d2);
            "string" === typeof b2 ? g2 = (this[b2 + "Getter"] || this._defaultGetter).call(this, b2, G) : (c(b2, function(c2, d3) {
              D = false;
              e2 || C(this, d3);
              this.symbolName && -1 !== p2.indexOf(d3) && (a3 || (this.symbolAttr(b2), a3 = true), D = true);
              !this.rotation || "x" !== d3 && "y" !== d3 || (this.doTransform = true);
              D || (t2 = this[d3 + "Setter"] || this._defaultSetter, t2.call(this, c2, d3, G));
            }, this), this.afterSetters());
            l2 && l2.call(this);
            return g2;
          }
          clip(b2) {
            return this.attr("clip-path", b2 ? "url(" + this.renderer.url + "#" + b2.id + ")" : "none");
          }
          crisp(b2, c2) {
            c2 = c2 || b2.strokeWidth || 0;
            const d2 = Math.round(c2) % 2 / 2;
            b2.x = Math.floor(b2.x || this.x || 0) + d2;
            b2.y = Math.floor(b2.y || this.y || 0) + d2;
            b2.width = Math.floor((b2.width || this.width || 0) - 2 * d2);
            b2.height = Math.floor((b2.height || this.height || 0) - 2 * d2);
            g(b2.strokeWidth) && (b2.strokeWidth = c2);
            return b2;
          }
          complexColor(b2, d2, l2) {
            const p2 = this.renderer;
            let G, q2, a3, t2, k2, D, m2, J, O, f2, n2 = [], h2;
            z(this.renderer, "complexColor", { args: arguments }, function() {
              b2.radialGradient ? q2 = "radialGradient" : b2.linearGradient && (q2 = "linearGradient");
              if (q2) {
                a3 = b2[q2];
                k2 = p2.gradients;
                D = b2.stops;
                O = l2.radialReference;
                e(a3) && (b2[q2] = a3 = { x1: a3[0], y1: a3[1], x2: a3[2], y2: a3[3], gradientUnits: "userSpaceOnUse" });
                "radialGradient" === q2 && O && !g(a3.gradientUnits) && (t2 = a3, a3 = x(a3, p2.getRadialAttr(O, t2), { gradientUnits: "userSpaceOnUse" }));
                c(a3, function(b3, c2) {
                  "id" !== c2 && n2.push(c2, b3);
                });
                c(D, function(b3) {
                  n2.push(b3);
                });
                n2 = n2.join(",");
                if (k2[n2])
                  f2 = k2[n2].attr("id");
                else {
                  a3.id = f2 = L();
                  const b3 = k2[n2] = p2.createElement(q2).attr(a3).add(p2.defs);
                  b3.radAttr = t2;
                  b3.stops = [];
                  D.forEach(function(c2) {
                    0 === c2[1].indexOf("rgba") ? (G = y.parse(c2[1]), m2 = G.get("rgb"), J = G.get("a")) : (m2 = c2[1], J = 1);
                    c2 = p2.createElement("stop").attr({
                      offset: c2[0],
                      "stop-color": m2,
                      "stop-opacity": J
                    }).add(b3);
                    b3.stops.push(c2);
                  });
                }
                h2 = "url(" + p2.url + "#" + f2 + ")";
                l2.setAttribute(d2, h2);
                l2.gradient = n2;
                b2.toString = function() {
                  return h2;
                };
              }
            });
          }
          css(b2) {
            const d2 = this.styles, l2 = {}, e2 = this.element;
            let G, q2 = !d2;
            b2.color && (b2.fill = b2.color);
            d2 && c(b2, function(b3, c2) {
              d2 && d2[c2] !== b3 && (l2[c2] = b3, q2 = true);
            });
            if (q2) {
              d2 && (b2 = F(d2, l2));
              null === b2.width || "auto" === b2.width ? delete this.textWidth : "text" === e2.nodeName.toLowerCase() && b2.width && (G = this.textWidth = p(b2.width));
              this.styles = b2;
              G && !v && this.renderer.forExport && delete b2.width;
              const c2 = x(b2);
              e2.namespaceURI === this.SVG_NS && ["textOutline", "textOverflow", "width"].forEach((b3) => c2 && delete c2[b3]);
              k(e2, c2);
            }
            this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), b2.textOutline && this.applyTextOutline(b2.textOutline));
            return this;
          }
          dashstyleSetter(c2) {
            let d2 = this["stroke-width"];
            "inherit" === d2 && (d2 = 1);
            if (c2 = c2 && c2.toLowerCase()) {
              const l2 = c2.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(
                /dot/g,
                "1,3,"
              ).replace("dash", "4,3,").replace(/,$/, "").split(",");
              for (c2 = l2.length; c2--; )
                l2[c2] = "" + p(l2[c2]) * b(d2, NaN);
              c2 = l2.join(",").replace(/NaN/g, "none");
              this.element.setAttribute("stroke-dasharray", c2);
            }
          }
          destroy() {
            const b2 = this;
            var d2 = b2.element || {};
            const l2 = b2.renderer;
            var e2 = d2.ownerSVGElement;
            let G = "SPAN" === d2.nodeName && b2.parentGroup || void 0;
            d2.onclick = d2.onmouseout = d2.onmouseover = d2.onmousemove = d2.point = null;
            C(b2);
            if (b2.clipPath && e2) {
              const c2 = b2.clipPath;
              [].forEach.call(e2.querySelectorAll("[clip-path],[CLIP-PATH]"), function(b3) {
                -1 < b3.getAttribute("clip-path").indexOf(c2.element.id) && b3.removeAttribute("clip-path");
              });
              b2.clipPath = c2.destroy();
            }
            if (b2.stops) {
              for (e2 = 0; e2 < b2.stops.length; e2++)
                b2.stops[e2].destroy();
              b2.stops.length = 0;
              b2.stops = void 0;
            }
            for (b2.safeRemoveChild(d2); G && G.div && 0 === G.div.childNodes.length; )
              d2 = G.parentGroup, b2.safeRemoveChild(G.div), delete G.div, G = d2;
            b2.alignTo && I(l2.alignedObjects, b2);
            c(b2, function(c2, d3) {
              b2[d3] && b2[d3].parentGroup === b2 && b2[d3].destroy && b2[d3].destroy();
              delete b2[d3];
            });
          }
          dSetter(b2, c2, d2) {
            e(b2) && ("string" === typeof b2[0] && (b2 = this.renderer.pathToSegments(b2)), this.pathArray = b2, b2 = b2.reduce((b3, c3, d3) => c3 && c3.join ? (d3 ? b3 + " " : "") + c3.join(" ") : (c3 || "").toString(), ""));
            /(NaN| {2}|^$)/.test(b2) && (b2 = "M 0 0");
            this[c2] !== b2 && (d2.setAttribute(c2, b2), this[c2] = b2);
          }
          fadeOut(c2) {
            const d2 = this;
            d2.animate({ opacity: 0 }, { duration: b(c2, 150), complete: function() {
              d2.hide();
            } });
          }
          fillSetter(b2, c2, d2) {
            "string" === typeof b2 ? d2.setAttribute(c2, b2) : b2 && this.complexColor(b2, c2, d2);
          }
          getBBox(c2, d2) {
            const { alignValue: l2, element: e2, renderer: G, styles: p2, textStr: q2 } = this, { cache: a3, cacheKeys: m2 } = G;
            var D = e2.namespaceURI === this.SVG_NS;
            d2 = b(d2, this.rotation, 0);
            var P = G.styledMode ? e2 && N.prototype.getStyle.call(e2, "font-size") : p2 && p2.fontSize;
            let J;
            let f2;
            g(q2) && (f2 = q2.toString(), -1 === f2.indexOf("<") && (f2 = f2.replace(/[0-9]/g, "0")), f2 += ["", G.rootFontSize, P, d2, this.textWidth, l2, p2 && p2.textOverflow, p2 && p2.fontWeight].join());
            f2 && !c2 && (J = a3[f2]);
            if (!J) {
              if (D || G.forExport) {
                try {
                  var x2 = this.fakeTS && function(b2) {
                    const c3 = e2.querySelector(".highcharts-text-outline");
                    c3 && k(c3, { display: b2 });
                  };
                  t(x2) && x2("none");
                  J = e2.getBBox ? F({}, e2.getBBox()) : {
                    width: e2.offsetWidth,
                    height: e2.offsetHeight,
                    x: 0,
                    y: 0
                  };
                  t(x2) && x2("");
                } catch (ia) {
                  "";
                }
                if (!J || 0 > J.width)
                  J = { x: 0, y: 0, width: 0, height: 0 };
              } else
                J = this.htmlGetBBox();
              x2 = J.width;
              c2 = J.height;
              D && (J.height = c2 = { "11px,17": 14, "13px,20": 16 }[`${P || ""},${Math.round(c2)}`] || c2);
              if (d2) {
                D = Number(e2.getAttribute("y") || 0) - J.y;
                P = { right: 1, center: 0.5 }[l2 || 0] || 0;
                var n2 = d2 * A, h2 = (d2 - 90) * A, L2 = x2 * Math.cos(n2);
                d2 = x2 * Math.sin(n2);
                var O = Math.cos(h2);
                n2 = Math.sin(h2);
                x2 = J.x + P * (x2 - L2) + D * O;
                h2 = x2 + L2;
                O = h2 - c2 * O;
                L2 = O - L2;
                D = J.y + D - P * d2 + D * n2;
                P = D + d2;
                c2 = P - c2 * n2;
                d2 = c2 - d2;
                J.x = Math.min(x2, h2, O, L2);
                J.y = Math.min(D, P, c2, d2);
                J.width = Math.max(
                  x2,
                  h2,
                  O,
                  L2
                ) - J.x;
                J.height = Math.max(D, P, c2, d2) - J.y;
              }
            }
            if (f2 && ("" === q2 || 0 < J.height)) {
              for (; 250 < m2.length; )
                delete a3[m2.shift()];
              a3[f2] || m2.push(f2);
              a3[f2] = J;
            }
            return J;
          }
          getStyle(b2) {
            return h.getComputedStyle(this.element || this, "").getPropertyValue(b2);
          }
          hasClass(b2) {
            return -1 !== ("" + this.attr("class")).split(" ").indexOf(b2);
          }
          hide() {
            return this.attr({ visibility: "hidden" });
          }
          htmlGetBBox() {
            return { height: 0, width: 0, x: 0, y: 0 };
          }
          init(b2, c2) {
            this.element = "span" === c2 ? n(c2) : u.createElementNS(this.SVG_NS, c2);
            this.renderer = b2;
            z(this, "afterInit");
          }
          on(b2, c2) {
            const { onEvents: d2 } = this;
            if (d2[b2])
              d2[b2]();
            d2[b2] = r(this.element, b2, c2);
            return this;
          }
          opacitySetter(b2, c2, d2) {
            this.opacity = b2 = Number(Number(b2).toFixed(3));
            d2.setAttribute(c2, b2);
          }
          removeClass(b2) {
            return this.attr("class", ("" + this.attr("class")).replace(q(b2) ? new RegExp(`(^| )${b2}( |$)`) : b2, " ").replace(/ +/g, " ").trim());
          }
          removeTextOutline() {
            const b2 = this.element.querySelector("tspan.highcharts-text-outline");
            b2 && this.safeRemoveChild(b2);
          }
          safeRemoveChild(b2) {
            const c2 = b2.parentNode;
            c2 && c2.removeChild(b2);
          }
          setRadialReference(b2) {
            const c2 = this.element.gradient && this.renderer.gradients[this.element.gradient];
            this.element.radialReference = b2;
            c2 && c2.radAttr && c2.animate(this.renderer.getRadialAttr(b2, c2.radAttr));
            return this;
          }
          setTextPath(b2, c2) {
            c2 = x(true, { enabled: true, attributes: { dy: -5, startOffset: "50%", textAnchor: "middle" } }, c2);
            const d2 = this.renderer.url, l2 = this.text || this, e2 = l2.textPath, { attributes: p2, enabled: q2 } = c2;
            b2 = b2 || e2 && e2.path;
            e2 && e2.undo();
            b2 && q2 ? (c2 = r(l2, "afterModifyTree", (c3) => {
              if (b2 && q2) {
                let D = b2.attr("id");
                D || b2.attr("id", D = L());
                var e3 = { x: 0, y: 0 };
                g(p2.dx) && (e3.dx = p2.dx, delete p2.dx);
                g(p2.dy) && (e3.dy = p2.dy, delete p2.dy);
                l2.attr(e3);
                this.attr({ transform: "" });
                this.box && (this.box = this.box.destroy());
                e3 = c3.nodes.slice(0);
                c3.nodes.length = 0;
                c3.nodes[0] = { tagName: "textPath", attributes: F(p2, { "text-anchor": p2.textAnchor, href: `${d2}#${D}` }), children: e3 };
              }
            }), l2.textPath = { path: b2, undo: c2 }) : (l2.attr({ dx: 0, dy: 0 }), delete l2.textPath);
            this.added && (l2.textCache = "", this.renderer.buildText(l2));
            return this;
          }
          shadow(b2) {
            var c2;
            const { renderer: l2 } = this, e2 = x(90 === (null === (c2 = this.parentGroup) || void 0 === c2 ? void 0 : c2.rotation) ? {
              offsetX: -1,
              offsetY: -1
            } : {}, d(b2) ? b2 : {});
            c2 = l2.shadowDefinition(e2);
            return this.attr({ filter: b2 ? `url(${l2.url}#${c2})` : "none" });
          }
          show(b2 = true) {
            return this.attr({ visibility: b2 ? "inherit" : "visible" });
          }
          ["stroke-widthSetter"](b2, c2, d2) {
            this[c2] = b2;
            d2.setAttribute(c2, b2);
          }
          strokeWidth() {
            if (!this.renderer.styledMode)
              return this["stroke-width"] || 0;
            const b2 = this.getStyle("stroke-width");
            let c2 = 0, d2;
            b2.indexOf("px") === b2.length - 2 ? c2 = p(b2) : "" !== b2 && (d2 = u.createElementNS(f, "rect"), m(d2, { width: b2, "stroke-width": 0 }), this.element.parentNode.appendChild(d2), c2 = d2.getBBox().width, d2.parentNode.removeChild(d2));
            return c2;
          }
          symbolAttr(c2) {
            const d2 = this;
            N.symbolCustomAttribs.forEach(function(l2) {
              d2[l2] = b(c2[l2], d2[l2]);
            });
            d2.attr({ d: d2.renderer.symbols[d2.symbolName](d2.x, d2.y, d2.width, d2.height, d2) });
          }
          textSetter(b2) {
            b2 !== this.textStr && (delete this.textPxLength, this.textStr = b2, this.added && this.renderer.buildText(this));
          }
          titleSetter(c2) {
            const d2 = this.element, l2 = d2.getElementsByTagName("title")[0] || u.createElementNS(this.SVG_NS, "title");
            d2.insertBefore ? d2.insertBefore(l2, d2.firstChild) : d2.appendChild(l2);
            l2.textContent = String(b(c2, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
          }
          toFront() {
            const b2 = this.element;
            b2.parentNode.appendChild(b2);
            return this;
          }
          translate(b2, c2) {
            return this.attr({ translateX: b2, translateY: c2 });
          }
          updateTransform() {
            const { element: c2, matrix: d2, rotation: l2 = 0, scaleX: e2, scaleY: p2, translateX: q2 = 0, translateY: a3 = 0 } = this, t2 = ["translate(" + q2 + "," + a3 + ")"];
            g(d2) && t2.push("matrix(" + d2.join(",") + ")");
            l2 && t2.push("rotate(" + l2 + " " + b(this.rotationOriginX, c2.getAttribute("x"), 0) + " " + b(
              this.rotationOriginY,
              c2.getAttribute("y") || 0
            ) + ")");
            (g(e2) || g(p2)) && t2.push("scale(" + b(e2, 1) + " " + b(p2, 1) + ")");
            t2.length && !(this.text || this).textPath && c2.setAttribute("transform", t2.join(" "));
          }
          visibilitySetter(b2, c2, d2) {
            "inherit" === b2 ? d2.removeAttribute(c2) : this[c2] !== b2 && d2.setAttribute(c2, b2);
            this[c2] = b2;
          }
          xGetter(b2) {
            "circle" === this.element.nodeName && ("x" === b2 ? b2 = "cx" : "y" === b2 && (b2 = "cy"));
            return this._defaultGetter(b2);
          }
          zIndexSetter(b2, c2) {
            var d2 = this.renderer, l2 = this.parentGroup;
            const e2 = (l2 || d2).element || d2.box, q2 = this.element;
            d2 = e2 === d2.box;
            let a3 = false, t2;
            var k2 = this.added;
            let D;
            g(b2) ? (q2.setAttribute("data-z-index", b2), b2 = +b2, this[c2] === b2 && (k2 = false)) : g(this[c2]) && q2.removeAttribute("data-z-index");
            this[c2] = b2;
            if (k2) {
              (b2 = this.zIndex) && l2 && (l2.handleZ = true);
              c2 = e2.childNodes;
              for (D = c2.length - 1; 0 <= D && !a3; D--)
                if (l2 = c2[D], k2 = l2.getAttribute("data-z-index"), t2 = !g(k2), l2 !== q2) {
                  if (0 > b2 && t2 && !d2 && !D)
                    e2.insertBefore(q2, c2[D]), a3 = true;
                  else if (p(k2) <= b2 || t2 && (!g(b2) || 0 <= b2))
                    e2.insertBefore(q2, c2[D + 1]), a3 = true;
                }
              a3 || (e2.insertBefore(q2, c2[d2 ? 3 : 0]), a3 = true);
            }
            return a3;
          }
        }
        N.symbolCustomAttribs = "anchorX anchorY clockwise end height innerR r start width x y".split(" ");
        N.prototype.strokeSetter = N.prototype.fillSetter;
        N.prototype.yGetter = N.prototype.xGetter;
        N.prototype.matrixSetter = N.prototype.rotationOriginXSetter = N.prototype.rotationOriginYSetter = N.prototype.rotationSetter = N.prototype.scaleXSetter = N.prototype.scaleYSetter = N.prototype.translateXSetter = N.prototype.translateYSetter = N.prototype.verticalAlignSetter = function(b2, c2) {
          this[c2] = b2;
          this.doTransform = true;
        };
        "";
        return N;
      });
      M(a, "Core/Renderer/RendererRegistry.js", [a["Core/Globals.js"]], function(a2) {
        var w;
        (function(w2) {
          w2.rendererTypes = {};
          let y;
          w2.getRendererType = function(a3 = y) {
            return w2.rendererTypes[a3] || w2.rendererTypes[y];
          };
          w2.registerRendererType = function(B, E, C) {
            w2.rendererTypes[B] = E;
            if (!y || C)
              y = B, a2.Renderer = E;
          };
        })(w || (w = {}));
        return w;
      });
      M(a, "Core/Renderer/SVG/SVGLabel.js", [a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function(a2, y) {
        const { defined: w, extend: K, isNumber: B, merge: E, pick: C, removeEvent: A } = y;
        class u extends a2 {
          constructor(a3, f, h, r, m, n, k, g, I, F) {
            super();
            this.paddingRightSetter = this.paddingLeftSetter = this.paddingSetter;
            this.init(a3, "g");
            this.textStr = f;
            this.x = h;
            this.y = r;
            this.anchorX = n;
            this.anchorY = k;
            this.baseline = I;
            this.className = F;
            this.addClass("button" === F ? "highcharts-no-tooltip" : "highcharts-label");
            F && this.addClass("highcharts-" + F);
            this.text = a3.text(void 0, 0, 0, g).attr({ zIndex: 1 });
            let z;
            "string" === typeof m && ((z = /^url\((.*?)\)$/.test(m)) || this.renderer.symbols[m]) && (this.symbolKey = m);
            this.bBox = u.emptyBBox;
            this.padding = 3;
            this.baselineOffset = 0;
            this.needsBox = a3.styledMode || z;
            this.deferredAttr = {};
            this.alignFactor = 0;
          }
          alignSetter(a3) {
            a3 = { left: 0, center: 0.5, right: 1 }[a3];
            a3 !== this.alignFactor && (this.alignFactor = a3, this.bBox && B(this.xSetting) && this.attr({ x: this.xSetting }));
          }
          anchorXSetter(a3, f) {
            this.anchorX = a3;
            this.boxAttr(f, Math.round(a3) - this.getCrispAdjust() - this.xSetting);
          }
          anchorYSetter(a3, f) {
            this.anchorY = a3;
            this.boxAttr(f, a3 - this.ySetting);
          }
          boxAttr(a3, f) {
            this.box ? this.box.attr(a3, f) : this.deferredAttr[a3] = f;
          }
          css(v) {
            if (v) {
              const a3 = {};
              v = E(v);
              u.textProps.forEach((f) => {
                "undefined" !== typeof v[f] && (a3[f] = v[f], delete v[f]);
              });
              this.text.css(a3);
              "fontSize" in a3 || "fontWeight" in a3 ? this.updateTextPadding() : ("width" in a3 || "textOverflow" in a3) && this.updateBoxSize();
            }
            return a2.prototype.css.call(this, v);
          }
          destroy() {
            A(this.element, "mouseenter");
            A(this.element, "mouseleave");
            this.text && this.text.destroy();
            this.box && (this.box = this.box.destroy());
            a2.prototype.destroy.call(this);
          }
          fillSetter(a3, f) {
            a3 && (this.needsBox = true);
            this.fill = a3;
            this.boxAttr(f, a3);
          }
          getBBox() {
            this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
            const a3 = this.padding, f = C(
              this.paddingLeft,
              a3
            );
            return { width: this.width, height: this.height, x: this.bBox.x - f, y: this.bBox.y - a3 };
          }
          getCrispAdjust() {
            return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
          }
          heightSetter(a3) {
            this.heightSetting = a3;
          }
          onAdd() {
            this.text.add(this);
            this.attr({ text: C(this.textStr, ""), x: this.x || 0, y: this.y || 0 });
            this.box && w(this.anchorX) && this.attr({ anchorX: this.anchorX, anchorY: this.anchorY });
          }
          paddingSetter(a3, f) {
            B(a3) ? a3 !== this[f] && (this[f] = a3, this.updateTextPadding()) : this[f] = void 0;
          }
          rSetter(a3, f) {
            this.boxAttr(f, a3);
          }
          strokeSetter(a3, f) {
            this.stroke = a3;
            this.boxAttr(f, a3);
          }
          ["stroke-widthSetter"](a3, f) {
            a3 && (this.needsBox = true);
            this["stroke-width"] = a3;
            this.boxAttr(f, a3);
          }
          ["text-alignSetter"](a3) {
            this.textAlign = a3;
          }
          textSetter(a3) {
            "undefined" !== typeof a3 && this.text.attr({ text: a3 });
            this.updateTextPadding();
          }
          updateBoxSize() {
            var a3 = this.text;
            const f = {}, h = this.padding, r = this.bBox = B(this.widthSetting) && B(this.heightSetting) && !this.textAlign || !w(a3.textStr) ? u.emptyBBox : a3.getBBox();
            this.width = this.getPaddedWidth();
            this.height = (this.heightSetting || r.height || 0) + 2 * h;
            const m = this.renderer.fontMetrics(a3);
            this.baselineOffset = h + Math.min((this.text.firstLineMetrics || m).b, r.height || Infinity);
            this.heightSetting && (this.baselineOffset += (this.heightSetting - m.h) / 2);
            this.needsBox && !a3.textPath && (this.box || (a3 = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), a3.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), a3.add(this)), a3 = this.getCrispAdjust(), f.x = a3, f.y = (this.baseline ? -this.baselineOffset : 0) + a3, f.width = Math.round(this.width), f.height = Math.round(this.height), this.box.attr(K(f, this.deferredAttr)), this.deferredAttr = {});
          }
          updateTextPadding() {
            const a3 = this.text;
            if (!a3.textPath) {
              this.updateBoxSize();
              const f = this.baseline ? 0 : this.baselineOffset;
              let h = C(this.paddingLeft, this.padding);
              w(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (h += { center: 0.5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width));
              if (h !== a3.x || f !== a3.y)
                a3.attr("x", h), a3.hasBoxWidthChanged && (this.bBox = a3.getBBox(true)), "undefined" !== typeof f && a3.attr("y", f);
              a3.x = h;
              a3.y = f;
            }
          }
          widthSetter(a3) {
            this.widthSetting = B(a3) ? a3 : void 0;
          }
          getPaddedWidth() {
            var a3 = this.padding;
            const f = C(this.paddingLeft, a3);
            a3 = C(this.paddingRight, a3);
            return (this.widthSetting || this.bBox.width || 0) + f + a3;
          }
          xSetter(a3) {
            this.x = a3;
            this.alignFactor && (a3 -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = true);
            this.xSetting = Math.round(a3);
            this.attr("translateX", this.xSetting);
          }
          ySetter(a3) {
            this.ySetting = this.y = Math.round(a3);
            this.attr("translateY", this.ySetting);
          }
        }
        u.emptyBBox = { width: 0, height: 0, x: 0, y: 0 };
        u.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow whiteSpace width".split(" ");
        return u;
      });
      M(a, "Core/Renderer/SVG/Symbols.js", [a["Core/Utilities.js"]], function(a2) {
        function w(a3, u, v, f, h) {
          const r = [];
          if (h) {
            const m = h.start || 0, n = C(h.r, v);
            v = C(h.r, f || v);
            f = (h.end || 0) - 1e-3;
            const k = h.innerR, g = C(h.open, 1e-3 > Math.abs((h.end || 0) - m - 2 * Math.PI)), I = Math.cos(m), F = Math.sin(m), z = Math.cos(f), e = Math.sin(f), t = C(h.longArc, 1e-3 > f - m - Math.PI ? 0 : 1);
            let d = ["A", n, v, 0, t, C(h.clockwise, 1), a3 + n * z, u + v * e];
            d.params = { start: m, end: f, cx: a3, cy: u };
            r.push(["M", a3 + n * I, u + v * F], d);
            B(k) && (d = ["A", k, k, 0, t, B(h.clockwise) ? 1 - h.clockwise : 0, a3 + k * I, u + k * F], d.params = { start: f, end: m, cx: a3, cy: u }, r.push(g ? ["M", a3 + k * z, u + k * e] : ["L", a3 + k * z, u + k * e], d));
            g || r.push(["Z"]);
          }
          return r;
        }
        function H(a3, u, v, f, h) {
          return h && h.r ? K(a3, u, v, f, h) : [["M", a3, u], ["L", a3 + v, u], ["L", a3 + v, u + f], ["L", a3, u + f], ["Z"]];
        }
        function K(a3, u, v, f, h) {
          h = (null === h || void 0 === h ? void 0 : h.r) || 0;
          return [["M", a3 + h, u], ["L", a3 + v - h, u], ["A", h, h, 0, 0, 1, a3 + v, u + h], ["L", a3 + v, u + f - h], ["A", h, h, 0, 0, 1, a3 + v - h, u + f], ["L", a3 + h, u + f], ["A", h, h, 0, 0, 1, a3, u + f - h], ["L", a3, u + h], ["A", h, h, 0, 0, 1, a3 + h, u], ["Z"]];
        }
        const { defined: B, isNumber: E, pick: C } = a2;
        return {
          arc: w,
          callout: function(a3, u, v, f, h) {
            const r = Math.min(h && h.r || 0, v, f), m = r + 6, n = h && h.anchorX;
            h = h && h.anchorY || 0;
            const k = K(a3, u, v, f, { r });
            if (!E(n))
              return k;
            a3 + n >= v ? h > u + m && h < u + f - m ? k.splice(3, 1, ["L", a3 + v, h - 6], ["L", a3 + v + 6, h], ["L", a3 + v, h + 6], ["L", a3 + v, u + f - r]) : k.splice(3, 1, ["L", a3 + v, f / 2], ["L", n, h], ["L", a3 + v, f / 2], ["L", a3 + v, u + f - r]) : 0 >= a3 + n ? h > u + m && h < u + f - m ? k.splice(7, 1, ["L", a3, h + 6], ["L", a3 - 6, h], ["L", a3, h - 6], ["L", a3, u + r]) : k.splice(7, 1, ["L", a3, f / 2], ["L", n, h], ["L", a3, f / 2], ["L", a3, u + r]) : h && h > f && n > a3 + m && n < a3 + v - m ? k.splice(5, 1, ["L", n + 6, u + f], ["L", n, u + f + 6], ["L", n - 6, u + f], ["L", a3 + r, u + f]) : h && 0 > h && n > a3 + m && n < a3 + v - m && k.splice(1, 1, ["L", n - 6, u], ["L", n, u - 6], ["L", n + 6, u], ["L", v - r, u]);
            return k;
          },
          circle: function(a3, u, v, f) {
            return w(a3 + v / 2, u + f / 2, v / 2, f / 2, { start: 0.5 * Math.PI, end: 2.5 * Math.PI, open: false });
          },
          diamond: function(a3, u, v, f) {
            return [["M", a3 + v / 2, u], ["L", a3 + v, u + f / 2], ["L", a3 + v / 2, u + f], ["L", a3, u + f / 2], ["Z"]];
          },
          rect: H,
          roundedRect: K,
          square: H,
          triangle: function(a3, u, v, f) {
            return [["M", a3 + v / 2, u], ["L", a3 + v, u + f], ["L", a3, u + f], ["Z"]];
          },
          "triangle-down": function(a3, u, v, f) {
            return [["M", a3, u], ["L", a3 + v, u], ["L", a3 + v / 2, u + f], ["Z"]];
          }
        };
      });
      M(a, "Core/Renderer/SVG/TextBuilder.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, y, H) {
        const { doc: w, SVG_NS: B, win: E } = y, {
          attr: C,
          extend: A,
          fireEvent: u,
          isString: v,
          objectEach: f,
          pick: h
        } = H;
        class r {
          constructor(a3) {
            const m = a3.styles;
            this.renderer = a3.renderer;
            this.svgElement = a3;
            this.width = a3.textWidth;
            this.textLineHeight = m && m.lineHeight;
            this.textOutline = m && m.textOutline;
            this.ellipsis = !(!m || "ellipsis" !== m.textOverflow);
            this.noWrap = !(!m || "nowrap" !== m.whiteSpace);
          }
          buildSVG() {
            const m = this.svgElement, f2 = m.element;
            var k = m.renderer, g = h(m.textStr, "").toString();
            const r2 = -1 !== g.indexOf("<"), F = f2.childNodes;
            k = !m.added && k.box;
            const z = /<br.*?>/g;
            var e = [
              g,
              this.ellipsis,
              this.noWrap,
              this.textLineHeight,
              this.textOutline,
              m.getStyle("font-size"),
              this.width
            ].join();
            if (e !== m.textCache) {
              m.textCache = e;
              delete m.actualWidth;
              for (e = F.length; e--; )
                f2.removeChild(F[e]);
              r2 || this.ellipsis || this.width || m.textPath || -1 !== g.indexOf(" ") && (!this.noWrap || z.test(g)) ? "" !== g && (k && k.appendChild(f2), g = new a2(g), this.modifyTree(g.nodes), g.addToDOM(f2), this.modifyDOM(), this.ellipsis && -1 !== (f2.textContent || "").indexOf("…") && m.attr("title", this.unescapeEntities(m.textStr || "", ["&lt;", "&gt;"])), k && k.removeChild(f2)) : f2.appendChild(w.createTextNode(this.unescapeEntities(g)));
              v(this.textOutline) && m.applyTextOutline && m.applyTextOutline(this.textOutline);
            }
          }
          modifyDOM() {
            const a3 = this.svgElement, f2 = C(a3.element, "x");
            a3.firstLineMetrics = void 0;
            let k;
            for (; k = a3.element.firstChild; )
              if (/^[\s\u200B]*$/.test(k.textContent || " "))
                a3.element.removeChild(k);
              else
                break;
            [].forEach.call(a3.element.querySelectorAll("tspan.highcharts-br"), (g2, e) => {
              g2.nextSibling && g2.previousSibling && (0 === e && 1 === g2.previousSibling.nodeType && (a3.firstLineMetrics = a3.renderer.fontMetrics(g2.previousSibling)), C(g2, {
                dy: this.getLineHeight(g2.nextSibling),
                x: f2
              }));
            });
            const g = this.width || 0;
            if (g) {
              var h2 = (k2, e) => {
                var t = k2.textContent || "";
                const d = t.replace(/([^\^])-/g, "$1- ").split(" ");
                var q = !this.noWrap && (1 < d.length || 1 < a3.element.childNodes.length);
                const m = this.getLineHeight(e);
                let c = 0, b = a3.actualWidth;
                if (this.ellipsis)
                  t && this.truncate(k2, t, void 0, 0, Math.max(0, g - 0.8 * m), (b2, c2) => b2.substring(0, c2) + "…");
                else if (q) {
                  t = [];
                  for (q = []; e.firstChild && e.firstChild !== k2; )
                    q.push(e.firstChild), e.removeChild(e.firstChild);
                  for (; d.length; )
                    d.length && !this.noWrap && 0 < c && (t.push(k2.textContent || ""), k2.textContent = d.join(" ").replace(/- /g, "-")), this.truncate(k2, void 0, d, 0 === c ? b || 0 : 0, g, (b2, c2) => d.slice(0, c2).join(" ").replace(/- /g, "-")), b = a3.actualWidth, c++;
                  q.forEach((b2) => {
                    e.insertBefore(b2, k2);
                  });
                  t.forEach((b2) => {
                    e.insertBefore(w.createTextNode(b2), k2);
                    b2 = w.createElementNS(B, "tspan");
                    b2.textContent = "​";
                    C(b2, { dy: m, x: f2 });
                    e.insertBefore(b2, k2);
                  });
                }
              }, r2 = (g2) => {
                [].slice.call(g2.childNodes).forEach((e) => {
                  e.nodeType === E.Node.TEXT_NODE ? h2(e, g2) : (-1 !== e.className.baseVal.indexOf("highcharts-br") && (a3.actualWidth = 0), r2(e));
                });
              };
              r2(a3.element);
            }
          }
          getLineHeight(a3) {
            a3 = a3.nodeType === E.Node.TEXT_NODE ? a3.parentElement : a3;
            return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a3 || this.svgElement.element).h;
          }
          modifyTree(a3) {
            const f2 = (k, g) => {
              const { attributes: m = {}, children: h2, style: n = {}, tagName: e } = k, t = this.renderer.styledMode;
              if ("b" === e || "strong" === e)
                t ? m["class"] = "highcharts-strong" : n.fontWeight = "bold";
              else if ("i" === e || "em" === e)
                t ? m["class"] = "highcharts-emphasized" : n.fontStyle = "italic";
              n && n.color && (n.fill = n.color);
              "br" === e ? (m["class"] = "highcharts-br", k.textContent = "​", (g = a3[g + 1]) && g.textContent && (g.textContent = g.textContent.replace(/^ +/gm, ""))) : "a" === e && h2 && h2.some((d) => "#text" === d.tagName) && (k.children = [{ children: h2, tagName: "tspan" }]);
              "#text" !== e && "a" !== e && (k.tagName = "tspan");
              A(k, { attributes: m, style: n });
              h2 && h2.filter((d) => "#text" !== d.tagName).forEach(f2);
            };
            a3.forEach(f2);
            u(this.svgElement, "afterModifyTree", { nodes: a3 });
          }
          truncate(a3, f2, k, g, h2, r2) {
            const m = this.svgElement, { rotation: e } = m, t = [];
            let d = k ? 1 : 0, q = (f2 || k || "").length, x = q, c, b;
            const p = function(b2, c2) {
              b2 = c2 || b2;
              if ((c2 = a3.parentNode) && "undefined" === typeof t[b2] && c2.getSubStringLength)
                try {
                  t[b2] = g + c2.getSubStringLength(0, k ? b2 + 1 : b2);
                } catch (N) {
                  "";
                }
              return t[b2];
            };
            m.rotation = 0;
            b = p(a3.textContent.length);
            if (g + b > h2) {
              for (; d <= q; )
                x = Math.ceil((d + q) / 2), k && (c = r2(k, x)), b = p(x, c && c.length - 1), d === q ? d = q + 1 : b > h2 ? q = x - 1 : d = x;
              0 === q ? a3.textContent = "" : f2 && q === f2.length - 1 || (a3.textContent = c || r2(f2 || k, x));
            }
            k && k.splice(0, x);
            m.actualWidth = b;
            m.rotation = e;
          }
          unescapeEntities(a3, h2) {
            f(this.renderer.escapes, function(k, g) {
              h2 && -1 !== h2.indexOf(k) || (a3 = a3.toString().replace(new RegExp(k, "g"), g));
            });
            return a3;
          }
        }
        return r;
      });
      M(a, "Core/Renderer/SVG/SVGRenderer.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGLabel.js"], a["Core/Renderer/SVG/Symbols.js"], a["Core/Renderer/SVG/TextBuilder.js"], a["Core/Utilities.js"]], function(a2, y, H, K, B, E, C, A, u) {
        const {
          charts: v,
          deg2rad: f,
          doc: h,
          isFirefox: r,
          isMS: m,
          isWebKit: n,
          noop: k,
          SVG_NS: g,
          symbolSizes: I,
          win: F
        } = H, { addEvent: z, attr: e, createElement: t, css: d, defined: q, destroyObjectProperties: x, extend: c, isArray: b, isNumber: p, isObject: l, isString: L, merge: N, pick: O, pInt: w, uniqueKey: S } = u;
        let U;
        class G {
          constructor(b2, c2, d2, a3, l2, e2, p2) {
            this.width = this.url = this.style = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
            this.init(b2, c2, d2, a3, l2, e2, p2);
          }
          init(b2, c2, a3, l2, D, p2, G2) {
            const q2 = this.createElement("svg").attr({
              version: "1.1",
              "class": "highcharts-root"
            }), g2 = q2.element;
            G2 || q2.css(this.getStyle(l2));
            b2.appendChild(g2);
            e(b2, "dir", "ltr");
            -1 === b2.innerHTML.indexOf("xmlns") && e(g2, "xmlns", this.SVG_NS);
            this.box = g2;
            this.boxWrapper = q2;
            this.alignedObjects = [];
            this.url = this.getReferenceURL();
            this.createElement("desc").add().element.appendChild(h.createTextNode("Created with Highcharts 11.0.0"));
            this.defs = this.createElement("defs").add();
            this.allowHTML = p2;
            this.forExport = D;
            this.styledMode = G2;
            this.gradients = {};
            this.cache = {};
            this.cacheKeys = [];
            this.imgCount = 0;
            this.rootFontSize = q2.getStyle("font-size");
            this.setSize(c2, a3, false);
            let t2;
            r && b2.getBoundingClientRect && (c2 = function() {
              d(b2, { left: 0, top: 0 });
              t2 = b2.getBoundingClientRect();
              d(b2, { left: Math.ceil(t2.left) - t2.left + "px", top: Math.ceil(t2.top) - t2.top + "px" });
            }, c2(), this.unSubPixelFix = z(F, "resize", c2));
          }
          definition(b2) {
            return new a2([b2]).addToDOM(this.defs.element);
          }
          getReferenceURL() {
            if ((r || n) && h.getElementsByTagName("base").length) {
              if (!q(U)) {
                var b2 = S();
                b2 = new a2([{ tagName: "svg", attributes: { width: 8, height: 8 }, children: [{
                  tagName: "defs",
                  children: [{ tagName: "clipPath", attributes: { id: b2 }, children: [{ tagName: "rect", attributes: { width: 4, height: 4 } }] }]
                }, { tagName: "rect", attributes: { id: "hitme", width: 8, height: 8, "clip-path": `url(#${b2})`, fill: "rgba(0,0,0,0.001)" } }] }]).addToDOM(h.body);
                d(b2, { position: "fixed", top: 0, left: 0, zIndex: 9e5 });
                const c2 = h.elementFromPoint(6, 6);
                U = "hitme" === (c2 && c2.id);
                h.body.removeChild(b2);
              }
              if (U)
                return F.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
            }
            return "";
          }
          getStyle(b2) {
            return this.style = c({ fontFamily: "Helvetica, Arial, sans-serif", fontSize: "1rem" }, b2);
          }
          setStyle(b2) {
            this.boxWrapper.css(this.getStyle(b2));
          }
          isHidden() {
            return !this.boxWrapper.getBBox().width;
          }
          destroy() {
            const b2 = this.defs;
            this.box = null;
            this.boxWrapper = this.boxWrapper.destroy();
            x(this.gradients || {});
            this.gradients = null;
            this.defs = b2.destroy();
            this.unSubPixelFix && this.unSubPixelFix();
            return this.alignedObjects = null;
          }
          createElement(b2) {
            const c2 = new this.Element();
            c2.init(this, b2);
            return c2;
          }
          getRadialAttr(b2, c2) {
            return { cx: b2[0] - b2[2] / 2 + (c2.cx || 0) * b2[2], cy: b2[1] - b2[2] / 2 + (c2.cy || 0) * b2[2], r: (c2.r || 0) * b2[2] };
          }
          shadowDefinition(b2) {
            const c2 = ["drop-shadow", ...Object.keys(b2).map((c3) => b2[c3])].join("-").replace(/[^a-z0-9\-]/g, ""), d2 = N({ color: "#000000", offsetX: 1, offsetY: 1, opacity: 0.15, width: 5 }, b2);
            this.defs.element.querySelector(`#${c2}`) || this.definition({ tagName: "filter", attributes: { id: c2 }, children: [{ tagName: "feDropShadow", attributes: { dx: d2.offsetX, dy: d2.offsetY, "flood-color": d2.color, "flood-opacity": Math.min(5 * d2.opacity, 1), stdDeviation: d2.width / 2 } }] });
            return c2;
          }
          buildText(b2) {
            new A(b2).buildSVG();
          }
          getContrast(b2) {
            b2 = y.parse(b2).rgba.map((b3) => {
              b3 /= 255;
              return 0.03928 >= b3 ? b3 / 12.92 : Math.pow((b3 + 0.055) / 1.055, 2.4);
            });
            b2 = 0.2126 * b2[0] + 0.7152 * b2[1] + 0.0722 * b2[2];
            return 1.05 / (b2 + 0.05) > (b2 + 0.05) / 0.05 ? "#FFFFFF" : "#000000";
          }
          button(b2, d2, e2, p2, D = {}, G2, q2, g2, t2, k2) {
            const J = this.label(b2, d2, e2, t2, void 0, void 0, k2, void 0, "button"), f2 = this.styledMode;
            b2 = D.states || {};
            let x2 = 0;
            D = N(D);
            delete D.states;
            const P = N({ color: "#333333", cursor: "pointer", fontSize: "0.8em", fontWeight: "normal" }, D.style);
            delete D.style;
            let h2 = a2.filterUserAttributes(D);
            J.attr(N({ padding: 8, r: 2 }, h2));
            let Q, n2, L2;
            f2 || (h2 = N({ fill: "#f7f7f7", stroke: "#cccccc", "stroke-width": 1 }, h2), G2 = N(h2, { fill: "#e6e6e6" }, a2.filterUserAttributes(G2 || b2.hover || {})), Q = G2.style, delete G2.style, q2 = N(h2, { fill: "#e6e9ff", style: { color: "#000000", fontWeight: "bold" } }, a2.filterUserAttributes(q2 || b2.select || {})), n2 = q2.style, delete q2.style, g2 = N(h2, { style: { color: "#cccccc" } }, a2.filterUserAttributes(g2 || b2.disabled || {})), L2 = g2.style, delete g2.style);
            z(J.element, m ? "mouseover" : "mouseenter", function() {
              3 !== x2 && J.setState(1);
            });
            z(J.element, m ? "mouseout" : "mouseleave", function() {
              3 !== x2 && J.setState(x2);
            });
            J.setState = function(b3) {
              1 !== b3 && (J.state = x2 = b3);
              J.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][b3 || 0]);
              f2 || (J.attr([h2, G2, q2, g2][b3 || 0]), b3 = [P, Q, n2, L2][b3 || 0], l(b3) && J.css(b3));
            };
            f2 || (J.attr(h2).css(c({ cursor: "default" }, P)), k2 && J.text.css({ pointerEvents: "none" }));
            return J.on("touchstart", (b3) => b3.stopPropagation()).on("click", function(b3) {
              3 !== x2 && p2.call(J, b3);
            });
          }
          crispLine(b2, c2, d2 = "round") {
            const a3 = b2[0], l2 = b2[1];
            q(a3[1]) && a3[1] === l2[1] && (a3[1] = l2[1] = Math[d2](a3[1]) - c2 % 2 / 2);
            q(a3[2]) && a3[2] === l2[2] && (a3[2] = l2[2] = Math[d2](a3[2]) + c2 % 2 / 2);
            return b2;
          }
          path(d2) {
            const a3 = this.styledMode ? {} : { fill: "none" };
            b(d2) ? a3.d = d2 : l(d2) && c(a3, d2);
            return this.createElement("path").attr(a3);
          }
          circle(b2, c2, d2) {
            b2 = l(b2) ? b2 : "undefined" === typeof b2 ? {} : { x: b2, y: c2, r: d2 };
            c2 = this.createElement("circle");
            c2.xSetter = c2.ySetter = function(b3, c3, d3) {
              d3.setAttribute("c" + c3, b3);
            };
            return c2.attr(b2);
          }
          arc(b2, c2, d2, a3, e2, p2) {
            l(b2) ? (a3 = b2, c2 = a3.y, d2 = a3.r, b2 = a3.x) : a3 = { innerR: a3, start: e2, end: p2 };
            b2 = this.symbol("arc", b2, c2, d2, d2, a3);
            b2.r = d2;
            return b2;
          }
          rect(b2, d2, a3, p2, D, G2) {
            b2 = l(b2) ? b2 : "undefined" === typeof b2 ? {} : { x: b2, y: d2, r: D, width: Math.max(a3 || 0, 0), height: Math.max(p2 || 0, 0) };
            const q2 = this.createElement("rect");
            this.styledMode || ("undefined" !== typeof G2 && (b2["stroke-width"] = G2, c(b2, q2.crisp(b2))), b2.fill = "none");
            q2.rSetter = function(b3, c2, d3) {
              q2.r = b3;
              e(d3, { rx: b3, ry: b3 });
            };
            q2.rGetter = function() {
              return q2.r || 0;
            };
            return q2.attr(b2);
          }
          roundedRect(b2) {
            return this.symbol("roundedRect").attr(b2);
          }
          setSize(b2, c2, d2) {
            this.width = b2;
            this.height = c2;
            this.boxWrapper.animate({ width: b2, height: c2 }, { step: function() {
              this.attr({ viewBox: "0 0 " + this.attr("width") + " " + this.attr("height") });
            }, duration: O(d2, true) ? void 0 : 0 });
            this.alignElements();
          }
          g(b2) {
            const c2 = this.createElement("g");
            return b2 ? c2.attr({ "class": "highcharts-" + b2 }) : c2;
          }
          image(b2, c2, d2, a3, l2, e2) {
            const D = { preserveAspectRatio: "none" }, q2 = function(b3, c3) {
              b3.setAttributeNS ? b3.setAttributeNS("http://www.w3.org/1999/xlink", "href", c3) : b3.setAttribute("hc-svg-href", c3);
            };
            p(c2) && (D.x = c2);
            p(d2) && (D.y = d2);
            p(a3) && (D.width = a3);
            p(l2) && (D.height = l2);
            const G2 = this.createElement("image").attr(D);
            c2 = function(c3) {
              q2(G2.element, b2);
              e2.call(
                G2,
                c3
              );
            };
            e2 ? (q2(G2.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), d2 = new F.Image(), z(d2, "load", c2), d2.src = b2, d2.complete && c2({})) : q2(G2.element, b2);
            return G2;
          }
          symbol(b2, a3, l2, p2, D, G2) {
            const g2 = this, k2 = /^url\((.*?)\)$/, f2 = k2.test(b2), x2 = !f2 && (this.symbols[b2] ? b2 : "circle"), m2 = x2 && this.symbols[x2];
            let P, n2, L2, r2;
            if (m2)
              "number" === typeof a3 && (n2 = m2.call(this.symbols, Math.round(a3 || 0), Math.round(l2 || 0), p2 || 0, D || 0, G2)), P = this.path(n2), g2.styledMode || P.attr("fill", "none"), c(P, { symbolName: x2 || void 0, x: a3, y: l2, width: p2, height: D }), G2 && c(P, G2);
            else if (f2) {
              L2 = b2.match(k2)[1];
              const c2 = P = this.image(L2);
              c2.imgwidth = O(G2 && G2.width, I[L2] && I[L2].width);
              c2.imgheight = O(G2 && G2.height, I[L2] && I[L2].height);
              r2 = (b3) => b3.attr({ width: b3.width, height: b3.height });
              ["width", "height"].forEach(function(b3) {
                c2[b3 + "Setter"] = function(b4, c3) {
                  this[c3] = b4;
                  const { alignByTranslate: d2, element: a4, width: l3, height: D2, imgwidth: p3, imgheight: g3 } = this;
                  b4 = this["img" + c3];
                  if (q(b4)) {
                    let q2 = 1;
                    G2 && "within" === G2.backgroundSize && l3 && D2 ? (q2 = Math.min(l3 / p3, D2 / g3), e(a4, { width: Math.round(p3 * q2), height: Math.round(g3 * q2) })) : a4 && a4.setAttribute(
                      c3,
                      b4
                    );
                    d2 || this.translate(((l3 || 0) - p3 * q2) / 2, ((D2 || 0) - g3 * q2) / 2);
                  }
                };
              });
              q(a3) && c2.attr({ x: a3, y: l2 });
              c2.isImg = true;
              q(c2.imgwidth) && q(c2.imgheight) ? r2(c2) : (c2.attr({ width: 0, height: 0 }), t("img", {
                onload: function() {
                  const b3 = v[g2.chartIndex];
                  0 === this.width && (d(this, { position: "absolute", top: "-999em" }), h.body.appendChild(this));
                  I[L2] = { width: this.width, height: this.height };
                  c2.imgwidth = this.width;
                  c2.imgheight = this.height;
                  c2.element && r2(c2);
                  this.parentNode && this.parentNode.removeChild(this);
                  g2.imgCount--;
                  if (!g2.imgCount && b3 && !b3.hasLoaded)
                    b3.onload();
                },
                src: L2
              }), this.imgCount++);
            }
            return P;
          }
          clipRect(b2, c2, d2, a3) {
            const l2 = S() + "-", e2 = this.createElement("clipPath").attr({ id: l2 }).add(this.defs);
            b2 = this.rect(b2, c2, d2, a3, 0).add(e2);
            b2.id = l2;
            b2.clipPath = e2;
            b2.count = 0;
            return b2;
          }
          text(b2, c2, d2, a3) {
            const l2 = {};
            if (a3 && (this.allowHTML || !this.forExport))
              return this.html(b2, c2, d2);
            l2.x = Math.round(c2 || 0);
            d2 && (l2.y = Math.round(d2));
            q(b2) && (l2.text = b2);
            b2 = this.createElement("text").attr(l2);
            if (!a3 || this.forExport && !this.allowHTML)
              b2.xSetter = function(b3, c3, d3) {
                const a4 = d3.getElementsByTagName("tspan"), l3 = d3.getAttribute(c3);
                for (let d4 = 0, e2; d4 < a4.length; d4++)
                  e2 = a4[d4], e2.getAttribute(c3) === l3 && e2.setAttribute(c3, b3);
                d3.setAttribute(c3, b3);
              };
            return b2;
          }
          fontMetrics(b2) {
            b2 = w(B.prototype.getStyle.call(b2, "font-size") || 0);
            const c2 = 24 > b2 ? b2 + 3 : Math.round(1.2 * b2);
            return { h: c2, b: Math.round(0.8 * c2), f: b2 };
          }
          rotCorr(b2, c2, d2) {
            let a3 = b2;
            c2 && d2 && (a3 = Math.max(a3 * Math.cos(c2 * f), 4));
            return { x: -b2 / 3 * Math.sin(c2 * f), y: a3 };
          }
          pathToSegments(b2) {
            const c2 = [], d2 = [], a3 = { A: 8, C: 7, H: 2, L: 3, M: 3, Q: 5, S: 5, T: 3, V: 2 };
            for (let l2 = 0; l2 < b2.length; l2++)
              L(d2[0]) && p(b2[l2]) && d2.length === a3[d2[0].toUpperCase()] && b2.splice(
                l2,
                0,
                d2[0].replace("M", "L").replace("m", "l")
              ), "string" === typeof b2[l2] && (d2.length && c2.push(d2.slice(0)), d2.length = 0), d2.push(b2[l2]);
            c2.push(d2.slice(0));
            return c2;
          }
          label(b2, c2, d2, a3, l2, e2, G2, p2, q2) {
            return new E(this, b2, c2, d2, a3, l2, e2, G2, p2, q2);
          }
          alignElements() {
            this.alignedObjects.forEach((b2) => b2.align());
          }
        }
        c(G.prototype, { Element: B, SVG_NS: g, escapes: { "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" }, symbols: C, draw: k });
        K.registerRendererType("svg", G, true);
        "";
        return G;
      });
      M(a, "Core/Renderer/HTML/HTMLElement.js", [
        a["Core/Globals.js"],
        a["Core/Renderer/SVG/SVGElement.js"],
        a["Core/Utilities.js"]
      ], function(a2, y, H) {
        const { isFirefox: w, isMS: B, isWebKit: E, win: C } = a2, { css: A, defined: u, extend: v, pick: f, pInt: h } = H, r = [];
        class m extends y {
          static compose(a3) {
            if (H.pushUnique(r, a3)) {
              const k = m.prototype, g = a3.prototype;
              g.getSpanCorrection = k.getSpanCorrection;
              g.htmlCss = k.htmlCss;
              g.htmlGetBBox = k.htmlGetBBox;
              g.htmlUpdateTransform = k.htmlUpdateTransform;
              g.setSpanRotation = k.setSpanRotation;
            }
            return a3;
          }
          getSpanCorrection(a3, k, g) {
            this.xCorr = -a3 * g;
            this.yCorr = -k;
          }
          htmlCss(a3) {
            const k = "SPAN" === this.element.tagName && a3 && "width" in a3, g = f(k && a3.width, void 0);
            let m2;
            k && (delete a3.width, this.textWidth = g, m2 = true);
            a3 && "ellipsis" === a3.textOverflow && (a3.whiteSpace = "nowrap", a3.overflow = "hidden");
            this.styles = v(this.styles, a3);
            A(this.element, a3);
            m2 && this.htmlUpdateTransform();
            return this;
          }
          htmlGetBBox() {
            const a3 = this.element;
            return { x: a3.offsetLeft, y: a3.offsetTop, width: a3.offsetWidth, height: a3.offsetHeight };
          }
          htmlUpdateTransform() {
            if (this.added) {
              var a3 = this.renderer, k = this.element, g = this.x || 0, f2 = this.y || 0, m2 = this.textAlign || "left", r2 = { left: 0, center: 0.5, right: 1 }[m2], e = this.styles, t = e && e.whiteSpace;
              A(k, { marginLeft: this.translateX || 0, marginTop: this.translateY || 0 });
              if ("SPAN" === k.tagName) {
                e = this.rotation;
                const q = this.textWidth && h(this.textWidth), x = [e, m2, k.innerHTML, this.textWidth, this.textAlign].join();
                let c = false;
                if (q !== this.oldTextWidth) {
                  if (this.textPxLength)
                    var d = this.textPxLength;
                  else
                    A(k, { width: "", whiteSpace: t || "nowrap" }), d = k.offsetWidth;
                  (q > this.oldTextWidth || d > q) && (/[ \-]/.test(k.textContent || k.innerText) || "ellipsis" === k.style.textOverflow) && (A(k, { width: d > q || e ? q + "px" : "auto", display: "block", whiteSpace: t || "normal" }), this.oldTextWidth = q, c = true);
                }
                this.hasBoxWidthChanged = c;
                x !== this.cTT && (a3 = a3.fontMetrics(k).b, !u(e) || e === (this.oldRotation || 0) && m2 === this.oldAlign || this.setSpanRotation(e, r2, a3), this.getSpanCorrection(!u(e) && this.textPxLength || k.offsetWidth, a3, r2, e, m2));
                A(k, { left: g + (this.xCorr || 0) + "px", top: f2 + (this.yCorr || 0) + "px" });
                this.cTT = x;
                this.oldRotation = e;
                this.oldAlign = m2;
              }
            } else
              this.alignOnAdd = true;
          }
          setSpanRotation(a3, k, g) {
            const f2 = {}, m2 = B && !/Edge/.test(C.navigator.userAgent) ? "-ms-transform" : E ? "-webkit-transform" : w ? "MozTransform" : C.opera ? "-o-transform" : void 0;
            m2 && (f2[m2] = f2.transform = "rotate(" + a3 + "deg)", f2[m2 + (w ? "Origin" : "-origin")] = f2.transformOrigin = 100 * k + "% " + g + "px", A(this.element, f2));
          }
        }
        return m;
      });
      M(a, "Core/Renderer/HTML/HTMLRenderer.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function(a2, y, H, K) {
        const { attr: w, createElement: E, extend: C, pick: A } = K, u = [];
        class v extends H {
          static compose(a3) {
            K.pushUnique(
              u,
              a3
            ) && (a3.prototype.html = v.prototype.html);
            return a3;
          }
          html(f, h, r) {
            const m = this.createElement("span"), n = m.element, k = m.renderer, g = function(a3, g2) {
              ["opacity", "visibility"].forEach(function(k2) {
                a3[k2 + "Setter"] = function(e, t, d) {
                  const q = a3.div ? a3.div.style : g2;
                  y.prototype[k2 + "Setter"].call(this, e, t, d);
                  q && (q[t] = e);
                };
              });
              a3.addedSetters = true;
            };
            m.textSetter = function(g2) {
              g2 !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a2.setElementHTML(this.element, A(g2, "")), this.textStr = g2, m.doTransform = true);
            };
            g(m, m.element.style);
            m.xSetter = m.ySetter = m.alignSetter = m.rotationSetter = function(a3, g2) {
              "align" === g2 ? m.alignValue = m.textAlign = a3 : m[g2] = a3;
              m.doTransform = true;
            };
            m.afterSetters = function() {
              this.doTransform && (this.htmlUpdateTransform(), this.doTransform = false);
            };
            m.attr({ text: f, x: Math.round(h), y: Math.round(r) }).css({ position: "absolute" });
            k.styledMode || m.css({ fontFamily: this.style.fontFamily, fontSize: this.style.fontSize });
            n.style.whiteSpace = "nowrap";
            m.css = m.htmlCss;
            m.add = function(a3) {
              const f2 = k.box.parentNode, h2 = [];
              let e;
              if (this.parentGroup = a3) {
                if (e = a3.div, !e) {
                  for (; a3; )
                    h2.push(a3), a3 = a3.parentGroup;
                  h2.reverse().forEach(function(a4) {
                    function d(b, d2) {
                      a4[d2] = b;
                      "translateX" === d2 ? c.left = b + "px" : c.top = b + "px";
                      a4.doTransform = true;
                    }
                    const q = w(a4.element, "class"), t = a4.styles || {};
                    e = a4.div = a4.div || E("div", q ? { className: q } : void 0, { position: "absolute", left: (a4.translateX || 0) + "px", top: (a4.translateY || 0) + "px", display: a4.display, opacity: a4.opacity, cursor: t.cursor, pointerEvents: t.pointerEvents, visibility: a4.visibility }, e || f2);
                    const c = e.style;
                    C(a4, { classSetter: function(b) {
                      return function(c2) {
                        this.element.setAttribute(
                          "class",
                          c2
                        );
                        b.className = c2;
                      };
                    }(e), on: function() {
                      h2[0].div && m.on.apply({ element: h2[0].div, onEvents: a4.onEvents }, arguments);
                      return a4;
                    }, translateXSetter: d, translateYSetter: d });
                    a4.addedSetters || g(a4);
                  });
                }
              } else
                e = f2;
              e.appendChild(n);
              m.added = true;
              m.alignOnAdd && m.htmlUpdateTransform();
              return m;
            };
            return m;
          }
        }
        return v;
      });
      M(a, "Core/Axis/AxisDefaults.js", [], function() {
        var a2;
        (function(a3) {
          a3.defaultXAxisOptions = {
            alignTicks: true,
            allowDecimals: void 0,
            panningEnabled: true,
            zIndex: 2,
            zoomEnabled: true,
            dateTimeLabelFormats: { millisecond: {
              main: "%H:%M:%S.%L",
              range: false
            }, second: { main: "%H:%M:%S", range: false }, minute: { main: "%H:%M", range: false }, hour: { main: "%H:%M", range: false }, day: { main: "%e %b" }, week: { main: "%e %b" }, month: { main: "%b '%y" }, year: { main: "%Y" } },
            endOnTick: false,
            gridLineDashStyle: "Solid",
            gridZIndex: 1,
            labels: { autoRotation: void 0, autoRotationLimit: 80, distance: 15, enabled: true, indentation: 10, overflow: "justify", padding: 5, reserveSpace: void 0, rotation: void 0, staggerLines: 0, step: 0, useHTML: false, zIndex: 7, style: { color: "#333333", cursor: "default", fontSize: "0.8em" } },
            maxPadding: 0.01,
            minorGridLineDashStyle: "Solid",
            minorTickLength: 2,
            minorTickPosition: "outside",
            minorTicksPerMajor: 5,
            minPadding: 0.01,
            offset: void 0,
            opposite: false,
            reversed: void 0,
            reversedStacks: false,
            showEmpty: true,
            showFirstLabel: true,
            showLastLabel: true,
            startOfWeek: 1,
            startOnTick: false,
            tickLength: 10,
            tickPixelInterval: 100,
            tickmarkPlacement: "between",
            tickPosition: "outside",
            title: { align: "middle", rotation: 0, useHTML: false, x: 0, y: 0, style: { color: "#666666", fontSize: "0.8em" } },
            type: "linear",
            uniqueNames: true,
            visible: true,
            minorGridLineColor: "#f2f2f2",
            minorGridLineWidth: 1,
            minorTickColor: "#999999",
            lineColor: "#333333",
            lineWidth: 1,
            gridLineColor: "#e6e6e6",
            gridLineWidth: void 0,
            tickColor: "#333333"
          };
          a3.defaultYAxisOptions = { reversedStacks: true, endOnTick: true, maxPadding: 0.05, minPadding: 0.05, tickPixelInterval: 72, showLastLabel: true, labels: { x: void 0 }, startOnTick: true, title: { rotation: 270, text: "Values" }, stackLabels: { animation: {}, allowOverlap: false, enabled: false, crop: true, overflow: "justify", formatter: function() {
            const { numberFormatter: a4 } = this.axis.chart;
            return a4(this.total || 0, -1);
          }, style: {
            color: "#000000",
            fontSize: "0.7em",
            fontWeight: "bold",
            textOutline: "1px contrast"
          } }, gridLineWidth: 1, lineWidth: 0 };
          a3.defaultLeftAxisOptions = { title: { rotation: 270 } };
          a3.defaultRightAxisOptions = { title: { rotation: 90 } };
          a3.defaultBottomAxisOptions = { labels: { autoRotation: [-45] }, margin: 15, title: { rotation: 0 } };
          a3.defaultTopAxisOptions = { labels: { autoRotation: [-45] }, margin: 15, title: { rotation: 0 } };
        })(a2 || (a2 = {}));
        return a2;
      });
      M(a, "Core/Foundation.js", [a["Core/Utilities.js"]], function(a2) {
        const { addEvent: w, isFunction: H, objectEach: K, removeEvent: B } = a2;
        var E;
        (function(a3) {
          a3.registerEventOptions = function(a4, u) {
            a4.eventOptions = a4.eventOptions || {};
            K(u.events, function(v, f) {
              a4.eventOptions[f] !== v && (a4.eventOptions[f] && (B(a4, f, a4.eventOptions[f]), delete a4.eventOptions[f]), H(v) && (a4.eventOptions[f] = v, w(a4, f, v, { order: 0 })));
            });
          };
        })(E || (E = {}));
        return E;
      });
      M(a, "Core/Axis/Tick.js", [a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, y, H) {
        const { deg2rad: w } = y, {
          clamp: B,
          correctFloat: E,
          defined: C,
          destroyObjectProperties: A,
          extend: u,
          fireEvent: v,
          isNumber: f,
          merge: h,
          objectEach: r,
          pick: m
        } = H;
        class n {
          constructor(a3, g, f2, m2, h2) {
            this.isNewLabel = this.isNew = true;
            this.axis = a3;
            this.pos = g;
            this.type = f2 || "";
            this.parameters = h2 || {};
            this.tickmarkOffset = this.parameters.tickmarkOffset;
            this.options = this.parameters.options;
            v(this, "init");
            f2 || m2 || this.addLabel();
          }
          addLabel() {
            const k = this, g = k.axis;
            var h2 = g.options;
            const n2 = g.chart;
            var r2 = g.categories;
            const e = g.logarithmic, t = g.names, d = k.pos, q = m(k.options && k.options.labels, h2.labels);
            var x = g.tickPositions;
            const c = d === x[0], b = d === x[x.length - 1], p = (!q.step || 1 === q.step) && 1 === g.tickInterval;
            x = x.info;
            let l = k.label, L, N, O;
            r2 = this.parameters.category || (r2 ? m(r2[d], t[d], d) : d);
            e && f(r2) && (r2 = E(e.lin2log(r2)));
            g.dateTime && (x ? (N = n2.time.resolveDTLFormat(h2.dateTimeLabelFormats[!h2.grid && x.higherRanks[d] || x.unitName]), L = N.main) : f(r2) && (L = g.dateTime.getXDateFormat(r2, h2.dateTimeLabelFormats || {})));
            k.isFirst = c;
            k.isLast = b;
            const w2 = { axis: g, chart: n2, dateTimeLabelFormat: L, isFirst: c, isLast: b, pos: d, tick: k, tickPositionInfo: x, value: r2 };
            v(this, "labelFormat", w2);
            const S = (b2) => q.formatter ? q.formatter.call(b2, b2) : q.format ? (b2.text = g.defaultLabelFormatter.call(b2, b2), a2.format(q.format, b2, n2)) : g.defaultLabelFormatter.call(b2, b2);
            h2 = S.call(w2, w2);
            const A2 = N && N.list;
            k.shortenLabel = A2 ? function() {
              for (O = 0; O < A2.length; O++)
                if (u(w2, { dateTimeLabelFormat: A2[O] }), l.attr({ text: S.call(w2, w2) }), l.getBBox().width < g.getSlotWidth(k) - 2 * q.padding)
                  return;
              l.attr({ text: "" });
            } : void 0;
            p && g._addedPlotLB && k.moveLabel(h2, q);
            C(l) || k.movedLabel ? l && l.textStr !== h2 && !p && (!l.textWidth || q.style.width || l.styles.width || l.css({ width: null }), l.attr({ text: h2 }), l.textPxLength = l.getBBox().width) : (k.label = l = k.createLabel({ x: 0, y: 0 }, h2, q), k.rotation = 0);
          }
          createLabel(a3, g, f2) {
            const k = this.axis, m2 = k.chart;
            if (a3 = C(g) && f2.enabled ? m2.renderer.text(g, a3.x, a3.y, f2.useHTML).add(k.labelGroup) : null)
              m2.styledMode || a3.css(h(f2.style)), a3.textPxLength = a3.getBBox().width;
            return a3;
          }
          destroy() {
            A(this, this.axis);
          }
          getPosition(a3, g, f2, m2) {
            const k = this.axis, e = k.chart, t = m2 && e.oldChartHeight || e.chartHeight;
            a3 = { x: a3 ? E(k.translate(g + f2, void 0, void 0, m2) + k.transB) : k.left + k.offset + (k.opposite ? (m2 && e.oldChartWidth || e.chartWidth) - k.right - k.left : 0), y: a3 ? t - k.bottom + k.offset - (k.opposite ? k.height : 0) : E(t - k.translate(g + f2, void 0, void 0, m2) - k.transB) };
            a3.y = B(a3.y, -1e5, 1e5);
            v(this, "afterGetPosition", { pos: a3 });
            return a3;
          }
          getLabelPosition(a3, g, f2, h2, n2, e, t, d) {
            const q = this.axis, k = q.transA, c = q.isLinked && q.linkedParent ? q.linkedParent.reversed : q.reversed, b = q.staggerLines, p = q.tickRotCorr || { x: 0, y: 0 }, l = h2 || q.reserveSpaceDefault ? 0 : -q.labelOffset * ("center" === q.labelAlign ? 0.5 : 1), L = n2.distance, r2 = {};
            f2 = 0 === q.side ? f2.rotation ? -L : -f2.getBBox().height : 2 === q.side ? p.y + L : Math.cos(f2.rotation * w) * (p.y - f2.getBBox(false, 0).height / 2);
            C(n2.y) && (f2 = 0 === q.side && q.horiz ? n2.y + f2 : n2.y);
            a3 = a3 + m(n2.x, [0, 1, 0, -1][q.side] * L) + l + p.x - (e && h2 ? e * k * (c ? -1 : 1) : 0);
            g = g + f2 - (e && !h2 ? e * k * (c ? 1 : -1) : 0);
            b && (h2 = t / (d || 1) % b, q.opposite && (h2 = b - h2 - 1), g += q.labelOffset / b * h2);
            r2.x = a3;
            r2.y = Math.round(g);
            v(this, "afterGetLabelPosition", { pos: r2, tickmarkOffset: e, index: t });
            return r2;
          }
          getLabelSize() {
            return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
          }
          getMarkPath(a3, g, f2, m2, h2, e) {
            return e.crispLine([[
              "M",
              a3,
              g
            ], ["L", a3 + (h2 ? 0 : -f2), g + (h2 ? f2 : 0)]], m2);
          }
          handleOverflow(a3) {
            const g = this.axis, f2 = g.options.labels, k = a3.x;
            var h2 = g.chart.chartWidth, e = g.chart.spacing;
            const t = m(g.labelLeft, Math.min(g.pos, e[3]));
            e = m(g.labelRight, Math.max(g.isRadial ? 0 : g.pos + g.len, h2 - e[1]));
            const d = this.label, q = this.rotation, x = { left: 0, center: 0.5, right: 1 }[g.labelAlign || d.attr("align")], c = d.getBBox().width, b = g.getSlotWidth(this), p = {};
            let l = b, n2 = 1, r2;
            if (q || "justify" !== f2.overflow)
              0 > q && k - x * c < t ? r2 = Math.round(k / Math.cos(q * w) - t) : 0 < q && k + x * c > e && (r2 = Math.round((h2 - k) / Math.cos(q * w)));
            else if (h2 = k + (1 - x) * c, k - x * c < t ? l = a3.x + l * (1 - x) - t : h2 > e && (l = e - a3.x + l * x, n2 = -1), l = Math.min(b, l), l < b && "center" === g.labelAlign && (a3.x += n2 * (b - l - x * (b - Math.min(c, l)))), c > l || g.autoRotation && (d.styles || {}).width)
              r2 = l;
            r2 && (this.shortenLabel ? this.shortenLabel() : (p.width = Math.floor(r2) + "px", (f2.style || {}).textOverflow || (p.textOverflow = "ellipsis"), d.css(p)));
          }
          moveLabel(a3, g) {
            const f2 = this;
            var k = f2.label;
            const m2 = f2.axis;
            let e = false;
            k && k.textStr === a3 ? (f2.movedLabel = k, e = true, delete f2.label) : r(m2.ticks, function(g2) {
              e || g2.isNew || g2 === f2 || !g2.label || g2.label.textStr !== a3 || (f2.movedLabel = g2.label, e = true, g2.labelPos = f2.movedLabel.xy, delete g2.label);
            });
            e || !f2.labelPos && !k || (k = f2.labelPos || k.xy, f2.movedLabel = f2.createLabel(k, a3, g), f2.movedLabel && f2.movedLabel.attr({ opacity: 0 }));
          }
          render(a3, g, f2) {
            var k = this.axis, h2 = k.horiz, e = this.pos, t = m(this.tickmarkOffset, k.tickmarkOffset);
            e = this.getPosition(h2, e, t, g);
            t = e.x;
            const d = e.y;
            k = h2 && t === k.pos + k.len || !h2 && d === k.pos ? -1 : 1;
            h2 = m(f2, this.label && this.label.newOpacity, 1);
            f2 = m(f2, 1);
            this.isActive = true;
            this.renderGridLine(
              g,
              f2,
              k
            );
            this.renderMark(e, f2, k);
            this.renderLabel(e, g, h2, a3);
            this.isNew = false;
            v(this, "afterRender");
          }
          renderGridLine(a3, g, f2) {
            const k = this.axis, h2 = k.options, e = {}, t = this.pos, d = this.type, q = m(this.tickmarkOffset, k.tickmarkOffset), x = k.chart.renderer;
            let c = this.gridLine, b = h2.gridLineWidth, p = h2.gridLineColor, l = h2.gridLineDashStyle;
            "minor" === this.type && (b = h2.minorGridLineWidth, p = h2.minorGridLineColor, l = h2.minorGridLineDashStyle);
            c || (k.chart.styledMode || (e.stroke = p, e["stroke-width"] = b || 0, e.dashstyle = l), d || (e.zIndex = 1), a3 && (g = 0), this.gridLine = c = x.path().attr(e).addClass("highcharts-" + (d ? d + "-" : "") + "grid-line").add(k.gridGroup));
            if (c && (f2 = k.getPlotLinePath({ value: t + q, lineWidth: c.strokeWidth() * f2, force: "pass", old: a3, acrossPanes: false })))
              c[a3 || this.isNew ? "attr" : "animate"]({ d: f2, opacity: g });
          }
          renderMark(a3, g, f2) {
            const k = this.axis;
            var h2 = k.options;
            const e = k.chart.renderer, t = this.type, d = k.tickSize(t ? t + "Tick" : "tick"), q = a3.x;
            a3 = a3.y;
            const x = m(h2["minor" !== t ? "tickWidth" : "minorTickWidth"], !t && k.isXAxis ? 1 : 0);
            h2 = h2["minor" !== t ? "tickColor" : "minorTickColor"];
            let c = this.mark;
            const b = !c;
            d && (k.opposite && (d[0] = -d[0]), c || (this.mark = c = e.path().addClass("highcharts-" + (t ? t + "-" : "") + "tick").add(k.axisGroup), k.chart.styledMode || c.attr({ stroke: h2, "stroke-width": x })), c[b ? "attr" : "animate"]({ d: this.getMarkPath(q, a3, d[0], c.strokeWidth() * f2, k.horiz, e), opacity: g }));
          }
          renderLabel(a3, g, h2, n2) {
            var k = this.axis;
            const e = k.horiz, t = k.options, d = this.label, q = t.labels, x = q.step;
            k = m(this.tickmarkOffset, k.tickmarkOffset);
            const c = a3.x;
            a3 = a3.y;
            let b = true;
            d && f(c) && (d.xy = a3 = this.getLabelPosition(
              c,
              a3,
              d,
              e,
              q,
              k,
              n2,
              x
            ), this.isFirst && !this.isLast && !t.showFirstLabel || this.isLast && !this.isFirst && !t.showLastLabel ? b = false : !e || q.step || q.rotation || g || 0 === h2 || this.handleOverflow(a3), x && n2 % x && (b = false), b && f(a3.y) ? (a3.opacity = h2, d[this.isNewLabel ? "attr" : "animate"](a3).show(true), this.isNewLabel = false) : (d.hide(), this.isNewLabel = true));
          }
          replaceMovedLabel() {
            const a3 = this.label, g = this.axis;
            a3 && !this.isNew && (a3.animate({ opacity: 0 }, void 0, a3.destroy), delete this.label);
            g.isDirty = true;
            this.label = this.movedLabel;
            delete this.movedLabel;
          }
        }
        "";
        return n;
      });
      M(a, "Core/Axis/Axis.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/AxisDefaults.js"], a["Core/Color/Color.js"], a["Core/Defaults.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Axis/Tick.js"], a["Core/Utilities.js"]], function(a2, y, H, K, B, E, C, A) {
        const { animObject: u } = a2, { defaultOptions: v } = K, { registerEventOptions: f } = B, { deg2rad: h } = E, {
          arrayMax: r,
          arrayMin: m,
          clamp: n,
          correctFloat: k,
          defined: g,
          destroyObjectProperties: w,
          erase: F,
          error: z,
          extend: e,
          fireEvent: t,
          isArray: d,
          isNumber: q,
          isString: x,
          merge: c,
          normalizeTickInterval: b,
          objectEach: p,
          pick: l,
          relativeLength: L,
          removeEvent: N,
          splat: O,
          syncTimeout: Z
        } = A, S = (c2, a3) => b(a3, void 0, void 0, l(c2.options.allowDecimals, 0.5 > a3 || void 0 !== c2.tickAmount), !!c2.tickAmount);
        class U {
          constructor(b2, c2) {
            this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;
            this.init(b2, c2);
          }
          init(b2, c2) {
            const a3 = c2.isX;
            this.chart = b2;
            this.horiz = b2.inverted && !this.isZAxis ? !a3 : a3;
            this.isXAxis = a3;
            this.coll = this.coll || (a3 ? "xAxis" : "yAxis");
            t(this, "init", { userOptions: c2 });
            this.opposite = l(c2.opposite, this.opposite);
            this.side = l(c2.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
            this.setOptions(c2);
            const d2 = this.options, e2 = d2.labels, D = d2.type;
            this.userOptions = c2;
            this.minPixelPadding = 0;
            this.reversed = l(d2.reversed, this.reversed);
            this.visible = d2.visible;
            this.zoomEnabled = d2.zoomEnabled;
            this.hasNames = "category" === D || true === d2.categories;
            this.categories = d2.categories || (this.hasNames ? [] : void 0);
            this.names || (this.names = [], this.names.keys = {});
            this.plotLinesAndBandsGroups = {};
            this.positiveValuesOnly = !!this.logarithmic;
            this.isLinked = g(d2.linkedTo);
            this.ticks = {};
            this.labelEdge = [];
            this.minorTicks = {};
            this.plotLinesAndBands = [];
            this.alternateBands = {};
            this.len = 0;
            this.minRange = this.userMinRange = d2.minRange || d2.maxZoom;
            this.range = d2.range;
            this.offset = d2.offset || 0;
            this.min = this.max = null;
            c2 = l(d2.crosshair, O(b2.options.tooltip.crosshairs)[a3 ? 0 : 1]);
            this.crosshair = true === c2 ? {} : c2;
            -1 === b2.axes.indexOf(this) && (a3 ? b2.axes.splice(b2.xAxis.length, 0, this) : b2.axes.push(this), b2[this.coll].push(this));
            this.series = this.series || [];
            b2.inverted && !this.isZAxis && a3 && "undefined" === typeof this.reversed && (this.reversed = true);
            this.labelRotation = q(e2.rotation) ? e2.rotation : void 0;
            f(this, d2);
            t(this, "afterInit");
          }
          setOptions(b2) {
            this.options = c(
              y.defaultXAxisOptions,
              "yAxis" === this.coll && y.defaultYAxisOptions,
              [y.defaultTopAxisOptions, y.defaultRightAxisOptions, y.defaultBottomAxisOptions, y.defaultLeftAxisOptions][this.side],
              c(v[this.coll], b2)
            );
            t(this, "afterSetOptions", { userOptions: b2 });
          }
          defaultLabelFormatter(b2) {
            var c2 = this.axis;
            ({ numberFormatter: b2 } = this.chart);
            const a3 = q(this.value) ? this.value : NaN, d2 = c2.chart.time, l2 = this.dateTimeLabelFormat;
            var e2 = v.lang;
            const p2 = e2.numericSymbols;
            e2 = e2.numericSymbolMagnitude || 1e3;
            const G = c2.logarithmic ? Math.abs(a3) : c2.tickInterval;
            let g2 = p2 && p2.length, f2;
            if (c2.categories)
              f2 = `${this.value}`;
            else if (l2)
              f2 = d2.dateFormat(l2, a3);
            else if (g2 && 1e3 <= G)
              for (; g2-- && "undefined" === typeof f2; )
                c2 = Math.pow(e2, g2 + 1), G >= c2 && 0 === 10 * a3 % c2 && null !== p2[g2] && 0 !== a3 && (f2 = b2(a3 / c2, -1) + p2[g2]);
            "undefined" === typeof f2 && (f2 = 1e4 <= Math.abs(a3) ? b2(a3, -1) : b2(a3, -1, void 0, ""));
            return f2;
          }
          getSeriesExtremes() {
            const b2 = this, c2 = b2.chart;
            let a3;
            t(this, "getSeriesExtremes", null, function() {
              b2.hasVisibleSeries = false;
              b2.dataMin = b2.dataMax = b2.threshold = null;
              b2.softThreshold = !b2.isXAxis;
              b2.series.forEach(function(d2) {
                if (d2.visible || !c2.options.chart.ignoreHiddenSeries) {
                  var e2 = d2.options;
                  let c3 = e2.threshold, p2, G;
                  b2.hasVisibleSeries = true;
                  b2.positiveValuesOnly && 0 >= c3 && (c3 = null);
                  if (b2.isXAxis)
                    (e2 = d2.xData) && e2.length && (e2 = b2.logarithmic ? e2.filter((b3) => 0 < b3) : e2, a3 = d2.getXExtremes(e2), p2 = a3.min, G = a3.max, q(p2) || p2 instanceof Date || (e2 = e2.filter(q), a3 = d2.getXExtremes(e2), p2 = a3.min, G = a3.max), e2.length && (b2.dataMin = Math.min(l(b2.dataMin, p2), p2), b2.dataMax = Math.max(l(b2.dataMax, G), G)));
                  else if (d2 = d2.applyExtremes(), q(d2.dataMin) && (p2 = d2.dataMin, b2.dataMin = Math.min(l(b2.dataMin, p2), p2)), q(d2.dataMax) && (G = d2.dataMax, b2.dataMax = Math.max(l(b2.dataMax, G), G)), g(c3) && (b2.threshold = c3), !e2.softThreshold || b2.positiveValuesOnly)
                    b2.softThreshold = false;
                }
              });
            });
            t(this, "afterGetSeriesExtremes");
          }
          translate(b2, c2, a3, d2, l2, e2) {
            const p2 = this.linkedParent || this, D = d2 && p2.old ? p2.old.min : p2.min;
            if (!q(D))
              return NaN;
            const g2 = p2.minPixelPadding;
            l2 = (p2.isOrdinal || p2.brokenAxis && p2.brokenAxis.hasBreaks || p2.logarithmic && l2) && p2.lin2val;
            let G = 1, f2 = 0;
            d2 = d2 && p2.old ? p2.old.transA : p2.transA;
            d2 || (d2 = p2.transA);
            a3 && (G *= -1, f2 = p2.len);
            p2.reversed && (G *= -1, f2 -= G * (p2.sector || p2.len));
            c2 ? (e2 = (b2 * G + f2 - g2) / d2 + D, l2 && (e2 = p2.lin2val(e2))) : (l2 && (b2 = p2.val2lin(b2)), b2 = G * (b2 - D) * d2, e2 = (p2.isRadial ? b2 : k(b2)) + f2 + G * g2 + (q(e2) ? d2 * e2 : 0));
            return e2;
          }
          toPixels(b2, c2) {
            return this.translate(
              b2,
              false,
              !this.horiz,
              void 0,
              true
            ) + (c2 ? 0 : this.pos);
          }
          toValue(b2, c2) {
            return this.translate(b2 - (c2 ? 0 : this.pos), true, !this.horiz, void 0, true);
          }
          getPlotLinePath(b2) {
            function c2(b3, c3, a4) {
              "pass" !== r2 && (b3 < c3 || b3 > a4) && (r2 ? b3 = n(b3, c3, a4) : ba = true);
              return b3;
            }
            const a3 = this, d2 = a3.chart, e2 = a3.left, p2 = a3.top, g2 = b2.old, G = b2.value, f2 = b2.lineWidth, k2 = g2 && d2.oldChartHeight || d2.chartHeight, h2 = g2 && d2.oldChartWidth || d2.chartWidth, m2 = a3.transB;
            let x2 = b2.translatedValue, r2 = b2.force, L2, N2, O2, W, ba;
            b2 = { value: G, lineWidth: f2, old: g2, force: r2, acrossPanes: b2.acrossPanes, translatedValue: x2 };
            t(this, "getPlotLinePath", b2, function(b3) {
              x2 = l(x2, a3.translate(G, void 0, void 0, g2));
              x2 = n(x2, -1e5, 1e5);
              L2 = O2 = Math.round(x2 + m2);
              N2 = W = Math.round(k2 - x2 - m2);
              q(x2) ? a3.horiz ? (N2 = p2, W = k2 - a3.bottom, L2 = O2 = c2(L2, e2, e2 + a3.width)) : (L2 = e2, O2 = h2 - a3.right, N2 = W = c2(N2, p2, p2 + a3.height)) : (ba = true, r2 = false);
              b3.path = ba && !r2 ? null : d2.renderer.crispLine([["M", L2, N2], ["L", O2, W]], f2 || 1);
            });
            return b2.path;
          }
          getLinearTickPositions(b2, c2, a3) {
            const d2 = k(Math.floor(c2 / b2) * b2);
            a3 = k(Math.ceil(a3 / b2) * b2);
            const l2 = [];
            let e2, p2;
            k(d2 + b2) === d2 && (p2 = 20);
            if (this.single)
              return [c2];
            for (c2 = d2; c2 <= a3; ) {
              l2.push(c2);
              c2 = k(c2 + b2, p2);
              if (c2 === e2)
                break;
              e2 = c2;
            }
            return l2;
          }
          getMinorTickInterval() {
            const b2 = this.options;
            return true === b2.minorTicks ? l(b2.minorTickInterval, "auto") : false === b2.minorTicks ? null : b2.minorTickInterval;
          }
          getMinorTickPositions() {
            var b2 = this.options;
            const c2 = this.tickPositions, a3 = this.minorTickInterval;
            var d2 = this.pointRangePadding || 0;
            const l2 = this.min - d2;
            d2 = this.max + d2;
            const e2 = d2 - l2;
            let p2 = [];
            if (e2 && e2 / a3 < this.len / 3) {
              const e3 = this.logarithmic;
              if (e3)
                this.paddedTicks.forEach(function(b3, c3, d3) {
                  c3 && p2.push.apply(p2, e3.getLogTickPositions(a3, d3[c3 - 1], d3[c3], true));
                });
              else if (this.dateTime && "auto" === this.getMinorTickInterval())
                p2 = p2.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(a3), l2, d2, b2.startOfWeek));
              else
                for (b2 = l2 + (c2[0] - l2) % a3; b2 <= d2 && b2 !== p2[0]; b2 += a3)
                  p2.push(b2);
            }
            0 !== p2.length && this.trimTicks(p2);
            return p2;
          }
          adjustForMinRange() {
            const b2 = this.options, c2 = this.logarithmic;
            let a3 = this.min;
            var d2 = this.max;
            let e2, p2 = 0, q2, f2, t2, k2, h2;
            this.isXAxis && "undefined" === typeof this.minRange && !c2 && (g(b2.min) || g(b2.max) || g(b2.floor) || g(b2.ceiling) ? this.minRange = null : (this.series.forEach(function(b3) {
              t2 = b3.xData;
              k2 = b3.xIncrement ? 1 : t2.length - 1;
              if (1 < t2.length) {
                for (q2 = k2; 0 < q2; q2--)
                  if (f2 = t2[q2] - t2[q2 - 1], !p2 || f2 < p2)
                    p2 = f2;
              }
            }), this.minRange = Math.min(5 * p2, this.dataMax - this.dataMin)));
            if (d2 - a3 < this.minRange) {
              e2 = this.dataMax - this.dataMin >= this.minRange;
              h2 = this.minRange;
              var x2 = (h2 - d2 + a3) / 2;
              x2 = [a3 - x2, l(b2.min, a3 - x2)];
              e2 && (x2[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
              a3 = r(x2);
              d2 = [a3 + h2, l(b2.max, a3 + h2)];
              e2 && (d2[2] = c2 ? c2.log2lin(this.dataMax) : this.dataMax);
              d2 = m(d2);
              d2 - a3 < h2 && (x2[0] = d2 - h2, x2[1] = l(b2.min, d2 - h2), a3 = r(x2));
            }
            this.min = a3;
            this.max = d2;
          }
          getClosest() {
            let b2;
            this.categories ? b2 = 1 : this.series.forEach(function(c2) {
              const a3 = c2.closestPointRange, d2 = c2.visible || !c2.chart.options.chart.ignoreHiddenSeries;
              !c2.noSharedTooltip && g(a3) && d2 && (b2 = g(b2) ? Math.min(b2, a3) : a3);
            });
            return b2;
          }
          nameToX(b2) {
            const c2 = d(this.options.categories), a3 = c2 ? this.categories : this.names;
            let e2 = b2.options.x, p2;
            b2.series.requireSorting = false;
            g(e2) || (e2 = this.options.uniqueNames && a3 ? c2 ? a3.indexOf(b2.name) : l(a3.keys[b2.name], -1) : b2.series.autoIncrement());
            -1 === e2 ? !c2 && a3 && (p2 = a3.length) : p2 = e2;
            "undefined" !== typeof p2 ? (this.names[p2] = b2.name, this.names.keys[b2.name] = p2) : b2.x && (p2 = b2.x);
            return p2;
          }
          updateNames() {
            const b2 = this, c2 = this.names;
            0 < c2.length && (Object.keys(c2.keys).forEach(function(b3) {
              delete c2.keys[b3];
            }), c2.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function(c3) {
              c3.xIncrement = null;
              if (!c3.points || c3.isDirtyData)
                b2.max = Math.max(b2.max, c3.xData.length - 1), c3.processData(), c3.generatePoints();
              c3.data.forEach(function(a3, d2) {
                let l2;
                a3 && a3.options && "undefined" !== typeof a3.name && (l2 = b2.nameToX(a3), "undefined" !== typeof l2 && l2 !== a3.x && (a3.x = l2, c3.xData[d2] = l2));
              });
            }));
          }
          setAxisTranslation() {
            const b2 = this, c2 = b2.max - b2.min;
            var a3 = b2.linkedParent;
            const d2 = !!b2.categories, e2 = b2.isXAxis;
            let p2 = b2.axisPointRange || 0, q2, g2 = 0, f2 = 0, k2 = b2.transA;
            if (e2 || d2 || p2)
              q2 = b2.getClosest(), a3 ? (g2 = a3.minPointOffset, f2 = a3.pointRangePadding) : b2.series.forEach(function(c3) {
                const a4 = d2 ? 1 : e2 ? l(c3.options.pointRange, q2, 0) : b2.axisPointRange || 0, D = c3.options.pointPlacement;
                p2 = Math.max(p2, a4);
                if (!b2.single || d2)
                  c3 = c3.is("xrange") ? !e2 : e2, g2 = Math.max(g2, c3 && x(D) ? 0 : a4 / 2), f2 = Math.max(f2, c3 && "on" === D ? 0 : a4);
              }), a3 = b2.ordinal && b2.ordinal.slope && q2 ? b2.ordinal.slope / q2 : 1, b2.minPointOffset = g2 *= a3, b2.pointRangePadding = f2 *= a3, b2.pointRange = Math.min(
                p2,
                b2.single && d2 ? 1 : c2
              ), e2 && (b2.closestPointRange = q2);
            b2.translationSlope = b2.transA = k2 = b2.staticScale || b2.len / (c2 + f2 || 1);
            b2.transB = b2.horiz ? b2.left : b2.bottom;
            b2.minPixelPadding = k2 * g2;
            t(this, "afterSetAxisTranslation");
          }
          minFromRange() {
            return this.max - this.range;
          }
          setTickInterval(b2) {
            var c2 = this.chart;
            const a3 = this.logarithmic, d2 = this.options, e2 = this.isXAxis, p2 = this.isLinked, f2 = d2.tickPixelInterval, h2 = this.categories, G = this.softThreshold;
            let m2 = d2.maxPadding, x2 = d2.minPadding;
            let r2 = q(d2.tickInterval) && 0 <= d2.tickInterval ? d2.tickInterval : void 0, n2 = q(this.threshold) ? this.threshold : null, L2, N2, O2;
            this.dateTime || h2 || p2 || this.getTickAmount();
            N2 = l(this.userMin, d2.min);
            O2 = l(this.userMax, d2.max);
            if (p2) {
              this.linkedParent = c2[this.coll][d2.linkedTo];
              var v2 = this.linkedParent.getExtremes();
              this.min = l(v2.min, v2.dataMin);
              this.max = l(v2.max, v2.dataMax);
              d2.type !== this.linkedParent.options.type && z(11, 1, c2);
            } else
              G && g(n2) && (this.dataMin >= n2 ? (v2 = n2, x2 = 0) : this.dataMax <= n2 && (L2 = n2, m2 = 0)), this.min = l(N2, v2, this.dataMin), this.max = l(O2, L2, this.dataMax);
            a3 && (this.positiveValuesOnly && !b2 && 0 >= Math.min(
              this.min,
              l(this.dataMin, this.min)
            ) && z(10, 1, c2), this.min = k(a3.log2lin(this.min), 16), this.max = k(a3.log2lin(this.max), 16));
            this.range && g(this.max) && (this.userMin = this.min = N2 = Math.max(this.dataMin, this.minFromRange()), this.userMax = O2 = this.max, this.range = null);
            t(this, "foundExtremes");
            this.beforePadding && this.beforePadding();
            this.adjustForMinRange();
            !(h2 || this.axisPointRange || this.stacking && this.stacking.usePercentage || p2) && g(this.min) && g(this.max) && (c2 = this.max - this.min) && (!g(N2) && x2 && (this.min -= c2 * x2), !g(O2) && m2 && (this.max += c2 * m2));
            q(this.userMin) || (q(d2.softMin) && d2.softMin < this.min && (this.min = N2 = d2.softMin), q(d2.floor) && (this.min = Math.max(this.min, d2.floor)));
            q(this.userMax) || (q(d2.softMax) && d2.softMax > this.max && (this.max = O2 = d2.softMax), q(d2.ceiling) && (this.max = Math.min(this.max, d2.ceiling)));
            G && g(this.dataMin) && (n2 = n2 || 0, !g(N2) && this.min < n2 && this.dataMin >= n2 ? this.min = this.options.minRange ? Math.min(n2, this.max - this.minRange) : n2 : !g(O2) && this.max > n2 && this.dataMax <= n2 && (this.max = this.options.minRange ? Math.max(n2, this.min + this.minRange) : n2));
            q(this.min) && q(this.max) && !this.chart.polar && this.min > this.max && (g(this.options.min) ? this.max = this.min : g(this.options.max) && (this.min = this.max));
            this.tickInterval = this.min === this.max || "undefined" === typeof this.min || "undefined" === typeof this.max ? 1 : p2 && this.linkedParent && !r2 && f2 === this.linkedParent.options.tickPixelInterval ? r2 = this.linkedParent.tickInterval : l(r2, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, h2 ? 1 : (this.max - this.min) * f2 / Math.max(this.len, f2));
            if (e2 && !b2) {
              const b3 = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
              this.series.forEach(function(c3) {
                c3.forceCrop = c3.forceCropping && c3.forceCropping();
                c3.processData(b3);
              });
              t(this, "postProcessData", { hasExtremesChanged: b3 });
            }
            this.setAxisTranslation();
            t(this, "initialAxisTranslation");
            this.pointRange && !r2 && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
            b2 = l(d2.minTickInterval, this.dateTime && !this.series.some((b3) => b3.noSharedTooltip) ? this.closestPointRange : 0);
            !r2 && this.tickInterval < b2 && (this.tickInterval = b2);
            this.dateTime || this.logarithmic || r2 || (this.tickInterval = S(this, this.tickInterval));
            this.tickAmount || (this.tickInterval = this.unsquish());
            this.setTickPositions();
          }
          setTickPositions() {
            var b2 = this.options;
            const c2 = b2.tickPositions, a3 = b2.tickPositioner;
            var d2 = this.getMinorTickInterval(), l2 = this.hasVerticalPanning(), e2 = "colorAxis" === this.coll;
            const p2 = (e2 || !l2) && b2.startOnTick;
            l2 = (e2 || !l2) && b2.endOnTick;
            e2 = [];
            let f2;
            this.tickmarkOffset = this.categories && "between" === b2.tickmarkPlacement && 1 === this.tickInterval ? 0.5 : 0;
            this.minorTickInterval = "auto" === d2 && this.tickInterval ? this.tickInterval / b2.minorTicksPerMajor : d2;
            this.single = this.min === this.max && g(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || false !== b2.allowDecimals);
            if (c2)
              e2 = c2.slice();
            else if (q(this.min) && q(this.max)) {
              if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)))
                if (this.dateTime)
                  e2 = this.getTimeTicks(
                    this.dateTime.normalizeTimeTickInterval(this.tickInterval, b2.units),
                    this.min,
                    this.max,
                    b2.startOfWeek,
                    this.ordinal && this.ordinal.positions,
                    this.closestPointRange,
                    true
                  );
                else if (this.logarithmic)
                  e2 = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
                else
                  for (d2 = b2 = this.tickInterval; d2 <= 2 * b2; )
                    if (e2 = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && e2.length > this.tickAmount)
                      this.tickInterval = S(this, d2 *= 1.1);
                    else
                      break;
              else
                e2 = [this.min, this.max], z(19, false, this.chart);
              e2.length > this.len && (e2 = [e2[0], e2[e2.length - 1]], e2[0] === e2[1] && (e2.length = 1));
              a3 && (this.tickPositions = e2, (f2 = a3.apply(this, [this.min, this.max])) && (e2 = f2));
            }
            this.tickPositions = e2;
            this.paddedTicks = e2.slice(0);
            this.trimTicks(e2, p2, l2);
            !this.isLinked && q(this.min) && q(this.max) && (this.single && 2 > e2.length && !this.categories && !this.series.some((b3) => b3.is("heatmap") && "between" === b3.options.pointPlacement) && (this.min -= 0.5, this.max += 0.5), c2 || f2 || this.adjustTickAmount());
            t(this, "afterSetTickPositions");
          }
          trimTicks(b2, c2, a3) {
            const d2 = b2[0], e2 = b2[b2.length - 1], l2 = !this.isOrdinal && this.minPointOffset || 0;
            t(this, "trimTicks");
            if (!this.isLinked) {
              if (c2 && -Infinity !== d2)
                this.min = d2;
              else
                for (; this.min - l2 > b2[0]; )
                  b2.shift();
              if (a3)
                this.max = e2;
              else
                for (; this.max + l2 < b2[b2.length - 1]; )
                  b2.pop();
              0 === b2.length && g(d2) && !this.options.tickPositions && b2.push((e2 + d2) / 2);
            }
          }
          alignToOthers() {
            const b2 = this, c2 = [this], a3 = b2.options, d2 = "yAxis" === this.coll && this.chart.options.chart.alignThresholds, e2 = [];
            let l2;
            b2.thresholdAlignment = void 0;
            if ((false !== this.chart.options.chart.alignTicks && a3.alignTicks || d2) && false !== a3.startOnTick && false !== a3.endOnTick && !b2.logarithmic) {
              const a4 = (b3) => {
                const { horiz: c3, options: a5 } = b3;
                return [c3 ? a5.left : a5.top, a5.width, a5.height, a5.pane].join();
              }, d3 = a4(this);
              this.chart[this.coll].forEach(function(e3) {
                const { series: p2 } = e3;
                p2.length && p2.some((b3) => b3.visible) && e3 !== b2 && a4(e3) === d3 && (l2 = true, c2.push(e3));
              });
            }
            if (l2 && d2) {
              c2.forEach((c3) => {
                c3 = c3.getThresholdAlignment(b2);
                q(c3) && e2.push(c3);
              });
              const a4 = 1 < e2.length ? e2.reduce((b3, c3) => b3 + c3, 0) / e2.length : void 0;
              c2.forEach((b3) => {
                b3.thresholdAlignment = a4;
              });
            }
            return l2;
          }
          getThresholdAlignment(b2) {
            (!q(this.dataMin) || this !== b2 && this.series.some((b3) => b3.isDirty || b3.isDirtyData)) && this.getSeriesExtremes();
            if (q(this.threshold))
              return b2 = n((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (b2 = 1 - b2), b2;
          }
          getTickAmount() {
            const b2 = this.options, c2 = b2.tickPixelInterval;
            let a3 = b2.tickAmount;
            !g(b2.tickInterval) && !a3 && this.len < c2 && !this.isRadial && !this.logarithmic && b2.startOnTick && b2.endOnTick && (a3 = 2);
            !a3 && this.alignToOthers() && (a3 = Math.ceil(this.len / c2) + 1);
            4 > a3 && (this.finalTickAmt = a3, a3 = 5);
            this.tickAmount = a3;
          }
          adjustTickAmount() {
            const b2 = this, { finalTickAmt: c2, max: a3, min: d2, options: e2, tickPositions: p2, tickAmount: f2, thresholdAlignment: t2 } = b2, h2 = p2 && p2.length;
            var m2 = l(b2.threshold, b2.softThreshold ? 0 : null);
            var x2 = b2.tickInterval;
            let n2;
            q(t2) && (n2 = 0.5 > t2 ? Math.ceil(t2 * (f2 - 1)) : Math.floor(t2 * (f2 - 1)), e2.reversed && (n2 = f2 - 1 - n2));
            if (b2.hasData() && q(d2) && q(a3)) {
              const l2 = () => {
                b2.transA *= (h2 - 1) / (f2 - 1);
                b2.min = e2.startOnTick ? p2[0] : Math.min(d2, p2[0]);
                b2.max = e2.endOnTick ? p2[p2.length - 1] : Math.max(a3, p2[p2.length - 1]);
              };
              if (q(n2) && q(b2.threshold)) {
                for (; p2[n2] !== m2 || p2.length !== f2 || p2[0] > d2 || p2[p2.length - 1] < a3; ) {
                  p2.length = 0;
                  for (p2.push(b2.threshold); p2.length < f2; )
                    void 0 === p2[n2] || p2[n2] > b2.threshold ? p2.unshift(k(p2[0] - x2)) : p2.push(k(p2[p2.length - 1] + x2));
                  if (x2 > 8 * b2.tickInterval)
                    break;
                  x2 *= 2;
                }
                l2();
              } else if (h2 < f2) {
                for (; p2.length < f2; )
                  p2.length % 2 || d2 === m2 ? p2.push(k(p2[p2.length - 1] + x2)) : p2.unshift(k(p2[0] - x2));
                l2();
              }
              if (g(c2)) {
                for (x2 = m2 = p2.length; x2--; )
                  (3 === c2 && 1 === x2 % 2 || 2 >= c2 && 0 < x2 && x2 < m2 - 1) && p2.splice(x2, 1);
                b2.finalTickAmt = void 0;
              }
            }
          }
          setScale() {
            let b2 = false, c2 = false;
            this.series.forEach(function(a4) {
              b2 = b2 || a4.isDirtyData || a4.isDirty;
              c2 = c2 || a4.xAxis && a4.xAxis.isDirty || false;
            });
            this.setAxisSize();
            const a3 = this.len !== (this.old && this.old.len);
            a3 || b2 || c2 || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && (this.stacking.resetStacks(), this.stacking.buildStacks()), this.forceRedraw = false, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = a3 || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
            b2 && this.panningState && (this.panningState.isDirty = true);
            t(this, "afterSetScale");
          }
          setExtremes(b2, c2, a3, d2, p2) {
            const q2 = this, g2 = q2.chart;
            a3 = l(a3, true);
            q2.series.forEach(function(b3) {
              delete b3.kdTree;
            });
            p2 = e(p2, { min: b2, max: c2 });
            t(q2, "setExtremes", p2, function() {
              q2.userMin = b2;
              q2.userMax = c2;
              q2.eventArgs = p2;
              a3 && g2.redraw(d2);
            });
          }
          zoom(b2, c2) {
            const a3 = this, d2 = this.dataMin, e2 = this.dataMax, p2 = this.options, q2 = Math.min(d2, l(p2.min, d2)), f2 = Math.max(e2, l(p2.max, e2));
            b2 = { newMin: b2, newMax: c2 };
            t(this, "zoom", b2, function(b3) {
              let c3 = b3.newMin, l2 = b3.newMax;
              if (c3 !== a3.min || l2 !== a3.max)
                a3.allowZoomOutside || (g(d2) && (c3 < q2 && (c3 = q2), c3 > f2 && (c3 = f2)), g(e2) && (l2 < q2 && (l2 = q2), l2 > f2 && (l2 = f2))), a3.displayBtn = "undefined" !== typeof c3 || "undefined" !== typeof l2, a3.setExtremes(c3, l2, false, void 0, { trigger: "zoom" });
              b3.zoomed = true;
            });
            return b2.zoomed;
          }
          setAxisSize() {
            const b2 = this.chart;
            var c2 = this.options;
            const a3 = c2.offsets || [0, 0, 0, 0], d2 = this.horiz, e2 = this.width = Math.round(L(l(c2.width, b2.plotWidth - a3[3] + a3[1]), b2.plotWidth)), p2 = this.height = Math.round(L(l(c2.height, b2.plotHeight - a3[0] + a3[2]), b2.plotHeight)), q2 = this.top = Math.round(L(l(c2.top, b2.plotTop + a3[0]), b2.plotHeight, b2.plotTop));
            c2 = this.left = Math.round(L(
              l(c2.left, b2.plotLeft + a3[3]),
              b2.plotWidth,
              b2.plotLeft
            ));
            this.bottom = b2.chartHeight - p2 - q2;
            this.right = b2.chartWidth - e2 - c2;
            this.len = Math.max(d2 ? e2 : p2, 0);
            this.pos = d2 ? c2 : q2;
          }
          getExtremes() {
            const b2 = this.logarithmic;
            return { min: b2 ? k(b2.lin2log(this.min)) : this.min, max: b2 ? k(b2.lin2log(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax };
          }
          getThreshold(b2) {
            var c2 = this.logarithmic;
            const a3 = c2 ? c2.lin2log(this.min) : this.min;
            c2 = c2 ? c2.lin2log(this.max) : this.max;
            null === b2 || -Infinity === b2 ? b2 = a3 : Infinity === b2 ? b2 = c2 : a3 > b2 ? b2 = a3 : c2 < b2 && (b2 = c2);
            return this.translate(
              b2,
              0,
              1,
              0,
              1
            );
          }
          autoLabelAlign(b2) {
            const c2 = (l(b2, 0) - 90 * this.side + 720) % 360;
            b2 = { align: "center" };
            t(this, "autoLabelAlign", b2, function(b3) {
              15 < c2 && 165 > c2 ? b3.align = "right" : 195 < c2 && 345 > c2 && (b3.align = "left");
            });
            return b2.align;
          }
          tickSize(b2) {
            const c2 = this.options, a3 = l(c2["tick" === b2 ? "tickWidth" : "minorTickWidth"], "tick" === b2 && this.isXAxis && !this.categories ? 1 : 0);
            let d2 = c2["tick" === b2 ? "tickLength" : "minorTickLength"], e2;
            a3 && d2 && ("inside" === c2[b2 + "Position"] && (d2 = -d2), e2 = [d2, a3]);
            b2 = { tickSize: e2 };
            t(this, "afterTickSize", b2);
            return b2.tickSize;
          }
          labelMetrics() {
            const b2 = this.chart.renderer;
            var c2 = this.ticks;
            c2 = c2[Object.keys(c2)[0]] || {};
            return this.chart.renderer.fontMetrics(c2.label || c2.movedLabel || b2.box);
          }
          unsquish() {
            const b2 = this.options.labels;
            var c2 = this.horiz;
            const a3 = this.tickInterval, d2 = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / a3), e2 = b2.rotation, p2 = 0.75 * this.labelMetrics().h, g2 = Math.max(this.max - this.min, 0), f2 = function(b3) {
              let c3 = b3 / (d2 || 1);
              c3 = 1 < c3 ? Math.ceil(c3) : 1;
              c3 * a3 > g2 && Infinity !== b3 && Infinity !== d2 && g2 && (c3 = Math.ceil(g2 / a3));
              return k(c3 * a3);
            };
            let t2 = a3, m2, x2 = Number.MAX_VALUE, n2;
            if (c2) {
              if (b2.staggerLines || (q(e2) ? n2 = [e2] : d2 < b2.autoRotationLimit && (n2 = b2.autoRotation)), n2) {
                let b3;
                for (const a4 of n2)
                  if (a4 === e2 || a4 && -90 <= a4 && 90 >= a4)
                    c2 = f2(Math.abs(p2 / Math.sin(h * a4))), b3 = c2 + Math.abs(a4 / 360), b3 < x2 && (x2 = b3, m2 = a4, t2 = c2);
              }
            } else
              t2 = f2(p2);
            this.autoRotation = n2;
            this.labelRotation = l(m2, q(e2) ? e2 : 0);
            return b2.step ? a3 : t2;
          }
          getSlotWidth(b2) {
            const c2 = this.chart, a3 = this.horiz, d2 = this.options.labels, e2 = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), l2 = c2.margin[3];
            if (b2 && q(b2.slotWidth))
              return b2.slotWidth;
            if (a3 && 2 > d2.step)
              return d2.rotation ? 0 : (this.staggerLines || 1) * this.len / e2;
            if (!a3) {
              b2 = d2.style.width;
              if (void 0 !== b2)
                return parseInt(String(b2), 10);
              if (l2)
                return l2 - c2.spacing[3];
            }
            return 0.33 * c2.chartWidth;
          }
          renderUnsquish() {
            const b2 = this.chart, c2 = b2.renderer, a3 = this.tickPositions, d2 = this.ticks, e2 = this.options.labels, l2 = e2.style, p2 = this.horiz, q2 = this.getSlotWidth();
            var g2 = Math.max(1, Math.round(q2 - 2 * e2.padding));
            const f2 = {}, t2 = this.labelMetrics(), k2 = l2.textOverflow;
            let h2, m2, n2 = 0;
            x(e2.rotation) || (f2.rotation = e2.rotation || 0);
            a3.forEach(function(b3) {
              b3 = d2[b3];
              b3.movedLabel && b3.replaceMovedLabel();
              b3 && b3.label && b3.label.textPxLength > n2 && (n2 = b3.label.textPxLength);
            });
            this.maxLabelLength = n2;
            if (this.autoRotation)
              n2 > g2 && n2 > t2.h ? f2.rotation = this.labelRotation : this.labelRotation = 0;
            else if (q2 && (h2 = g2, !k2))
              for (m2 = "clip", g2 = a3.length; !p2 && g2--; ) {
                var r2 = a3[g2];
                if (r2 = d2[r2].label)
                  r2.styles && "ellipsis" === r2.styles.textOverflow ? r2.css({ textOverflow: "clip" }) : r2.textPxLength > q2 && r2.css({ width: q2 + "px" }), r2.getBBox().height > this.len / a3.length - (t2.h - t2.f) && (r2.specificTextOverflow = "ellipsis");
              }
            f2.rotation && (h2 = n2 > 0.5 * b2.chartHeight ? 0.33 * b2.chartHeight : n2, k2 || (m2 = "ellipsis"));
            if (this.labelAlign = e2.align || this.autoLabelAlign(this.labelRotation))
              f2.align = this.labelAlign;
            a3.forEach(function(b3) {
              const c3 = (b3 = d2[b3]) && b3.label, a4 = l2.width, e3 = {};
              c3 && (c3.attr(f2), b3.shortenLabel ? b3.shortenLabel() : h2 && !a4 && "nowrap" !== l2.whiteSpace && (h2 < c3.textPxLength || "SPAN" === c3.element.tagName) ? (e3.width = h2 + "px", k2 || (e3.textOverflow = c3.specificTextOverflow || m2), c3.css(e3)) : c3.styles && c3.styles.width && !e3.width && !a4 && c3.css({ width: null }), delete c3.specificTextOverflow, b3.rotation = f2.rotation);
            }, this);
            this.tickRotCorr = c2.rotCorr(
              t2.b,
              this.labelRotation || 0,
              0 !== this.side
            );
          }
          hasData() {
            return this.series.some(function(b2) {
              return b2.hasData();
            }) || this.options.showEmpty && g(this.min) && g(this.max);
          }
          addTitle(b2) {
            const a3 = this.chart.renderer, d2 = this.horiz, e2 = this.opposite, l2 = this.options.title, p2 = this.chart.styledMode;
            let q2;
            this.axisTitle || ((q2 = l2.textAlign) || (q2 = (d2 ? { low: "left", middle: "center", high: "right" } : { low: e2 ? "right" : "left", middle: "center", high: e2 ? "left" : "right" })[l2.align]), this.axisTitle = a3.text(l2.text || "", 0, 0, l2.useHTML).attr({
              zIndex: 7,
              rotation: l2.rotation,
              align: q2
            }).addClass("highcharts-axis-title"), p2 || this.axisTitle.css(c(l2.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = true);
            p2 || l2.style.width || this.isRadial || this.axisTitle.css({ width: this.len + "px" });
            this.axisTitle[b2 ? "show" : "hide"](b2);
          }
          generateTick(b2) {
            const c2 = this.ticks;
            c2[b2] ? c2[b2].addLabel() : c2[b2] = new C(this, b2);
          }
          getOffset() {
            const b2 = this, { chart: c2, horiz: a3, options: d2, side: e2, ticks: q2, tickPositions: f2, coll: k2, axisParent: h2 } = b2, m2 = c2.renderer, x2 = c2.inverted && !b2.isZAxis ? [1, 0, 3, 2][e2] : e2;
            var n2 = b2.hasData();
            const r2 = d2.title;
            var L2 = d2.labels, N2 = c2.axisOffset;
            const O2 = c2.clipOffset, v2 = [-1, 1, 1, -1][e2], W = d2.className;
            let ba, ea = 0, u2;
            var F2 = 0;
            let z2 = 0;
            b2.showAxis = ba = n2 || d2.showEmpty;
            b2.staggerLines = b2.horiz && L2.staggerLines || void 0;
            if (!b2.axisGroup) {
              const c3 = (b3, c4, a4) => m2.g(b3).attr({ zIndex: a4 }).addClass(`highcharts-${k2.toLowerCase()}${c4} ` + (this.isRadial ? `highcharts-radial-axis${c4} ` : "") + (W || "")).add(h2);
              b2.gridGroup = c3("grid", "-grid", d2.gridZIndex);
              b2.axisGroup = c3("axis", "", d2.zIndex);
              b2.labelGroup = c3("axis-labels", "-labels", L2.zIndex);
            }
            n2 || b2.isLinked ? (f2.forEach(function(c3) {
              b2.generateTick(c3);
            }), b2.renderUnsquish(), b2.reserveSpaceDefault = 0 === e2 || 2 === e2 || { 1: "left", 3: "right" }[e2] === b2.labelAlign, l(L2.reserveSpace, "center" === b2.labelAlign ? true : null, b2.reserveSpaceDefault) && f2.forEach(function(b3) {
              z2 = Math.max(q2[b3].getLabelSize(), z2);
            }), b2.staggerLines && (z2 *= b2.staggerLines), b2.labelOffset = z2 * (b2.opposite ? -1 : 1)) : p(q2, function(b3, c3) {
              b3.destroy();
              delete q2[c3];
            });
            r2 && r2.text && false !== r2.enabled && (b2.addTitle(ba), ba && false !== r2.reserveSpace && (b2.titleOffset = ea = b2.axisTitle.getBBox()[a3 ? "height" : "width"], u2 = r2.offset, F2 = g(u2) ? 0 : l(r2.margin, a3 ? 5 : 10)));
            b2.renderLine();
            b2.offset = v2 * l(d2.offset, N2[e2] ? N2[e2] + (d2.margin || 0) : 0);
            b2.tickRotCorr = b2.tickRotCorr || { x: 0, y: 0 };
            n2 = 0 === e2 ? -b2.labelMetrics().h : 2 === e2 ? b2.tickRotCorr.y : 0;
            F2 = Math.abs(z2) + F2;
            z2 && (F2 = F2 - n2 + v2 * (a3 ? l(L2.y, b2.tickRotCorr.y + v2 * L2.distance) : l(L2.x, v2 * L2.distance)));
            b2.axisTitleMargin = l(u2, F2);
            b2.getMaxLabelDimensions && (b2.maxLabelDimensions = b2.getMaxLabelDimensions(q2, f2));
            "colorAxis" !== k2 && (L2 = this.tickSize("tick"), N2[e2] = Math.max(N2[e2], (b2.axisTitleMargin || 0) + ea + v2 * b2.offset, F2, f2 && f2.length && L2 ? L2[0] + v2 * b2.offset : 0), N2 = !b2.axisLine || d2.offset ? 0 : 2 * Math.floor(b2.axisLine.strokeWidth() / 2), O2[x2] = Math.max(O2[x2], N2));
            t(this, "afterGetOffset");
          }
          getLinePath(b2) {
            const c2 = this.chart, a3 = this.opposite;
            var d2 = this.offset;
            const e2 = this.horiz, l2 = this.left + (a3 ? this.width : 0) + d2;
            d2 = c2.chartHeight - this.bottom - (a3 ? this.height : 0) + d2;
            a3 && (b2 *= -1);
            return c2.renderer.crispLine([["M", e2 ? this.left : l2, e2 ? d2 : this.top], ["L", e2 ? c2.chartWidth - this.right : l2, e2 ? d2 : c2.chartHeight - this.bottom]], b2);
          }
          renderLine() {
            this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({ stroke: this.options.lineColor, "stroke-width": this.options.lineWidth, zIndex: 7 }));
          }
          getTitlePosition(b2) {
            var c2 = this.horiz, a3 = this.left;
            const d2 = this.top;
            var e2 = this.len;
            const l2 = this.options.title, p2 = c2 ? a3 : d2, q2 = this.opposite, g2 = this.offset, f2 = l2.x, k2 = l2.y, h2 = this.chart.renderer.fontMetrics(b2);
            b2 = b2 ? Math.max(b2.getBBox(false, 0).height - h2.h - 1, 0) : 0;
            e2 = { low: p2 + (c2 ? 0 : e2), middle: p2 + e2 / 2, high: p2 + (c2 ? e2 : 0) }[l2.align];
            a3 = (c2 ? d2 + this.height : a3) + (c2 ? 1 : -1) * (q2 ? -1 : 1) * (this.axisTitleMargin || 0) + [-b2, b2, h2.f, -b2][this.side];
            c2 = { x: c2 ? e2 + f2 : a3 + (q2 ? this.width : 0) + g2 + f2, y: c2 ? a3 + k2 - (q2 ? this.height : 0) + g2 : e2 + k2 };
            t(this, "afterGetTitlePosition", { titlePosition: c2 });
            return c2;
          }
          renderMinorTick(b2, c2) {
            const a3 = this.minorTicks;
            a3[b2] || (a3[b2] = new C(this, b2, "minor"));
            c2 && a3[b2].isNew && a3[b2].render(null, true);
            a3[b2].render(null, false, 1);
          }
          renderTick(b2, c2, a3) {
            const d2 = this.ticks;
            if (!this.isLinked || b2 >= this.min && b2 <= this.max || this.grid && this.grid.isColumn)
              d2[b2] || (d2[b2] = new C(this, b2)), a3 && d2[b2].isNew && d2[b2].render(c2, true, -1), d2[b2].render(c2);
          }
          render() {
            const b2 = this, c2 = b2.chart, a3 = b2.logarithmic, d2 = b2.options, e2 = b2.isLinked, l2 = b2.tickPositions, g2 = b2.axisTitle, f2 = b2.ticks, k2 = b2.minorTicks, h2 = b2.alternateBands, m2 = d2.stackLabels, x2 = d2.alternateGridColor, n2 = b2.tickmarkOffset, r2 = b2.axisLine, L2 = b2.showAxis, N2 = u(c2.renderer.globalAnimation);
            let O2, W;
            b2.labelEdge.length = 0;
            b2.overlap = false;
            [f2, k2, h2].forEach(function(b3) {
              p(b3, function(b4) {
                b4.isActive = false;
              });
            });
            if (b2.hasData() || e2) {
              const e3 = b2.chart.hasRendered && b2.old && q(b2.old.min);
              b2.minorTickInterval && !b2.categories && b2.getMinorTickPositions().forEach(function(c3) {
                b2.renderMinorTick(c3, e3);
              });
              l2.length && (l2.forEach(function(c3, a4) {
                b2.renderTick(c3, a4, e3);
              }), n2 && (0 === b2.min || b2.single) && (f2[-1] || (f2[-1] = new C(b2, -1, null, true)), f2[-1].render(-1)));
              x2 && l2.forEach(function(d3, e4) {
                W = "undefined" !== typeof l2[e4 + 1] ? l2[e4 + 1] + n2 : b2.max - n2;
                0 === e4 % 2 && d3 < b2.max && W <= b2.max + (c2.polar ? -n2 : n2) && (h2[d3] || (h2[d3] = new E.PlotLineOrBand(b2)), O2 = d3 + n2, h2[d3].options = { from: a3 ? a3.lin2log(O2) : O2, to: a3 ? a3.lin2log(W) : W, color: x2, className: "highcharts-alternate-grid" }, h2[d3].render(), h2[d3].isActive = true);
              });
              b2._addedPlotLB || (b2._addedPlotLB = true, (d2.plotLines || []).concat(d2.plotBands || []).forEach(function(c3) {
                b2.addPlotBandOrLine(c3);
              }));
            }
            [
              f2,
              k2,
              h2
            ].forEach(function(b3) {
              const a4 = [], d3 = N2.duration;
              p(b3, function(b4, c3) {
                b4.isActive || (b4.render(c3, false, 0), b4.isActive = false, a4.push(c3));
              });
              Z(function() {
                let c3 = a4.length;
                for (; c3--; )
                  b3[a4[c3]] && !b3[a4[c3]].isActive && (b3[a4[c3]].destroy(), delete b3[a4[c3]]);
              }, b3 !== h2 && c2.hasRendered && d3 ? d3 : 0);
            });
            r2 && (r2[r2.isPlaced ? "animate" : "attr"]({ d: this.getLinePath(r2.strokeWidth()) }), r2.isPlaced = true, r2[L2 ? "show" : "hide"](L2));
            g2 && L2 && (g2[g2.isNew ? "attr" : "animate"](b2.getTitlePosition(g2)), g2.isNew = false);
            m2 && m2.enabled && b2.stacking && b2.stacking.renderStackTotals();
            b2.old = { len: b2.len, max: b2.max, min: b2.min, transA: b2.transA, userMax: b2.userMax, userMin: b2.userMin };
            b2.isDirty = false;
            t(this, "afterRender");
          }
          redraw() {
            this.visible && (this.render(), this.plotLinesAndBands.forEach(function(b2) {
              b2.render();
            }));
            this.series.forEach(function(b2) {
              b2.isDirty = true;
            });
          }
          getKeepProps() {
            return this.keepProps || U.keepProps;
          }
          destroy(b2) {
            const c2 = this, a3 = c2.plotLinesAndBands, d2 = this.eventOptions;
            t(this, "destroy", { keepEvents: b2 });
            b2 || N(c2);
            [c2.ticks, c2.minorTicks, c2.alternateBands].forEach(function(b3) {
              w(b3);
            });
            if (a3)
              for (b2 = a3.length; b2--; )
                a3[b2].destroy();
            "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function(b3) {
              c2[b3] && (c2[b3] = c2[b3].destroy());
            });
            for (const b3 in c2.plotLinesAndBandsGroups)
              c2.plotLinesAndBandsGroups[b3] = c2.plotLinesAndBandsGroups[b3].destroy();
            p(c2, function(b3, a4) {
              -1 === c2.getKeepProps().indexOf(a4) && delete c2[a4];
            });
            this.eventOptions = d2;
          }
          drawCrosshair(b2, c2) {
            const a3 = this.crosshair;
            var d2 = l(a3 && a3.snap, true);
            const p2 = this.chart;
            let q2, f2 = this.cross;
            t(this, "drawCrosshair", { e: b2, point: c2 });
            b2 || (b2 = this.cross && this.cross.e);
            if (a3 && false !== (g(c2) || !d2)) {
              d2 ? g(c2) && (q2 = l("colorAxis" !== this.coll ? c2.crosshairPos : null, this.isXAxis ? c2.plotX : this.len - c2.plotY)) : q2 = b2 && (this.horiz ? b2.chartX - this.pos : this.len - b2.chartY + this.pos);
              if (g(q2)) {
                var k2 = { value: c2 && (this.isXAxis ? c2.x : l(c2.stackY, c2.y)), translatedValue: q2 };
                p2.polar && e(k2, { isCrosshair: true, chartX: b2 && b2.chartX, chartY: b2 && b2.chartY, point: c2 });
                k2 = this.getPlotLinePath(k2) || null;
              }
              if (!g(k2)) {
                this.hideCrosshair();
                return;
              }
              d2 = this.categories && !this.isRadial;
              f2 || (this.cross = f2 = p2.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (d2 ? "category " : "thin ") + (a3.className || "")).attr({ zIndex: l(a3.zIndex, 2) }).add(), p2.styledMode || (f2.attr({ stroke: a3.color || (d2 ? H.parse("#ccd3ff").setOpacity(0.25).get() : "#cccccc"), "stroke-width": l(a3.width, 1) }).css({ "pointer-events": "none" }), a3.dashStyle && f2.attr({ dashstyle: a3.dashStyle })));
              f2.show().attr({ d: k2 });
              d2 && !a3.width && f2.attr({ "stroke-width": this.transA });
              this.cross.e = b2;
            } else
              this.hideCrosshair();
            t(this, "afterDrawCrosshair", { e: b2, point: c2 });
          }
          hideCrosshair() {
            this.cross && this.cross.hide();
            t(this, "afterHideCrosshair");
          }
          hasVerticalPanning() {
            const b2 = this.chart.options.chart.panning;
            return !!(b2 && b2.enabled && /y/.test(b2.type));
          }
          update(b2, a3) {
            const d2 = this.chart;
            b2 = c(this.userOptions, b2);
            this.destroy(true);
            this.init(d2, b2);
            d2.isDirtyBox = true;
            l(a3, true) && d2.redraw();
          }
          remove(b2) {
            const c2 = this.chart, a3 = this.coll, d2 = this.series;
            let e2 = d2.length;
            for (; e2--; )
              d2[e2] && d2[e2].remove(false);
            F(c2.axes, this);
            F(c2[a3], this);
            c2[a3].forEach(function(b3, c3) {
              b3.options.index = b3.userOptions.index = c3;
            });
            this.destroy();
            c2.isDirtyBox = true;
            l(b2, true) && c2.redraw();
          }
          setTitle(b2, c2) {
            this.update({ title: b2 }, c2);
          }
          setCategories(b2, c2) {
            this.update(
              { categories: b2 },
              c2
            );
          }
        }
        U.defaultOptions = y.defaultXAxisOptions;
        U.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
        "";
        return U;
      });
      M(a, "Core/Axis/DateTimeAxis.js", [a["Core/Utilities.js"]], function(a2) {
        const { addEvent: w, getMagnitude: H, normalizeTickInterval: K, timeUnits: B } = a2;
        var E;
        (function(C) {
          function A() {
            return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
          }
          function u(a3) {
            "datetime" !== a3.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new f(this));
          }
          const v = [];
          C.compose = function(f2) {
            a2.pushUnique(
              v,
              f2
            ) && (f2.keepProps.push("dateTime"), f2.prototype.getTimeTicks = A, w(f2, "init", u));
            return f2;
          };
          class f {
            constructor(a3) {
              this.axis = a3;
            }
            normalizeTimeTickInterval(a3, f2) {
              const h = f2 || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
              f2 = h[h.length - 1];
              let n = B[f2[0]], k = f2[1], g;
              for (g = 0; g < h.length && !(f2 = h[g], n = B[f2[0]], k = f2[1], h[g + 1] && a3 <= (n * k[k.length - 1] + B[h[g + 1][0]]) / 2); g++)
                ;
              n === B.year && a3 < 5 * n && (k = [1, 2, 5]);
              a3 = K(a3 / n, k, "year" === f2[0] ? Math.max(H(a3 / n), 1) : 1);
              return { unitRange: n, count: a3, unitName: f2[0] };
            }
            getXDateFormat(a3, f2) {
              const { axis: h } = this, n = h.chart.time;
              return h.closestPointRange ? n.getDateFormat(h.closestPointRange, a3, h.options.startOfWeek, f2) || n.resolveDTLFormat(f2.year).main : n.resolveDTLFormat(f2.day).main;
            }
          }
          C.Additions = f;
        })(E || (E = {}));
        return E;
      });
      M(a, "Core/Axis/LogarithmicAxis.js", [a["Core/Utilities.js"]], function(a2) {
        const { addEvent: w, normalizeTickInterval: H, pick: K } = a2;
        var B;
        (function(y) {
          function C(a3) {
            let f = this.logarithmic;
            "logarithmic" !== a3.userOptions.type ? this.logarithmic = void 0 : f || (this.logarithmic = new v(this));
          }
          function A() {
            const a3 = this.logarithmic;
            a3 && (this.lin2val = function(f) {
              return a3.lin2log(f);
            }, this.val2lin = function(f) {
              return a3.log2lin(f);
            });
          }
          const u = [];
          y.compose = function(f) {
            a2.pushUnique(u, f) && (f.keepProps.push("logarithmic"), w(f, "init", C), w(f, "afterInit", A));
            return f;
          };
          class v {
            constructor(a3) {
              this.axis = a3;
            }
            getLogTickPositions(a3, h, r, m) {
              const f = this.axis;
              var k = f.len, g = f.options;
              let v2 = [];
              m || (this.minorAutoInterval = void 0);
              if (0.5 <= a3)
                a3 = Math.round(a3), v2 = f.getLinearTickPositions(a3, h, r);
              else if (0.08 <= a3) {
                g = Math.floor(h);
                let f2, n, e, t, d;
                for (k = 0.3 < a3 ? [1, 2, 4] : 0.15 < a3 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; g < r + 1 && !d; g++)
                  for (n = k.length, f2 = 0; f2 < n && !d; f2++)
                    e = this.log2lin(this.lin2log(g) * k[f2]), e > h && (!m || t <= r) && "undefined" !== typeof t && v2.push(t), t > r && (d = true), t = e;
              } else
                h = this.lin2log(h), r = this.lin2log(r), a3 = m ? f.getMinorTickInterval() : g.tickInterval, a3 = K("auto" === a3 ? null : a3, this.minorAutoInterval, g.tickPixelInterval / (m ? 5 : 1) * (r - h) / ((m ? k / f.tickPositions.length : k) || 1)), a3 = H(a3), v2 = f.getLinearTickPositions(a3, h, r).map(this.log2lin), m || (this.minorAutoInterval = a3 / 5);
              m || (f.tickInterval = a3);
              return v2;
            }
            lin2log(a3) {
              return Math.pow(10, a3);
            }
            log2lin(a3) {
              return Math.log(a3) / Math.LN10;
            }
          }
          y.Additions = v;
        })(B || (B = {}));
        return B;
      });
      M(a, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [a["Core/Utilities.js"]], function(a2) {
        const { erase: w, extend: H, isNumber: K } = a2;
        var B;
        (function(y) {
          function C(a3) {
            return this.addPlotBandOrLine(a3, "plotBands");
          }
          function A(a3, f2) {
            const g = this.userOptions;
            let k = new n(
              this,
              a3
            );
            this.visible && (k = k.render());
            if (k) {
              this._addedPlotLB || (this._addedPlotLB = true, (g.plotLines || []).concat(g.plotBands || []).forEach((a4) => {
                this.addPlotBandOrLine(a4);
              }));
              if (f2) {
                const k2 = g[f2] || [];
                k2.push(a3);
                g[f2] = k2;
              }
              this.plotLinesAndBands.push(k);
            }
            return k;
          }
          function u(a3) {
            return this.addPlotBandOrLine(a3, "plotLines");
          }
          function v(a3, f2, h2 = this.options) {
            const g = this.getPlotLinePath({ value: f2, force: true, acrossPanes: h2.acrossPanes }), k = [], e = this.horiz;
            f2 = !K(this.min) || !K(this.max) || a3 < this.min && f2 < this.min || a3 > this.max && f2 > this.max;
            a3 = this.getPlotLinePath({ value: a3, force: true, acrossPanes: h2.acrossPanes });
            h2 = 1;
            let t;
            if (a3 && g)
              for (f2 && (t = a3.toString() === g.toString(), h2 = 0), f2 = 0; f2 < a3.length; f2 += 2) {
                const d = a3[f2], q = a3[f2 + 1], x = g[f2], c = g[f2 + 1];
                "M" !== d[0] && "L" !== d[0] || "M" !== q[0] && "L" !== q[0] || "M" !== x[0] && "L" !== x[0] || "M" !== c[0] && "L" !== c[0] || (e && x[1] === d[1] ? (x[1] += h2, c[1] += h2) : e || x[2] !== d[2] || (x[2] += h2, c[2] += h2), k.push(["M", d[1], d[2]], ["L", q[1], q[2]], ["L", c[1], c[2]], ["L", x[1], x[2]], ["Z"]));
                k.isFlat = t;
              }
            return k;
          }
          function f(a3) {
            this.removePlotBandOrLine(a3);
          }
          function h(a3) {
            const f2 = this.plotLinesAndBands, k = this.options, h2 = this.userOptions;
            if (f2) {
              let g = f2.length;
              for (; g--; )
                f2[g].id === a3 && f2[g].destroy();
              [k.plotLines || [], h2.plotLines || [], k.plotBands || [], h2.plotBands || []].forEach(function(e) {
                for (g = e.length; g--; )
                  (e[g] || {}).id === a3 && w(e, e[g]);
              });
            }
          }
          function r(a3) {
            this.removePlotBandOrLine(a3);
          }
          const m = [];
          let n;
          y.compose = function(k, g) {
            n || (n = k);
            a2.pushUnique(m, g) && H(g.prototype, { addPlotBand: C, addPlotLine: u, addPlotBandOrLine: A, getPlotBandPath: v, removePlotBand: f, removePlotLine: r, removePlotBandOrLine: h });
            return g;
          };
        })(B || (B = {}));
        return B;
      });
      M(a, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [a["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], a["Core/Utilities.js"]], function(a2, y) {
        const { arrayMax: w, arrayMin: K, defined: B, destroyObjectProperties: E, erase: C, fireEvent: A, merge: u, objectEach: v, pick: f } = y;
        class h {
          static compose(f2) {
            return a2.compose(h, f2);
          }
          constructor(a3, f2) {
            this.axis = a3;
            f2 && (this.options = f2, this.id = f2.id);
          }
          render() {
            A(this, "render");
            const a3 = this, h2 = a3.axis, n = h2.horiz;
            var k = h2.logarithmic;
            const g = a3.options, w2 = g.color, F = f(g.zIndex, 0), z = g.events, e = {}, t = h2.chart.renderer;
            let d = g.label, q = a3.label, x = g.to, c = g.from, b = g.value, p = a3.svgElem;
            var l = [];
            const L = B(c) && B(x);
            l = B(b);
            const N = !p, O = { "class": "highcharts-plot-" + (L ? "band " : "line ") + (g.className || "") };
            let Z = L ? "bands" : "lines";
            k && (c = k.log2lin(c), x = k.log2lin(x), b = k.log2lin(b));
            h2.chart.styledMode || (l ? (O.stroke = w2 || "#999999", O["stroke-width"] = f(g.width, 1), g.dashStyle && (O.dashstyle = g.dashStyle)) : L && (O.fill = w2 || "#e6e9ff", g.borderWidth && (O.stroke = g.borderColor, O["stroke-width"] = g.borderWidth)));
            e.zIndex = F;
            Z += "-" + F;
            (k = h2.plotLinesAndBandsGroups[Z]) || (h2.plotLinesAndBandsGroups[Z] = k = t.g("plot-" + Z).attr(e).add());
            N && (a3.svgElem = p = t.path().attr(O).add(k));
            if (l)
              l = h2.getPlotLinePath({ value: b, lineWidth: p.strokeWidth(), acrossPanes: g.acrossPanes });
            else if (L)
              l = h2.getPlotBandPath(c, x, g);
            else
              return;
            !a3.eventsAdded && z && (v(z, function(b2, c2) {
              p.on(c2, function(b3) {
                z[c2].apply(a3, [b3]);
              });
            }), a3.eventsAdded = true);
            (N || !p.d) && l && l.length ? p.attr({ d: l }) : p && (l ? (p.show(), p.animate({ d: l })) : p.d && (p.hide(), q && (a3.label = q = q.destroy())));
            d && (B(d.text) || B(d.formatter)) && l && l.length && 0 < h2.width && 0 < h2.height && !l.isFlat ? (d = u({ align: n && L && "center", x: n ? !L && 4 : 10, verticalAlign: !n && L && "middle", y: n ? L ? 16 : 10 : L ? 6 : -4, rotation: n && !L && 90 }, d), this.renderLabel(d, l, L, F)) : q && q.hide();
            return a3;
          }
          renderLabel(a3, f2, h2, k) {
            const g = this.axis;
            var m = g.chart.renderer;
            let n = this.label;
            n || (this.label = n = m.text(this.getLabelText(a3), 0, 0, a3.useHTML).attr({
              align: a3.textAlign || a3.align,
              rotation: a3.rotation,
              "class": "highcharts-plot-" + (h2 ? "band" : "line") + "-label " + (a3.className || ""),
              zIndex: k
            }).add(), g.chart.styledMode || n.css(u({ fontSize: "0.8em", textOverflow: "ellipsis" }, a3.style)));
            k = f2.xBounds || [f2[0][1], f2[1][1], h2 ? f2[2][1] : f2[0][1]];
            f2 = f2.yBounds || [f2[0][2], f2[1][2], h2 ? f2[2][2] : f2[0][2]];
            h2 = K(k);
            m = K(f2);
            n.align(a3, false, { x: h2, y: m, width: w(k) - h2, height: w(f2) - m });
            n.alignValue && "left" !== n.alignValue || (a3 = a3.clip ? g.width : g.chart.chartWidth, n.css({ width: (90 === n.rotation ? g.height - (n.alignAttr.y - g.top) : a3 - (n.alignAttr.x - g.left)) + "px" }));
            n.show(true);
          }
          getLabelText(a3) {
            return B(a3.formatter) ? a3.formatter.call(this) : a3.text;
          }
          destroy() {
            C(this.axis.plotLinesAndBands, this);
            delete this.axis;
            E(this);
          }
        }
        "";
        "";
        return h;
      });
      M(a, "Core/Tooltip.js", [a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Utilities.js"]], function(a2, y, H, K, B) {
        const { format: w } = a2, { doc: C } = y, { distribute: A } = H, { addEvent: u, clamp: v, css: f, discardElement: h, extend: r, fireEvent: m, isArray: n, isNumber: k, isString: g, merge: I, pick: F, splat: z, syncTimeout: e } = B;
        class t {
          constructor(a3, e2) {
            this.allowShared = true;
            this.container = void 0;
            this.crosshairs = [];
            this.distance = 0;
            this.isHidden = true;
            this.isSticky = false;
            this.now = {};
            this.options = {};
            this.outside = false;
            this.chart = a3;
            this.init(a3, e2);
          }
          bodyFormatter(a3) {
            return a3.map(function(a4) {
              const d = a4.series.tooltipOptions;
              return (d[(a4.point.formatPrefix || "point") + "Formatter"] || a4.point.tooltipFormatter).call(a4.point, d[(a4.point.formatPrefix || "point") + "Format"] || "");
            });
          }
          cleanSplit(a3) {
            this.chart.series.forEach(function(d) {
              const e2 = d && d.tt;
              e2 && (!e2.isActive || a3 ? d.tt = e2.destroy() : e2.isActive = false);
            });
          }
          defaultFormatter(a3) {
            const d = this.points || z(this);
            let e2;
            e2 = [a3.tooltipFooterHeaderFormatter(d[0])];
            e2 = e2.concat(a3.bodyFormatter(d));
            e2.push(a3.tooltipFooterHeaderFormatter(d[0], true));
            return e2;
          }
          destroy() {
            this.label && (this.label = this.label.destroy());
            this.split && (this.cleanSplit(true), this.tt && (this.tt = this.tt.destroy()));
            this.renderer && (this.renderer = this.renderer.destroy(), h(this.container));
            B.clearTimeout(this.hideTimer);
            B.clearTimeout(this.tooltipTimeout);
          }
          getAnchor(a3, e2) {
            var d = this.chart;
            const c = d.pointer, b = d.inverted, p = d.plotTop;
            d = d.plotLeft;
            a3 = z(a3);
            a3[0].series && a3[0].series.yAxis && !a3[0].series.yAxis.options.reversedStacks && (a3 = a3.slice().reverse());
            if (this.followPointer && e2)
              "undefined" === typeof e2.chartX && (e2 = c.normalize(e2)), a3 = [e2.chartX - d, e2.chartY - p];
            else if (a3[0].tooltipPos)
              a3 = a3[0].tooltipPos;
            else {
              let c2 = 0, f2 = 0;
              a3.forEach(function(b2) {
                if (b2 = b2.pos(true))
                  c2 += b2[0], f2 += b2[1];
              });
              c2 /= a3.length;
              f2 /= a3.length;
              this.shared && 1 < a3.length && e2 && (b ? c2 = e2.chartX : f2 = e2.chartY);
              a3 = [c2 - d, f2 - p];
            }
            return a3.map(Math.round);
          }
          getClassName(a3, e2, f2) {
            const c = a3.series, b = c.options;
            return [
              this.options.className,
              "highcharts-label",
              f2 && "highcharts-tooltip-header",
              e2 ? "highcharts-tooltip-box" : "highcharts-tooltip",
              !f2 && "highcharts-color-" + F(a3.colorIndex, c.colorIndex),
              b && b.className
            ].filter(g).join(" ");
          }
          getLabel() {
            const a3 = this, e2 = this.chart.styledMode, g2 = this.options, c = this.split && this.allowShared, b = g2.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none");
            let p, l = this.chart.renderer;
            if (this.label) {
              var h2 = !this.label.hasClass("highcharts-label");
              (!c && h2 || c && !h2) && this.destroy();
            }
            if (!this.label) {
              if (this.outside) {
                h2 = this.chart.options.chart.style;
                const c2 = K.getRendererType();
                this.container = p = y.doc.createElement("div");
                p.className = "highcharts-tooltip-container";
                f(p, { position: "absolute", top: "1px", pointerEvents: b, zIndex: Math.max(this.options.style.zIndex || 0, (h2 && h2.zIndex || 0) + 3) });
                y.doc.body.appendChild(p);
                this.renderer = l = new c2(p, 0, 0, h2, void 0, void 0, l.styledMode);
              }
              c ? this.label = l.g("tooltip") : (this.label = l.label("", 0, 0, g2.shape, void 0, void 0, g2.useHTML, void 0, "tooltip").attr({ padding: g2.padding, r: g2.borderRadius }), e2 || this.label.attr({
                fill: g2.backgroundColor,
                "stroke-width": g2.borderWidth || 0
              }).css(g2.style).css({ pointerEvents: b }));
              if (a3.outside) {
                const b2 = this.label, { xSetter: c2, ySetter: d } = b2;
                b2.xSetter = function(d2) {
                  c2.call(b2, a3.distance);
                  p.style.left = d2 + "px";
                };
                b2.ySetter = function(c3) {
                  d.call(b2, a3.distance);
                  p.style.top = c3 + "px";
                };
              }
              this.label.attr({ zIndex: 8 }).shadow(g2.shadow).add();
            }
            return this.label;
          }
          getPlayingField() {
            const { body: a3, documentElement: e2 } = C, { chart: f2, distance: c, outside: b } = this;
            return { width: b ? Math.max(a3.scrollWidth, e2.scrollWidth, a3.offsetWidth, e2.offsetWidth, e2.clientWidth) - 2 * c : f2.chartWidth, height: b ? Math.max(a3.scrollHeight, e2.scrollHeight, a3.offsetHeight, e2.offsetHeight, e2.clientHeight) : f2.chartHeight };
          }
          getPosition(a3, e2, f2) {
            const c = this.chart, b = this.distance, d = {}, l = c.inverted && f2.h || 0, q = this.outside;
            var g2 = this.getPlayingField();
            const h2 = g2.width, t2 = g2.height, k2 = c.pointer.getChartPosition();
            g2 = (d2) => {
              const l2 = "x" === d2;
              return [d2, l2 ? h2 : t2, l2 ? a3 : e2].concat(q ? [l2 ? a3 * k2.scaleX : e2 * k2.scaleY, l2 ? k2.left - b + (f2.plotX + c.plotLeft) * k2.scaleX : k2.top - b + (f2.plotY + c.plotTop) * k2.scaleY, 0, l2 ? h2 : t2] : [l2 ? a3 : e2, l2 ? f2.plotX + c.plotLeft : f2.plotY + c.plotTop, l2 ? c.plotLeft : c.plotTop, l2 ? c.plotLeft + c.plotWidth : c.plotTop + c.plotHeight]);
            };
            let m2 = g2("y"), x = g2("x"), n2;
            g2 = !!f2.negative;
            !c.polar && c.hoverSeries && c.hoverSeries.yAxis && c.hoverSeries.yAxis.reversed && (g2 = !g2);
            const r2 = !this.followPointer && F(f2.ttBelow, !c.inverted === g2), v2 = function(c2, a4, e3, p, f3, g3, h3) {
              const t3 = q ? "y" === c2 ? b * k2.scaleY : b * k2.scaleX : b, m3 = (e3 - p) / 2, D2 = p < f3 - b, x2 = f3 + b + p < a4, n3 = f3 - t3 - e3 + m3;
              f3 = f3 + t3 - m3;
              if (r2 && x2)
                d[c2] = f3;
              else if (!r2 && D2)
                d[c2] = n3;
              else if (D2)
                d[c2] = Math.min(h3 - p, 0 > n3 - l ? n3 : n3 - l);
              else if (x2)
                d[c2] = Math.max(g3, f3 + l + e3 > a4 ? f3 : f3 + l);
              else
                return false;
            }, u2 = function(c2, a4, e3, l2, p) {
              let f3;
              p < b || p > a4 - b ? f3 = false : d[c2] = p < e3 / 2 ? 1 : p > a4 - l2 / 2 ? a4 - l2 - 2 : p - e3 / 2;
              return f3;
            }, D = function(b2) {
              const c2 = m2;
              m2 = x;
              x = c2;
              n2 = b2;
            }, P = function() {
              false !== v2.apply(0, m2) ? false !== u2.apply(0, x) || n2 || (D(true), P()) : n2 ? d.x = d.y = 0 : (D(true), P());
            };
            (c.inverted || 1 < this.len) && D();
            P();
            return d;
          }
          hide(a3) {
            const d = this;
            B.clearTimeout(this.hideTimer);
            a3 = F(a3, this.options.hideDelay);
            this.isHidden || (this.hideTimer = e(function() {
              d.getLabel().fadeOut(a3 ? void 0 : a3);
              d.isHidden = true;
            }, a3));
          }
          init(a3, e2) {
            this.chart = a3;
            this.options = e2;
            this.crosshairs = [];
            this.now = { x: 0, y: 0 };
            this.isHidden = true;
            this.split = e2.split && !a3.inverted && !a3.polar;
            this.shared = e2.shared || this.split;
            this.outside = F(e2.outside, !(!a3.scrollablePixelsX && !a3.scrollablePixelsY));
          }
          shouldStickOnContact(a3) {
            return !(this.followPointer || !this.options.stickOnContact || a3 && !this.chart.pointer.inClass(a3.target, "highcharts-tooltip"));
          }
          move(a3, e2, f2, c) {
            const b = this, d = b.now, l = false !== b.options.animation && !b.isHidden && (1 < Math.abs(a3 - d.x) || 1 < Math.abs(e2 - d.y)), g2 = b.followPointer || 1 < b.len;
            r(d, { x: l ? (2 * d.x + a3) / 3 : a3, y: l ? (d.y + e2) / 2 : e2, anchorX: g2 ? void 0 : l ? (2 * d.anchorX + f2) / 3 : f2, anchorY: g2 ? void 0 : l ? (d.anchorY + c) / 2 : c });
            b.getLabel().attr(d);
            b.drawTracker();
            l && (B.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {
              b && b.move(a3, e2, f2, c);
            }, 32));
          }
          refresh(a3, e2) {
            const d = this.chart, c = this.options, b = d.pointer, p = z(a3), l = p[0], f2 = [];
            var g2 = c.formatter || this.defaultFormatter, q = this.shared;
            const h2 = d.styledMode;
            let t2 = {};
            if (c.enabled && l.series) {
              B.clearTimeout(this.hideTimer);
              this.allowShared = !(!n(a3) && a3.series && a3.series.noSharedTooltip);
              this.followPointer = !this.split && l.series.tooltipOptions.followPointer;
              a3 = this.getAnchor(a3, e2);
              var k2 = a3[0], r2 = a3[1];
              q && this.allowShared ? (b.applyInactiveState(p), p.forEach(function(b2) {
                b2.setState("hover");
                f2.push(b2.getLabelConfig());
              }), t2 = { x: l.category, y: l.y }, t2.points = f2) : t2 = l.getLabelConfig();
              this.len = f2.length;
              g2 = g2.call(t2, this);
              q = l.series;
              this.distance = F(q.tooltipOptions.distance, 16);
              if (false === g2)
                this.hide();
              else {
                if (this.split && this.allowShared)
                  this.renderSplit(g2, p);
                else {
                  let f3 = k2, t3 = r2;
                  e2 && b.isDirectTouch && (f3 = e2.chartX - d.plotLeft, t3 = e2.chartY - d.plotTop);
                  if (d.polar || false === q.options.clip || p.some((c2) => b.isDirectTouch || c2.series.shouldShowTooltip(f3, t3)))
                    e2 = this.getLabel(), c.style.width && !h2 || e2.css({ width: (this.outside ? this.getPlayingField() : d.spacingBox).width + "px" }), e2.attr({ text: g2 && g2.join ? g2.join("") : g2 }), e2.addClass(this.getClassName(l), true), h2 || e2.attr({ stroke: c.borderColor || l.color || q.color || "#666666" }), this.updatePosition({ plotX: k2, plotY: r2, negative: l.negative, ttBelow: l.ttBelow, h: a3[2] || 0 });
                  else {
                    this.hide();
                    return;
                  }
                }
                this.isHidden && this.label && this.label.attr({ opacity: 1 }).show();
                this.isHidden = false;
              }
              m(this, "refresh");
            }
          }
          renderSplit(a3, e2) {
            function d(b2, a4, d2, e3, l2 = true) {
              d2 ? (a4 = R ? 0 : B2, b2 = v(b2 - e3 / 2, P.left, P.right - e3 - (c.outside ? V : 0))) : (a4 -= y2, b2 = l2 ? b2 - e3 - w2 : b2 + w2, b2 = v(b2, l2 ? b2 : P.left, P.right));
              return { x: b2, y: a4 };
            }
            const c = this, { chart: b, chart: { chartWidth: p, chartHeight: l, plotHeight: f2, plotLeft: q, plotTop: h2, pointer: t2, scrollablePixelsY: k2 = 0, scrollablePixelsX: m2, scrollingContainer: { scrollLeft: n2, scrollTop: u2 } = { scrollLeft: 0, scrollTop: 0 }, styledMode: z2 }, distance: w2, options: I2, options: { positioner: D } } = c, P = c.outside && "number" !== typeof m2 ? C.documentElement.getBoundingClientRect() : { left: n2, right: n2 + p, top: u2, bottom: u2 + l }, J = c.getLabel(), X = this.renderer || b.renderer, R = !(!b.xAxis[0] || !b.xAxis[0].opposite), { left: V, top: ha } = t2.getChartPosition();
            let y2 = h2 + u2, ca = 0, B2 = f2 - k2;
            g(a3) && (a3 = [false, a3]);
            a3 = a3.slice(0, e2.length + 1).reduce(function(b2, a4, l2) {
              if (false !== a4 && "" !== a4) {
                l2 = e2[l2 - 1] || { isHeader: true, plotX: e2[0].plotX, plotY: f2, series: {} };
                const n3 = l2.isHeader;
                var p2 = n3 ? c : l2.series, g2;
                {
                  var t3 = l2;
                  a4 = a4.toString();
                  var k3 = p2.tt;
                  const { isHeader: b3, series: d2 } = t3;
                  k3 || (k3 = { padding: I2.padding, r: I2.borderRadius }, z2 || (k3.fill = I2.backgroundColor, k3["stroke-width"] = null !== (g2 = I2.borderWidth) && void 0 !== g2 ? g2 : 1), k3 = X.label("", 0, 0, I2[b3 ? "headerShape" : "shape"], void 0, void 0, I2.useHTML).addClass(c.getClassName(t3, true, b3)).attr(k3).add(J));
                  k3.isActive = true;
                  k3.attr({ text: a4 });
                  z2 || k3.css(I2.style).attr({ stroke: I2.borderColor || t3.color || d2.color || "#333333" });
                  g2 = k3;
                }
                g2 = p2.tt = g2;
                t3 = g2.getBBox();
                p2 = t3.width + g2.strokeWidth();
                n3 && (ca = t3.height, B2 += ca, R && (y2 -= ca));
                {
                  const { isHeader: b3, plotX: c2 = 0, plotY: d2 = 0, series: e3 } = l2;
                  if (b3) {
                    a4 = q + c2;
                    var m3 = h2 + f2 / 2;
                  } else {
                    const { xAxis: b4, yAxis: l3 } = e3;
                    a4 = b4.pos + v(c2, -w2, b4.len + w2);
                    e3.shouldShowTooltip(0, l3.pos - h2 + d2, { ignoreX: true }) && (m3 = l3.pos + d2);
                  }
                  a4 = v(a4, P.left - w2, P.right + w2);
                  m3 = { anchorX: a4, anchorY: m3 };
                }
                const { anchorX: x, anchorY: r2 } = m3;
                "number" === typeof r2 ? (m3 = t3.height + 1, t3 = D ? D.call(c, p2, m3, l2) : d(x, r2, n3, p2), b2.push({ align: D ? 0 : void 0, anchorX: x, anchorY: r2, boxWidth: p2, point: l2, rank: F(t3.rank, n3 ? 1 : 0), size: m3, target: t3.y, tt: g2, x: t3.x })) : g2.isActive = false;
              }
              return b2;
            }, []);
            !D && a3.some((b2) => {
              var { outside: a4 } = c;
              a4 = (a4 ? V : 0) + b2.anchorX;
              return a4 < P.left && a4 + b2.boxWidth < P.right ? true : a4 < V - P.left + b2.boxWidth && P.right - a4 > a4;
            }) && (a3 = a3.map((b2) => {
              const { x: c2, y: a4 } = d(b2.anchorX, b2.anchorY, b2.point.isHeader, b2.boxWidth, false);
              return r(b2, { target: a4, x: c2 });
            }));
            c.cleanSplit();
            A(a3, B2);
            var E = V, H2 = V;
            a3.forEach(function(b2) {
              const { x: a4, boxWidth: d2, isHeader: e3 } = b2;
              e3 || (c.outside && V + a4 < E && (E = V + a4), !e3 && c.outside && E + d2 > H2 && (H2 = V + a4));
            });
            a3.forEach(function(b2) {
              const { x: a4, anchorX: d2, anchorY: e3, pos: l2, point: { isHeader: p2 } } = b2, f3 = { visibility: "undefined" === typeof l2 ? "hidden" : "inherit", x: a4, y: (l2 || 0) + y2, anchorX: d2, anchorY: e3 };
              if (c.outside && a4 < d2) {
                const b3 = V - E;
                0 < b3 && (p2 || (f3.x = a4 + b3, f3.anchorX = d2 + b3), p2 && (f3.x = (H2 - E) / 2, f3.anchorX = d2 + b3));
              }
              b2.tt.attr(f3);
            });
            const { container: W, outside: ba, renderer: ea } = c;
            if (ba && W && ea) {
              const { width: b2, height: c2, x: a4, y: d2 } = J.getBBox();
              ea.setSize(b2 + a4, c2 + d2, false);
              W.style.left = E + "px";
              W.style.top = ha + "px";
            }
          }
          drawTracker() {
            if (this.shouldStickOnContact()) {
              var a3 = this.chart, e2 = this.label, f2 = this.shared ? a3.hoverPoints : a3.hoverPoint;
              if (e2 && f2) {
                var c = { x: 0, y: 0, width: 0, height: 0 };
                f2 = this.getAnchor(f2);
                var b = e2.getBBox();
                f2[0] += a3.plotLeft - e2.translateX;
                f2[1] += a3.plotTop - e2.translateY;
                c.x = Math.min(0, f2[0]);
                c.y = Math.min(0, f2[1]);
                c.width = 0 > f2[0] ? Math.max(Math.abs(f2[0]), b.width - f2[0]) : Math.max(Math.abs(f2[0]), b.width);
                c.height = 0 > f2[1] ? Math.max(Math.abs(f2[1]), b.height - Math.abs(f2[1])) : Math.max(Math.abs(f2[1]), b.height);
                this.tracker ? this.tracker.attr(c) : (this.tracker = e2.renderer.rect(c).addClass("highcharts-tracker").add(e2), a3.styledMode || this.tracker.attr({ fill: "rgba(0,0,0,0)" }));
              }
            } else
              this.tracker && (this.tracker = this.tracker.destroy());
          }
          styledModeFormat(a3) {
            return a3.replace(
              'style="font-size: 0.8em"',
              'class="highcharts-header"'
            ).replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"');
          }
          tooltipFooterHeaderFormatter(a3, e2) {
            const d = a3.series, c = d.tooltipOptions;
            var b = d.xAxis;
            const p = b && b.dateTime;
            b = { isFooter: e2, labelConfig: a3 };
            let l = c.xDateFormat, f2 = c[e2 ? "footerFormat" : "headerFormat"];
            m(this, "headerFormatter", b, function(b2) {
              p && !l && k(a3.key) && (l = p.getXDateFormat(a3.key, c.dateTimeLabelFormats));
              p && l && (a3.point && a3.point.tooltipDateKeys || ["key"]).forEach(function(b3) {
                f2 = f2.replace("{point." + b3 + "}", "{point." + b3 + ":" + l + "}");
              });
              d.chart.styledMode && (f2 = this.styledModeFormat(f2));
              b2.text = w(f2, { point: a3, series: d }, this.chart);
            });
            return b.text;
          }
          update(a3) {
            this.destroy();
            I(true, this.chart.options.tooltip.userOptions, a3);
            this.init(this.chart, I(true, this.options, a3));
          }
          updatePosition(a3) {
            const { chart: d, distance: e2, options: c } = this;
            var b = d.pointer;
            const p = this.getLabel(), { left: l, top: g2, scaleX: t2, scaleY: h2 } = b.getChartPosition();
            b = (c.positioner || this.getPosition).call(
              this,
              p.width,
              p.height,
              a3
            );
            let k2 = (a3.plotX || 0) + d.plotLeft;
            a3 = (a3.plotY || 0) + d.plotTop;
            let m2;
            if (this.outside) {
              c.positioner && (b.x += l - e2, b.y += g2 - e2);
              m2 = (c.borderWidth || 0) + 2 * e2;
              this.renderer.setSize(p.width + m2, p.height + m2, false);
              if (1 !== t2 || 1 !== h2)
                f(this.container, { transform: `scale(${t2}, ${h2})` }), k2 *= t2, a3 *= h2;
              k2 += l - b.x;
              a3 += g2 - b.y;
            }
            this.move(Math.round(b.x), Math.round(b.y || 0), k2, a3);
          }
        }
        (function(a3) {
          const d = [];
          a3.compose = function(e2) {
            B.pushUnique(d, e2) && u(e2, "afterInit", function() {
              const c = this.chart;
              c.options.tooltip && (c.tooltip = new a3(c, c.options.tooltip));
            });
          };
        })(t || (t = {}));
        "";
        return t;
      });
      M(a, "Core/Series/Point.js", [a["Core/Renderer/HTML/AST.js"], a["Core/Animation/AnimationUtilities.js"], a["Core/Defaults.js"], a["Core/FormatUtilities.js"], a["Core/Utilities.js"]], function(a2, y, H, K, B) {
        const { animObject: w } = y, { defaultOptions: C } = H, { format: A } = K, { addEvent: u, defined: v, erase: f, extend: h, fireEvent: r, getNestedProperty: m, isArray: n, isFunction: k, isNumber: g, isObject: I, merge: F, objectEach: z, pick: e, syncTimeout: t, removeEvent: d, uniqueKey: q } = B;
        class x {
          constructor() {
            this.category = void 0;
            this.destroyed = false;
            this.formatPrefix = "point";
            this.id = void 0;
            this.isNull = false;
            this.percentage = this.options = this.name = void 0;
            this.selected = false;
            this.total = this.shapeArgs = this.series = void 0;
            this.visible = true;
            this.x = void 0;
          }
          animateBeforeDestroy() {
            const a3 = this, b = { x: a3.startXPos, opacity: 0 }, d2 = a3.getGraphicalProps();
            d2.singular.forEach(function(c) {
              a3[c] = a3[c].animate("dataLabel" === c ? { x: a3[c].startXPos, y: a3[c].startYPos, opacity: 0 } : b);
            });
            d2.plural.forEach(function(b2) {
              a3[b2].forEach(function(b3) {
                b3.element && b3.animate(h(
                  { x: a3.startXPos },
                  b3.startYPos ? { x: b3.startXPos, y: b3.startYPos } : {}
                ));
              });
            });
          }
          applyOptions(a3, b) {
            const c = this.series, d2 = c.options.pointValKey || c.pointValKey;
            a3 = x.prototype.optionsToObject.call(this, a3);
            h(this, a3);
            this.options = this.options ? h(this.options, a3) : a3;
            a3.group && delete this.group;
            a3.dataLabels && delete this.dataLabels;
            d2 && (this.y = x.prototype.getNestedProperty.call(this, d2));
            this.formatPrefix = (this.isNull = this.isValid && !this.isValid()) ? "null" : "point";
            this.selected && (this.state = "select");
            "name" in this && "undefined" === typeof b && c.xAxis && c.xAxis.hasNames && (this.x = c.xAxis.nameToX(this));
            "undefined" === typeof this.x && c ? this.x = "undefined" === typeof b ? c.autoIncrement() : b : g(a3.x) && c.options.relativeXValue && (this.x = c.autoIncrement(a3.x));
            return this;
          }
          destroy() {
            if (!this.destroyed) {
              const b = this;
              var a3 = b.series;
              const c = a3.chart;
              a3 = a3.options.dataSorting;
              const e2 = c.hoverPoints, g2 = w(b.series.chart.renderer.globalAnimation), q2 = () => {
                if (b.graphic || b.graphics || b.dataLabel || b.dataLabels)
                  d(b), b.destroyElements();
                for (const a4 in b)
                  delete b[a4];
              };
              b.legendItem && c.legend.destroyItem(b);
              e2 && (b.setState(), f(e2, b), e2.length || (c.hoverPoints = null));
              if (b === c.hoverPoint)
                b.onMouseOut();
              a3 && a3.enabled ? (this.animateBeforeDestroy(), t(q2, g2.duration)) : q2();
              c.pointCount--;
            }
            this.destroyed = true;
          }
          destroyElements(a3) {
            const b = this;
            a3 = b.getGraphicalProps(a3);
            a3.singular.forEach(function(a4) {
              b[a4] = b[a4].destroy();
            });
            a3.plural.forEach(function(a4) {
              b[a4].forEach(function(b2) {
                b2 && b2.element && b2.destroy();
              });
              delete b[a4];
            });
          }
          firePointEvent(a3, b, d2) {
            const c = this, e2 = this.series.options;
            (e2.point.events[a3] || c.options && c.options.events && c.options.events[a3]) && c.importEvents();
            "click" === a3 && e2.allowPointSelect && (d2 = function(b2) {
              c.select && c.select(null, b2.ctrlKey || b2.metaKey || b2.shiftKey);
            });
            r(c, a3, b, d2);
          }
          getClassName() {
            return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace(
              "highcharts-negative",
              ""
            ) : "");
          }
          getGraphicalProps(a3) {
            const b = this, c = [], d2 = { singular: [], plural: [] };
            let e2, f2;
            a3 = a3 || { graphic: 1, dataLabel: 1 };
            a3.graphic && c.push("graphic");
            a3.dataLabel && c.push("dataLabel", "dataLabelPath", "dataLabelUpper", "connector");
            for (f2 = c.length; f2--; )
              e2 = c[f2], b[e2] && d2.singular.push(e2);
            ["graphic", "dataLabel", "connector"].forEach(function(c2) {
              const e3 = c2 + "s";
              a3[c2] && b[e3] && d2.plural.push(e3);
            });
            return d2;
          }
          getLabelConfig() {
            return {
              x: this.category,
              y: this.y,
              color: this.color,
              colorIndex: this.colorIndex,
              key: this.name || this.category,
              series: this.series,
              point: this,
              percentage: this.percentage,
              total: this.total || this.stackTotal
            };
          }
          getNestedProperty(a3) {
            if (a3)
              return 0 === a3.indexOf("custom.") ? m(a3, this.options) : this[a3];
          }
          getZone() {
            var a3 = this.series;
            const b = a3.zones;
            a3 = a3.zoneAxis || "y";
            let d2, e2 = 0;
            for (d2 = b[e2]; this[a3] >= d2.value; )
              d2 = b[++e2];
            this.nonZonedColor || (this.nonZonedColor = this.color);
            this.color = d2 && d2.color && !this.options.color ? d2.color : this.nonZonedColor;
            return d2;
          }
          hasNewShapeType() {
            return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
          }
          init(a3, b, d2) {
            this.series = a3;
            this.applyOptions(b, d2);
            this.id = v(this.id) ? this.id : q();
            this.resolveColor();
            a3.chart.pointCount++;
            r(this, "afterInit");
            return this;
          }
          isValid() {
            return null !== this.x && g(this.y);
          }
          optionsToObject(a3) {
            var b = this.series;
            const c = b.options.keys, d2 = c || b.pointArrayMap || ["y"], e2 = d2.length;
            let f2 = {}, q2 = 0, t2 = 0;
            if (g(a3) || null === a3)
              f2[d2[0]] = a3;
            else if (n(a3))
              for (!c && a3.length > e2 && (b = typeof a3[0], "string" === b ? f2.name = a3[0] : "number" === b && (f2.x = a3[0]), q2++); t2 < e2; )
                c && "undefined" === typeof a3[q2] || (0 < d2[t2].indexOf(".") ? x.prototype.setNestedProperty(f2, a3[q2], d2[t2]) : f2[d2[t2]] = a3[q2]), q2++, t2++;
            else
              "object" === typeof a3 && (f2 = a3, a3.dataLabels && (b._hasPointLabels = true), a3.marker && (b._hasPointMarkers = true));
            return f2;
          }
          pos(a3, b = this.plotY) {
            if (!this.destroyed) {
              const { plotX: c, series: d2 } = this, { chart: e2, xAxis: f2, yAxis: q2 } = d2;
              let t2 = 0, h2 = 0;
              if (g(c) && g(b))
                return a3 && (t2 = f2 ? f2.pos : e2.plotLeft, h2 = q2 ? q2.pos : e2.plotTop), e2.inverted && f2 && q2 ? [q2.len - b + h2, f2.len - c + t2] : [c + t2, b + h2];
            }
          }
          resolveColor() {
            const a3 = this.series;
            var b = a3.chart.styledMode;
            let d2;
            var l = a3.chart.options.chart.colorCount;
            delete this.nonZonedColor;
            a3.options.colorByPoint ? (b || (l = a3.options.colors || a3.chart.options.colors, d2 = l[a3.colorCounter], l = l.length), b = a3.colorCounter, a3.colorCounter++, a3.colorCounter === l && (a3.colorCounter = 0)) : (b || (d2 = a3.color), b = a3.colorIndex);
            this.colorIndex = e(this.options.colorIndex, b);
            this.color = e(this.options.color, d2);
          }
          setNestedProperty(a3, b, d2) {
            d2.split(".").reduce(function(a4, c, d3, e2) {
              a4[c] = e2.length - 1 === d3 ? b : I(a4[c], true) ? a4[c] : {};
              return a4[c];
            }, a3);
            return a3;
          }
          shouldDraw() {
            return !this.isNull;
          }
          tooltipFormatter(a3) {
            const b = this.series, c = b.tooltipOptions, d2 = e(c.valueDecimals, ""), f2 = c.valuePrefix || "", g2 = c.valueSuffix || "";
            b.chart.styledMode && (a3 = b.chart.tooltip.styledModeFormat(a3));
            (b.pointArrayMap || ["y"]).forEach(function(b2) {
              b2 = "{point." + b2;
              if (f2 || g2)
                a3 = a3.replace(RegExp(b2 + "}", "g"), f2 + b2 + "}" + g2);
              a3 = a3.replace(RegExp(b2 + "}", "g"), b2 + ":,." + d2 + "f}");
            });
            return A(a3, { point: this, series: this.series }, b.chart);
          }
          update(a3, b, d2, l) {
            function c() {
              f2.applyOptions(a3);
              var c2 = g2 && f2.hasMockGraphic;
              c2 = null === f2.y ? !c2 : c2;
              g2 && c2 && (f2.graphic = g2.destroy(), delete f2.hasMockGraphic);
              I(a3, true) && (g2 && g2.element && a3 && a3.marker && "undefined" !== typeof a3.marker.symbol && (f2.graphic = g2.destroy()), a3 && a3.dataLabels && f2.dataLabel && (f2.dataLabel = f2.dataLabel.destroy()), f2.connector && (f2.connector = f2.connector.destroy()));
              h2 = f2.index;
              p.updateParallelArrays(f2, h2);
              t2.data[h2] = I(t2.data[h2], true) || I(a3, true) ? f2.options : e(a3, t2.data[h2]);
              p.isDirty = p.isDirtyData = true;
              !p.fixedBox && p.hasCartesianSeries && (q2.isDirtyBox = true);
              "point" === t2.legendType && (q2.isDirtyLegend = true);
              b && q2.redraw(d2);
            }
            const f2 = this, p = f2.series, g2 = f2.graphic, q2 = p.chart, t2 = p.options;
            let h2;
            b = e(b, true);
            false === l ? c() : f2.firePointEvent("update", { options: a3 }, c);
          }
          remove(a3, b) {
            this.series.removePoint(this.series.data.indexOf(this), a3, b);
          }
          select(a3, b) {
            const c = this, d2 = c.series, f2 = d2.chart;
            this.selectedStaging = a3 = e(a3, !c.selected);
            c.firePointEvent(a3 ? "select" : "unselect", { accumulate: b }, function() {
              c.selected = c.options.selected = a3;
              d2.options.data[d2.data.indexOf(c)] = c.options;
              c.setState(a3 && "select");
              b || f2.getSelectedPoints().forEach(function(b2) {
                const a4 = b2.series;
                b2.selected && b2 !== c && (b2.selected = b2.options.selected = false, a4.options.data[a4.data.indexOf(b2)] = b2.options, b2.setState(f2.hoverPoints && a4.options.inactiveOtherPoints ? "inactive" : ""), b2.firePointEvent("unselect"));
              });
            });
            delete this.selectedStaging;
          }
          onMouseOver(a3) {
            const b = this.series.chart, c = b.pointer;
            a3 = a3 ? c.normalize(a3) : c.getChartCoordinatesFromPoint(this, b.inverted);
            c.runPointActions(a3, this);
          }
          onMouseOut() {
            const a3 = this.series.chart;
            this.firePointEvent("mouseOut");
            this.series.options.inactiveOtherPoints || (a3.hoverPoints || []).forEach(function(b) {
              b.setState();
            });
            a3.hoverPoints = a3.hoverPoint = null;
          }
          importEvents() {
            if (!this.hasImportedEvents) {
              const a3 = this, b = F(a3.series.options.point, a3.options).events;
              a3.events = b;
              z(b, function(b2, c) {
                k(b2) && u(a3, c, b2);
              });
              this.hasImportedEvents = true;
            }
          }
          setState(c, b) {
            const d2 = this.series;
            var l = this.state, f2 = d2.options.states[c || "normal"] || {}, q2 = C.plotOptions[d2.type].marker && d2.options.marker;
            const t2 = q2 && false === q2.enabled, k2 = q2 && q2.states && q2.states[c || "normal"] || {}, m2 = false === k2.enabled, n2 = this.marker || {}, x2 = d2.chart, v2 = q2 && d2.markerAttribs;
            let u2 = d2.halo;
            var z2;
            let w2;
            var D = d2.stateMarkerGraphic;
            c = c || "";
            if (!(c === this.state && !b || this.selected && "select" !== c || false === f2.enabled || c && (m2 || t2 && false === k2.enabled) || c && n2.states && n2.states[c] && false === n2.states[c].enabled)) {
              this.state = c;
              v2 && (z2 = d2.markerAttribs(this, c));
              if (this.graphic && !this.hasMockGraphic) {
                l && this.graphic.removeClass("highcharts-point-" + l);
                c && this.graphic.addClass("highcharts-point-" + c);
                if (!x2.styledMode) {
                  l = d2.pointAttribs(this, c);
                  w2 = e(x2.options.chart.animation, f2.animation);
                  const b2 = l.opacity;
                  d2.options.inactiveOtherPoints && g(b2) && ((this.dataLabels || []).forEach(function(a3) {
                    a3 && !a3.hasClass("highcharts-data-label-hidden") && a3.animate({ opacity: b2 }, w2);
                  }), this.connector && this.connector.animate({ opacity: b2 }, w2));
                  this.graphic.animate(l, w2);
                }
                z2 && this.graphic.animate(z2, e(x2.options.chart.animation, k2.animation, q2.animation));
                D && D.hide();
              } else {
                if (c && k2) {
                  q2 = n2.symbol || d2.symbol;
                  D && D.currentSymbol !== q2 && (D = D.destroy());
                  if (z2)
                    if (D)
                      D[b ? "animate" : "attr"]({ x: z2.x, y: z2.y });
                    else
                      q2 && (d2.stateMarkerGraphic = D = x2.renderer.symbol(q2, z2.x, z2.y, z2.width, z2.height).add(d2.markerGroup), D.currentSymbol = q2);
                  !x2.styledMode && D && "inactive" !== this.state && D.attr(d2.pointAttribs(this, c));
                }
                D && (D[c && this.isInside ? "show" : "hide"](), D.element.point = this, D.addClass(this.getClassName(), true));
              }
              f2 = f2.halo;
              z2 = (D = this.graphic || D) && D.visibility || "inherit";
              f2 && f2.size && D && "hidden" !== z2 && !this.isCluster ? (u2 || (d2.halo = u2 = x2.renderer.path().add(D.parentGroup)), u2.show()[b ? "animate" : "attr"]({ d: this.haloPath(f2.size) }), u2.attr({ "class": "highcharts-halo highcharts-color-" + e(this.colorIndex, d2.colorIndex) + (this.className ? " " + this.className : ""), visibility: z2, zIndex: -1 }), u2.point = this, x2.styledMode || u2.attr(h({ fill: this.color || d2.color, "fill-opacity": f2.opacity }, a2.filterUserAttributes(f2.attributes || {})))) : u2 && u2.point && u2.point.haloPath && u2.animate({ d: u2.point.haloPath(0) }, null, u2.hide);
              r(this, "afterSetState", { state: c });
            }
          }
          haloPath(a3) {
            const b = this.pos();
            return b ? this.series.chart.renderer.symbols.circle(Math.floor(b[0]) - a3, b[1] - a3, 2 * a3, 2 * a3) : [];
          }
        }
        "";
        return x;
      });
      M(a, "Core/Pointer.js", [a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, y, H) {
        const { parse: w } = a2, { charts: B, noop: E } = y, { addEvent: C, attr: A, css: u, defined: v, extend: f, find: h, fireEvent: r, isNumber: m, isObject: n, objectEach: k, offset: g, pick: I, splat: F } = H;
        class z {
          constructor(a3, f2) {
            this.lastValidTouch = {};
            this.pinchDown = [];
            this.runChartClick = false;
            this.eventsToUnbind = [];
            this.chart = a3;
            this.hasDragged = false;
            this.options = f2;
            this.init(a3, f2);
          }
          applyInactiveState(a3) {
            let e = [], d;
            (a3 || []).forEach(function(a4) {
              d = a4.series;
              e.push(d);
              d.linkedParent && e.push(d.linkedParent);
              d.linkedSeries && (e = e.concat(d.linkedSeries));
              d.navigatorSeries && e.push(d.navigatorSeries);
            });
            this.chart.series.forEach(function(a4) {
              -1 === e.indexOf(a4) ? a4.setState("inactive", true) : a4.options.inactiveOtherPoints && a4.setAllPointsToState("inactive");
            });
          }
          destroy() {
            const a3 = this;
            this.eventsToUnbind.forEach((a4) => a4());
            this.eventsToUnbind = [];
            y.chartCount || (z.unbindDocumentMouseUp && (z.unbindDocumentMouseUp = z.unbindDocumentMouseUp()), z.unbindDocumentTouchEnd && (z.unbindDocumentTouchEnd = z.unbindDocumentTouchEnd()));
            clearInterval(a3.tooltipTimeout);
            k(a3, function(e, d) {
              a3[d] = void 0;
            });
          }
          getSelectionMarkerAttrs(a3, f2) {
            const d = { args: { chartX: a3, chartY: f2 }, attrs: {}, shapeType: "rect" };
            r(this, "getSelectionMarkerAttrs", d, (d2) => {
              const { chart: e, mouseDownX: c = 0, mouseDownY: b = 0, zoomHor: p, zoomVert: l } = this;
              d2 = d2.attrs;
              let g2;
              d2.x = e.plotLeft;
              d2.y = e.plotTop;
              d2.width = p ? 1 : e.plotWidth;
              d2.height = l ? 1 : e.plotHeight;
              p && (g2 = a3 - c, d2.width = Math.abs(g2), d2.x = (0 < g2 ? 0 : g2) + c);
              l && (g2 = f2 - b, d2.height = Math.abs(g2), d2.y = (0 < g2 ? 0 : g2) + b);
            });
            return d;
          }
          drag(a3) {
            const e = this.chart, d = e.options.chart;
            var f2 = e.plotLeft;
            const g2 = e.plotTop, c = e.plotWidth, b = e.plotHeight, p = this.mouseDownX || 0, l = this.mouseDownY || 0, h2 = n(d.panning) ? d.panning && d.panning.enabled : d.panning, k2 = d.panKey && a3[d.panKey + "Key"];
            let m2 = a3.chartX, r2 = a3.chartY, v2 = this.selectionMarker;
            if (!v2 || !v2.touch) {
              if (m2 < f2 ? m2 = f2 : m2 > f2 + c && (m2 = f2 + c), r2 < g2 ? r2 = g2 : r2 > g2 + b && (r2 = g2 + b), this.hasDragged = Math.sqrt(Math.pow(p - m2, 2) + Math.pow(l - r2, 2)), 10 < this.hasDragged) {
                f2 = e.isInsidePlot(p - f2, l - g2, { visiblePlotOnly: true });
                const { shapeType: b2, attrs: c2 } = this.getSelectionMarkerAttrs(m2, r2);
                !e.hasCartesianSeries && !e.mapView || !this.zoomX && !this.zoomY || !f2 || k2 || v2 || (this.selectionMarker = v2 = e.renderer[b2](), v2.attr({ "class": "highcharts-selection-marker", zIndex: 7 }).add(), e.styledMode || v2.attr({ fill: d.selectionMarkerFill || w("#334eff").setOpacity(0.25).get() }));
                v2 && v2.attr(c2);
                f2 && !v2 && h2 && e.pan(a3, d.panning);
              }
            }
          }
          dragStart(a3) {
            const e = this.chart;
            e.mouseIsDown = a3.type;
            e.cancelClick = false;
            e.mouseDownX = this.mouseDownX = a3.chartX;
            e.mouseDownY = this.mouseDownY = a3.chartY;
          }
          getSelectionBox(a3) {
            const e = { args: { marker: a3 }, result: {} };
            r(this, "getSelectionBox", e, (d) => {
              d.result = { x: a3.attr ? +a3.attr("x") : a3.x, y: a3.attr ? +a3.attr("y") : a3.y, width: a3.attr ? a3.attr("width") : a3.width, height: a3.attr ? a3.attr("height") : a3.height };
            });
            return e.result;
          }
          drop(a3) {
            const e = this, d = this.chart, g2 = this.hasPinched;
            if (this.selectionMarker) {
              const { x: q, y: c, width: b, height: p } = this.getSelectionBox(this.selectionMarker), l = { originalEvent: a3, xAxis: [], yAxis: [], x: q, y: c, width: b, height: p };
              let h2 = !!d.mapView;
              if (this.hasDragged || g2)
                d.axes.forEach(function(d2) {
                  if (d2.zoomEnabled && v(d2.min) && (g2 || e[{ xAxis: "zoomX", yAxis: "zoomY" }[d2.coll]]) && m(q) && m(c) && m(b) && m(p)) {
                    var f2 = d2.horiz;
                    const e2 = "touchend" === a3.type ? d2.minPixelPadding : 0, g3 = d2.toValue((f2 ? q : c) + e2);
                    f2 = d2.toValue((f2 ? q + b : c + p) - e2);
                    l[d2.coll].push({ axis: d2, min: Math.min(g3, f2), max: Math.max(g3, f2) });
                    h2 = true;
                  }
                }), h2 && r(d, "selection", l, function(b2) {
                  d.zoom(f(b2, g2 ? { animation: false } : null));
                });
              m(d.index) && (this.selectionMarker = this.selectionMarker.destroy());
              g2 && this.scaleGroups();
            }
            d && m(d.index) && (u(d.container, { cursor: d._cursor }), d.cancelClick = 10 < this.hasDragged, d.mouseIsDown = this.hasDragged = this.hasPinched = false, this.pinchDown = []);
          }
          findNearestKDPoint(a3, f2, d) {
            let e;
            a3.forEach(function(a4) {
              var c = !(a4.noSharedTooltip && f2) && 0 > a4.options.findNearestPointBy.indexOf("y");
              a4 = a4.searchPoint(d, c);
              if ((c = n(a4, true) && a4.series) && !(c = !n(e, true))) {
                {
                  c = e.distX - a4.distX;
                  const b = e.dist - a4.dist, d2 = (a4.series.group && a4.series.group.zIndex) - (e.series.group && e.series.group.zIndex);
                  c = 0 !== c && f2 ? c : 0 !== b ? b : 0 !== d2 ? d2 : e.series.index > a4.series.index ? -1 : 1;
                }
                c = 0 < c;
              }
              c && (e = a4);
            });
            return e;
          }
          getChartCoordinatesFromPoint(a3, f2) {
            var d = a3.series;
            const e = d.xAxis;
            d = d.yAxis;
            const g2 = a3.shapeArgs;
            if (e && d) {
              let c = I(a3.clientX, a3.plotX), b = a3.plotY || 0;
              a3.isNode && g2 && m(g2.x) && m(g2.y) && (c = g2.x, b = g2.y);
              return f2 ? { chartX: d.len + d.pos - b, chartY: e.len + e.pos - c } : { chartX: c + e.pos, chartY: b + d.pos };
            }
            if (g2 && g2.x && g2.y)
              return { chartX: g2.x, chartY: g2.y };
          }
          getChartPosition() {
            if (this.chartPosition)
              return this.chartPosition;
            var { container: a3 } = this.chart;
            const f2 = g(a3);
            this.chartPosition = { left: f2.left, top: f2.top, scaleX: 1, scaleY: 1 };
            const d = a3.offsetWidth;
            a3 = a3.offsetHeight;
            2 < d && 2 < a3 && (this.chartPosition.scaleX = f2.width / d, this.chartPosition.scaleY = f2.height / a3);
            return this.chartPosition;
          }
          getCoordinates(a3) {
            const e = { xAxis: [], yAxis: [] };
            this.chart.axes.forEach(function(d) {
              e[d.isXAxis ? "xAxis" : "yAxis"].push({ axis: d, value: d.toValue(a3[d.horiz ? "chartX" : "chartY"]) });
            });
            return e;
          }
          getHoverData(a3, f2, d, g2, k2, c) {
            const b = [];
            g2 = !(!g2 || !a3);
            const e = function(b2) {
              return b2.visible && !(!k2 && b2.directTouch) && I(b2.options.enableMouseTracking, true);
            };
            let l, q = { chartX: c ? c.chartX : void 0, chartY: c ? c.chartY : void 0, shared: k2 };
            r(this, "beforeGetHoverData", q);
            l = f2 && !f2.stickyTracking ? [f2] : d.filter((b2) => b2.stickyTracking && (q.filter || e)(b2));
            const t = g2 || !c ? a3 : this.findNearestKDPoint(
              l,
              k2,
              c
            );
            f2 = t && t.series;
            t && (k2 && !f2.noSharedTooltip ? (l = d.filter(function(b2) {
              return q.filter ? q.filter(b2) : e(b2) && !b2.noSharedTooltip;
            }), l.forEach(function(a4) {
              let c2 = h(a4.points, function(b2) {
                return b2.x === t.x && !b2.isNull;
              });
              n(c2) && (a4.boosted && a4.boost && (c2 = a4.boost.getPoint(c2)), b.push(c2));
            })) : b.push(t));
            q = { hoverPoint: t };
            r(this, "afterGetHoverData", q);
            return { hoverPoint: q.hoverPoint, hoverSeries: f2, hoverPoints: b };
          }
          getPointFromEvent(a3) {
            a3 = a3.target;
            let e;
            for (; a3 && !e; )
              e = a3.point, a3 = a3.parentNode;
            return e;
          }
          onTrackerMouseOut(a3) {
            a3 = a3.relatedTarget;
            const e = this.chart.hoverSeries;
            this.isDirectTouch = false;
            if (!(!e || !a3 || e.stickyTracking || this.inClass(a3, "highcharts-tooltip") || this.inClass(a3, "highcharts-series-" + e.index) && this.inClass(a3, "highcharts-tracker")))
              e.onMouseOut();
          }
          inClass(a3, f2) {
            let d;
            for (; a3; ) {
              if (d = A(a3, "class")) {
                if (-1 !== d.indexOf(f2))
                  return true;
                if (-1 !== d.indexOf("highcharts-container"))
                  return false;
              }
              a3 = a3.parentElement;
            }
          }
          init(a3, f2) {
            this.options = f2;
            this.chart = a3;
            this.runChartClick = !(!f2.chart.events || !f2.chart.events.click);
            this.pinchDown = [];
            this.lastValidTouch = {};
            this.setDOMEvents();
            r(this, "afterInit");
          }
          normalize(a3, g2) {
            var d = a3.touches, e = d ? d.length ? d.item(0) : I(d.changedTouches, a3.changedTouches)[0] : a3;
            g2 || (g2 = this.getChartPosition());
            d = e.pageX - g2.left;
            e = e.pageY - g2.top;
            d /= g2.scaleX;
            e /= g2.scaleY;
            return f(a3, { chartX: Math.round(d), chartY: Math.round(e) });
          }
          onContainerClick(a3) {
            const e = this.chart, d = e.hoverPoint;
            a3 = this.normalize(a3);
            const g2 = e.plotLeft, h2 = e.plotTop;
            e.cancelClick || (d && this.inClass(a3.target, "highcharts-tracker") ? (r(d.series, "click", f(a3, { point: d })), e.hoverPoint && d.firePointEvent("click", a3)) : (f(a3, this.getCoordinates(a3)), e.isInsidePlot(a3.chartX - g2, a3.chartY - h2, { visiblePlotOnly: true }) && r(e, "click", a3)));
          }
          onContainerMouseDown(a3) {
            const e = 1 === ((a3.buttons || a3.button) & 1);
            a3 = this.normalize(a3);
            if (y.isFirefox && 0 !== a3.button)
              this.onContainerMouseMove(a3);
            if ("undefined" === typeof a3.button || e)
              this.zoomOption(a3), e && a3.preventDefault && a3.preventDefault(), this.dragStart(a3);
          }
          onContainerMouseLeave(a3) {
            const e = B[I(z.hoverChartIndex, -1)];
            a3 = this.normalize(a3);
            e && a3.relatedTarget && !this.inClass(
              a3.relatedTarget,
              "highcharts-tooltip"
            ) && (e.pointer.reset(), e.pointer.chartPosition = void 0);
          }
          onContainerMouseEnter(a3) {
            delete this.chartPosition;
          }
          onContainerMouseMove(a3) {
            const e = this.chart, d = e.tooltip;
            a3 = this.normalize(a3);
            this.setHoverChartIndex();
            ("mousedown" === e.mouseIsDown || this.touchSelect(a3)) && this.drag(a3);
            e.openMenu || !this.inClass(a3.target, "highcharts-tracker") && !e.isInsidePlot(a3.chartX - e.plotLeft, a3.chartY - e.plotTop, { visiblePlotOnly: true }) || d && d.shouldStickOnContact(a3) || (this.inClass(a3.target, "highcharts-no-tooltip") ? this.reset(false, 0) : this.runPointActions(a3));
          }
          onDocumentTouchEnd(a3) {
            const e = B[I(z.hoverChartIndex, -1)];
            e && e.pointer.drop(a3);
          }
          onContainerTouchMove(a3) {
            if (this.touchSelect(a3))
              this.onContainerMouseMove(a3);
            else
              this.touch(a3);
          }
          onContainerTouchStart(a3) {
            if (this.touchSelect(a3))
              this.onContainerMouseDown(a3);
            else
              this.zoomOption(a3), this.touch(a3, true);
          }
          onDocumentMouseMove(a3) {
            const e = this.chart, d = e.tooltip, f2 = this.chartPosition;
            a3 = this.normalize(a3, f2);
            !f2 || e.isInsidePlot(a3.chartX - e.plotLeft, a3.chartY - e.plotTop, { visiblePlotOnly: true }) || d && d.shouldStickOnContact(a3) || this.inClass(a3.target, "highcharts-tracker") || this.reset();
          }
          onDocumentMouseUp(a3) {
            const e = B[I(z.hoverChartIndex, -1)];
            e && e.pointer.drop(a3);
          }
          pinch(a3) {
            const e = this, d = e.chart, g2 = e.pinchDown, h2 = a3.touches || [], c = h2.length, b = e.lastValidTouch, p = e.hasZoom, l = {}, k2 = 1 === c && (e.inClass(a3.target, "highcharts-tracker") && d.runTrackerClick || e.runChartClick), m2 = {};
            var n2 = e.chart.tooltip;
            n2 = 1 === c && I(n2 && n2.options.followTouchMove, true);
            let v2 = e.selectionMarker;
            1 < c ? e.initiated = true : n2 && (e.initiated = false);
            p && e.initiated && !k2 && false !== a3.cancelable && a3.preventDefault();
            [].map.call(h2, function(b2) {
              return e.normalize(b2);
            });
            "touchstart" === a3.type ? ([].forEach.call(h2, function(b2, a4) {
              g2[a4] = { chartX: b2.chartX, chartY: b2.chartY };
            }), b.x = [g2[0].chartX, g2[1] && g2[1].chartX], b.y = [g2[0].chartY, g2[1] && g2[1].chartY], d.axes.forEach(function(b2) {
              if (b2.zoomEnabled) {
                const a4 = d.bounds[b2.horiz ? "h" : "v"], c2 = b2.minPixelPadding, e2 = b2.toPixels(Math.min(I(b2.options.min, b2.dataMin), b2.dataMin)), f2 = b2.toPixels(Math.max(I(b2.options.max, b2.dataMax), b2.dataMax)), l2 = Math.max(e2, f2);
                a4.min = Math.min(b2.pos, Math.min(e2, f2) - c2);
                a4.max = Math.max(b2.pos + b2.len, l2 + c2);
              }
            }), e.res = true) : n2 ? this.runPointActions(e.normalize(a3)) : g2.length && (r(d, "touchpan", { originalEvent: a3 }, () => {
              v2 || (e.selectionMarker = v2 = f({ destroy: E, touch: true }, d.plotBox));
              e.pinchTranslate(g2, h2, l, v2, m2, b);
              e.hasPinched = p;
              e.scaleGroups(l, m2);
            }), e.res && (e.res = false, this.reset(false, 0)));
          }
          pinchTranslate(a3, f2, d, g2, h2, c) {
            this.zoomHor && this.pinchTranslateDirection(true, a3, f2, d, g2, h2, c);
            this.zoomVert && this.pinchTranslateDirection(false, a3, f2, d, g2, h2, c);
          }
          pinchTranslateDirection(a3, f2, d, g2, h2, c, b, p) {
            const e = this.chart, k2 = a3 ? "x" : "y", q = a3 ? "X" : "Y", m2 = "chart" + q, n2 = a3 ? "width" : "height", t = e["plot" + (a3 ? "Left" : "Top")], r2 = e.inverted, x = e.bounds[a3 ? "h" : "v"], v2 = 1 === f2.length, u2 = f2[0][m2], z2 = !v2 && f2[1][m2];
            f2 = function() {
              "number" === typeof X && 20 < Math.abs(u2 - z2) && (P = p || Math.abs(J - X) / Math.abs(u2 - z2));
              D = (t - J) / P + u2;
              w2 = e["plot" + (a3 ? "Width" : "Height")] / P;
            };
            let w2, D, P = p || 1, J = d[0][m2], X = !v2 && d[1][m2], F2;
            f2();
            d = D;
            d < x.min ? (d = x.min, F2 = true) : d + w2 > x.max && (d = x.max - w2, F2 = true);
            F2 ? (J -= 0.8 * (J - b[k2][0]), "number" === typeof X && (X -= 0.8 * (X - b[k2][1])), f2()) : b[k2] = [
              J,
              X
            ];
            r2 || (c[k2] = D - t, c[n2] = w2);
            c = r2 ? 1 / P : P;
            h2[n2] = w2;
            h2[k2] = d;
            g2[r2 ? a3 ? "scaleY" : "scaleX" : "scale" + q] = P;
            g2["translate" + q] = c * t + (J - c * u2);
          }
          reset(a3, f2) {
            const d = this.chart, e = d.hoverSeries, g2 = d.hoverPoint, c = d.hoverPoints, b = d.tooltip, p = b && b.shared ? c : g2;
            a3 && p && F(p).forEach(function(b2) {
              b2.series.isCartesian && "undefined" === typeof b2.plotX && (a3 = false);
            });
            if (a3)
              b && p && F(p).length && (b.refresh(p), b.shared && c ? c.forEach(function(b2) {
                b2.setState(b2.state, true);
                b2.series.isCartesian && (b2.series.xAxis.crosshair && b2.series.xAxis.drawCrosshair(null, b2), b2.series.yAxis.crosshair && b2.series.yAxis.drawCrosshair(null, b2));
              }) : g2 && (g2.setState(g2.state, true), d.axes.forEach(function(b2) {
                b2.crosshair && g2.series[b2.coll] === b2 && b2.drawCrosshair(null, g2);
              })));
            else {
              if (g2)
                g2.onMouseOut();
              c && c.forEach(function(b2) {
                b2.setState();
              });
              if (e)
                e.onMouseOut();
              b && b.hide(f2);
              this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
              d.axes.forEach(function(b2) {
                b2.hideCrosshair();
              });
              this.hoverX = d.hoverPoints = d.hoverPoint = null;
            }
          }
          runPointActions(a3, f2, d) {
            const e = this.chart, g2 = e.tooltip && e.tooltip.options.enabled ? e.tooltip : void 0, c = g2 ? g2.shared : false;
            let b = f2 || e.hoverPoint, p = b && b.series || e.hoverSeries;
            f2 = this.getHoverData(b, p, e.series, (!a3 || "touchmove" !== a3.type) && (!!f2 || p && p.directTouch && this.isDirectTouch), c, a3);
            b = f2.hoverPoint;
            p = f2.hoverSeries;
            const l = f2.hoverPoints;
            f2 = p && p.tooltipOptions.followPointer && !p.tooltipOptions.split;
            const k2 = c && p && !p.noSharedTooltip;
            if (b && (d || b !== e.hoverPoint || g2 && g2.isHidden)) {
              (e.hoverPoints || []).forEach(function(b2) {
                -1 === l.indexOf(b2) && b2.setState();
              });
              if (e.hoverSeries !== p)
                p.onMouseOver();
              this.applyInactiveState(l);
              (l || []).forEach(function(b2) {
                b2.setState("hover");
              });
              e.hoverPoint && e.hoverPoint.firePointEvent("mouseOut");
              if (!b.series)
                return;
              e.hoverPoints = l;
              e.hoverPoint = b;
              b.firePointEvent("mouseOver", void 0, () => {
                g2 && b && g2.refresh(k2 ? l : b, a3);
              });
            } else
              f2 && g2 && !g2.isHidden && (d = g2.getAnchor([{}], a3), e.isInsidePlot(d[0], d[1], { visiblePlotOnly: true }) && g2.updatePosition({ plotX: d[0], plotY: d[1] }));
            this.unDocMouseMove || (this.unDocMouseMove = C(e.container.ownerDocument, "mousemove", function(b2) {
              const a4 = B[z.hoverChartIndex];
              if (a4)
                a4.pointer.onDocumentMouseMove(b2);
            }), this.eventsToUnbind.push(this.unDocMouseMove));
            e.axes.forEach(function(b2) {
              const c2 = I((b2.crosshair || {}).snap, true);
              let d2;
              c2 && ((d2 = e.hoverPoint) && d2.series[b2.coll] === b2 || (d2 = h(l, (a4) => a4.series && a4.series[b2.coll] === b2)));
              d2 || !c2 ? b2.drawCrosshair(a3, d2) : b2.hideCrosshair();
            });
          }
          scaleGroups(a3, f2) {
            const d = this.chart;
            d.series.forEach(function(e) {
              const g2 = a3 || e.getPlotBox();
              e.group && (e.xAxis && e.xAxis.zoomEnabled || d.mapView) && (e.group.attr(g2), e.markerGroup && (e.markerGroup.attr(g2), e.markerGroup.clip(f2 ? d.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(g2));
            });
            d.clipRect.attr(f2 || d.clipBox);
          }
          setDOMEvents() {
            const a3 = this.chart.container, f2 = a3.ownerDocument;
            a3.onmousedown = this.onContainerMouseDown.bind(this);
            a3.onmousemove = this.onContainerMouseMove.bind(this);
            a3.onclick = this.onContainerClick.bind(this);
            this.eventsToUnbind.push(C(a3, "mouseenter", this.onContainerMouseEnter.bind(this)));
            this.eventsToUnbind.push(C(a3, "mouseleave", this.onContainerMouseLeave.bind(this)));
            z.unbindDocumentMouseUp || (z.unbindDocumentMouseUp = C(f2, "mouseup", this.onDocumentMouseUp.bind(this)));
            let d = this.chart.renderTo.parentElement;
            for (; d && "BODY" !== d.tagName; )
              this.eventsToUnbind.push(C(d, "scroll", () => {
                delete this.chartPosition;
              })), d = d.parentElement;
            y.hasTouch && (this.eventsToUnbind.push(C(a3, "touchstart", this.onContainerTouchStart.bind(this), { passive: false })), this.eventsToUnbind.push(C(a3, "touchmove", this.onContainerTouchMove.bind(this), { passive: false })), z.unbindDocumentTouchEnd || (z.unbindDocumentTouchEnd = C(f2, "touchend", this.onDocumentTouchEnd.bind(this), { passive: false })));
          }
          setHoverChartIndex() {
            const a3 = this.chart, f2 = y.charts[I(z.hoverChartIndex, -1)];
            if (f2 && f2 !== a3)
              f2.pointer.onContainerMouseLeave({ relatedTarget: a3.container });
            f2 && f2.mouseIsDown || (z.hoverChartIndex = a3.index);
          }
          touch(a3, f2) {
            const d = this.chart;
            let e, g2;
            this.setHoverChartIndex();
            1 === a3.touches.length ? (a3 = this.normalize(a3), (g2 = d.isInsidePlot(a3.chartX - d.plotLeft, a3.chartY - d.plotTop, { visiblePlotOnly: true })) && !d.openMenu ? (f2 && this.runPointActions(a3), "touchmove" === a3.type && (f2 = this.pinchDown, e = f2[0] ? 4 <= Math.sqrt(Math.pow(f2[0].chartX - a3.chartX, 2) + Math.pow(f2[0].chartY - a3.chartY, 2)) : false), I(e, true) && this.pinch(a3)) : f2 && this.reset()) : 2 === a3.touches.length && this.pinch(a3);
          }
          touchSelect(a3) {
            return !(!this.chart.options.chart.zooming.singleTouch || !a3.touches || 1 !== a3.touches.length);
          }
          zoomOption(a3) {
            var e = this.chart, d = e.options.chart;
            e = e.inverted;
            let f2 = d.zooming.type || "";
            /touch/.test(a3.type) && (f2 = I(d.zooming.pinchType, f2));
            this.zoomX = a3 = /x/.test(f2);
            this.zoomY = d = /y/.test(f2);
            this.zoomHor = a3 && !e || d && e;
            this.zoomVert = d && !e || a3 && e;
            this.hasZoom = a3 || d;
          }
        }
        (function(a3) {
          const e = [], d = [];
          a3.compose = function(e2) {
            H.pushUnique(
              d,
              e2
            ) && C(e2, "beforeRender", function() {
              this.pointer = new a3(this, this.options);
            });
          };
          a3.dissolve = function() {
            for (let a4 = 0, d2 = e.length; a4 < d2; ++a4)
              e[a4]();
            e.length = 0;
          };
        })(z || (z = {}));
        "";
        return z;
      });
      M(a, "Core/Legend/Legend.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Core/Series/Point.js"], a["Core/Renderer/RendererUtilities.js"], a["Core/Utilities.js"]], function(a2, y, H, K, B, E) {
        const { animObject: w, setAnimation: A } = a2, { format: u } = y, { marginNames: v } = H, { distribute: f } = B, {
          addEvent: h,
          createElement: r,
          css: m,
          defined: n,
          discardElement: k,
          find: g,
          fireEvent: I,
          isNumber: F,
          merge: z,
          pick: e,
          relativeLength: t,
          stableSort: d,
          syncTimeout: q
        } = E;
        class x {
          constructor(a3, b) {
            this.allItems = [];
            this.contentGroup = this.box = void 0;
            this.display = false;
            this.group = void 0;
            this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
            this.options = void 0;
            this.padding = 0;
            this.pages = [];
            this.proximate = false;
            this.scrollGroup = void 0;
            this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
            this.chart = a3;
            this.init(a3, b);
          }
          init(a3, b) {
            this.chart = a3;
            this.setOptions(b);
            b.enabled && (this.render(), h(this.chart, "endResize", function() {
              this.legend.positionCheckboxes();
            }), h(this.chart, "render", () => {
              this.proximate && (this.proximatePositions(), this.positionItems());
            }));
          }
          setOptions(a3) {
            const b = e(a3.padding, 8);
            this.options = a3;
            this.chart.styledMode || (this.itemStyle = a3.itemStyle, this.itemHiddenStyle = z(this.itemStyle, a3.itemHiddenStyle));
            this.itemMarginTop = a3.itemMarginTop;
            this.itemMarginBottom = a3.itemMarginBottom;
            this.padding = b;
            this.initialItemY = b - 5;
            this.symbolWidth = e(a3.symbolWidth, 16);
            this.pages = [];
            this.proximate = "proximate" === a3.layout && !this.chart.inverted;
            this.baseline = void 0;
          }
          update(a3, b) {
            const c = this.chart;
            this.setOptions(z(true, this.options, a3));
            this.destroy();
            c.isDirtyLegend = c.isDirtyBox = true;
            e(b, true) && c.redraw();
            I(this, "afterUpdate");
          }
          colorizeItem(a3, b) {
            const {
              group: c,
              label: d2,
              line: e2,
              symbol: f2
            } = a3.legendItem || {};
            if (c)
              c[b ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
            if (!this.chart.styledMode) {
              var g2 = this.options;
              const c2 = this.itemHiddenStyle.color;
              g2 = b ? g2.itemStyle.color : c2;
              const l = b ? a3.color || c2 : c2, p = a3.options && a3.options.marker;
              let h2 = { fill: l };
              d2 && d2.css({ fill: g2 });
              e2 && e2.attr({ stroke: l });
              f2 && (p && f2.isMarker && (h2 = a3.pointAttribs(), b || (h2.stroke = h2.fill = c2)), f2.attr(h2));
            }
            I(this, "afterColorizeItem", { item: a3, visible: b });
          }
          positionItems() {
            this.allItems.forEach(
              this.positionItem,
              this
            );
            this.chart.isResizing || this.positionCheckboxes();
          }
          positionItem(a3) {
            const { group: b, x: c = 0, y: d2 = 0 } = a3.legendItem || {};
            var e2 = this.options, f2 = e2.symbolPadding;
            const g2 = !e2.rtl;
            e2 = a3.checkbox;
            b && b.element && (f2 = { translateX: g2 ? c : this.legendWidth - c - 2 * f2 - 4, translateY: d2 }, b[n(b.translateY) ? "animate" : "attr"](f2, void 0, () => {
              I(this, "afterPositionItem", { item: a3 });
            }));
            e2 && (e2.x = c, e2.y = d2);
          }
          destroyItem(a3) {
            const b = a3.checkbox, c = a3.legendItem || {};
            for (const b2 of ["group", "label", "line", "symbol"])
              c[b2] && (c[b2] = c[b2].destroy());
            b && k(b);
            a3.legendItem = void 0;
          }
          destroy() {
            for (const a3 of this.getAllItems())
              this.destroyItem(a3);
            for (const a3 of "clipRect up down pager nav box title group".split(" "))
              this[a3] && (this[a3] = this[a3].destroy());
            this.display = null;
          }
          positionCheckboxes() {
            const a3 = this.group && this.group.alignAttr, b = this.clipHeight || this.legendHeight, d2 = this.titleHeight;
            let e2;
            a3 && (e2 = a3.translateY, this.allItems.forEach(function(c) {
              const f2 = c.checkbox;
              let l;
              f2 && (l = e2 + d2 + f2.y + (this.scrollOffset || 0) + 3, m(f2, { left: a3.translateX + c.checkboxOffset + f2.x - 20 + "px", top: l + "px", display: this.proximate || l > e2 - 6 && l < e2 + b - 6 ? "" : "none" }));
            }, this));
          }
          renderTitle() {
            var a3 = this.options;
            const b = this.padding, d2 = a3.title;
            let e2 = 0;
            d2.text && (this.title || (this.title = this.chart.renderer.label(d2.text, b - 3, b - 4, void 0, void 0, void 0, a3.useHTML, void 0, "legend-title").attr({ zIndex: 1 }), this.chart.styledMode || this.title.css(d2.style), this.title.add(this.group)), d2.width || this.title.css({ width: this.maxLegendWidth + "px" }), a3 = this.title.getBBox(), e2 = a3.height, this.offsetWidth = a3.width, this.contentGroup.attr({ translateY: e2 }));
            this.titleHeight = e2;
          }
          setText(a3) {
            const b = this.options;
            a3.legendItem.label.attr({ text: b.labelFormat ? u(b.labelFormat, a3, this.chart) : b.labelFormatter.call(a3) });
          }
          renderItem(a3) {
            const b = a3.legendItem = a3.legendItem || {};
            var c = this.chart, d2 = c.renderer;
            const f2 = this.options, g2 = this.symbolWidth, h2 = f2.symbolPadding || 0, k2 = this.itemStyle, q2 = this.itemHiddenStyle, m2 = "horizontal" === f2.layout ? e(f2.itemDistance, 20) : 0, n2 = !f2.rtl, t2 = !a3.series, r2 = !t2 && a3.series.drawLegendSymbol ? a3.series : a3;
            var x2 = r2.options;
            const v2 = this.createCheckboxForItem && x2 && x2.showCheckbox, D = f2.useHTML, P = a3.options.className;
            let J = b.label;
            x2 = g2 + h2 + m2 + (v2 ? 20 : 0);
            J || (b.group = d2.g("legend-item").addClass("highcharts-" + r2.type + "-series highcharts-color-" + a3.colorIndex + (P ? " " + P : "") + (t2 ? " highcharts-series-" + a3.index : "")).attr({ zIndex: 1 }).add(this.scrollGroup), b.label = J = d2.text("", n2 ? g2 + h2 : -h2, this.baseline || 0, D), c.styledMode || J.css(z(a3.visible ? k2 : q2)), J.attr({ align: n2 ? "left" : "right", zIndex: 2 }).add(b.group), this.baseline || (this.fontMetrics = d2.fontMetrics(J), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, J.attr("y", this.baseline), this.symbolHeight = e(f2.symbolHeight, this.fontMetrics.f), f2.squareSymbol && (this.symbolWidth = e(f2.symbolWidth, Math.max(this.symbolHeight, 16)), x2 = this.symbolWidth + h2 + m2 + (v2 ? 20 : 0), n2 && J.attr("x", this.symbolWidth + h2))), r2.drawLegendSymbol(this, a3), this.setItemEvents && this.setItemEvents(a3, J, D));
            v2 && !a3.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a3);
            this.colorizeItem(a3, a3.visible);
            !c.styledMode && k2.width || J.css({ width: (f2.itemWidth || this.widthOption || c.spacingBox.width) - x2 + "px" });
            this.setText(a3);
            c = J.getBBox();
            d2 = this.fontMetrics && this.fontMetrics.h || 0;
            a3.itemWidth = a3.checkboxOffset = f2.itemWidth || b.labelWidth || c.width + x2;
            this.maxItemWidth = Math.max(this.maxItemWidth, a3.itemWidth);
            this.totalItemWidth += a3.itemWidth;
            this.itemHeight = a3.itemHeight = Math.round(b.labelHeight || (c.height > 1.5 * d2 ? c.height : d2));
          }
          layoutItem(a3) {
            var b = this.options;
            const c = this.padding, d2 = "horizontal" === b.layout, f2 = a3.itemHeight, g2 = this.itemMarginBottom, h2 = this.itemMarginTop, k2 = d2 ? e(b.itemDistance, 20) : 0, q2 = this.maxLegendWidth;
            b = b.alignColumns && this.totalItemWidth > q2 ? this.maxItemWidth : a3.itemWidth;
            const m2 = a3.legendItem || {};
            d2 && this.itemX - c + b > q2 && (this.itemX = c, this.lastLineHeight && (this.itemY += h2 + this.lastLineHeight + g2), this.lastLineHeight = 0);
            this.lastItemY = h2 + this.itemY + g2;
            this.lastLineHeight = Math.max(f2, this.lastLineHeight);
            m2.x = this.itemX;
            m2.y = this.itemY;
            d2 ? this.itemX += b : (this.itemY += h2 + f2 + g2, this.lastLineHeight = f2);
            this.offsetWidth = this.widthOption || Math.max((d2 ? this.itemX - c - (a3.checkbox ? 0 : k2) : b) + c, this.offsetWidth);
          }
          getAllItems() {
            let a3 = [];
            this.chart.series.forEach(function(b) {
              const c = b && b.options;
              b && e(c.showInLegend, n(c.linkedTo) ? false : void 0, true) && (a3 = a3.concat((b.legendItem || {}).labels || ("point" === c.legendType ? b.data : b)));
            });
            I(this, "afterGetAllItems", { allItems: a3 });
            return a3;
          }
          getAlignment() {
            const a3 = this.options;
            return this.proximate ? a3.align.charAt(0) + "tv" : a3.floating ? "" : a3.align.charAt(0) + a3.verticalAlign.charAt(0) + a3.layout.charAt(0);
          }
          adjustMargins(a3, b) {
            const c = this.chart, d2 = this.options, f2 = this.getAlignment();
            f2 && [
              /(lth|ct|rth)/,
              /(rtv|rm|rbv)/,
              /(rbh|cb|lbh)/,
              /(lbv|lm|ltv)/
            ].forEach(function(l, g2) {
              l.test(f2) && !n(a3[g2]) && (c[v[g2]] = Math.max(c[v[g2]], c.legend[(g2 + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][g2] * d2[g2 % 2 ? "x" : "y"] + e(d2.margin, 12) + b[g2] + (c.titleOffset[g2] || 0)));
            });
          }
          proximatePositions() {
            const a3 = this.chart, b = [], d2 = "left" === this.options.align;
            this.allItems.forEach(function(c) {
              var e3;
              var f2 = d2;
              let l;
              c.yAxis && (c.xAxis.options.reversed && (f2 = !f2), c.points && (e3 = g(f2 ? c.points : c.points.slice(0).reverse(), function(b2) {
                return F(b2.plotY);
              })), f2 = this.itemMarginTop + c.legendItem.label.getBBox().height + this.itemMarginBottom, l = c.yAxis.top - a3.plotTop, c.visible ? (e3 = e3 ? e3.plotY : c.yAxis.height, e3 += l - 0.3 * f2) : e3 = l + c.yAxis.height, b.push({ target: e3, size: f2, item: c }));
            }, this);
            let e2;
            for (const c of f(b, a3.plotHeight))
              e2 = c.item.legendItem || {}, F(c.pos) && (e2.y = a3.plotTop - a3.spacing[0] + c.pos);
          }
          render() {
            const a3 = this.chart, b = a3.renderer, e2 = this.options, f2 = this.padding;
            var g2 = this.getAllItems();
            let h2, k2 = this.group, q2 = this.box;
            this.itemX = f2;
            this.itemY = this.initialItemY;
            this.lastItemY = this.offsetWidth = 0;
            this.widthOption = t(e2.width, a3.spacingBox.width - f2);
            var m2 = a3.spacingBox.width - 2 * f2 - e2.x;
            -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (m2 /= 2);
            this.maxLegendWidth = this.widthOption || m2;
            k2 || (this.group = k2 = b.g("legend").addClass(e2.className || "").attr({ zIndex: 7 }).add(), this.contentGroup = b.g().attr({ zIndex: 1 }).add(k2), this.scrollGroup = b.g().add(this.contentGroup));
            this.renderTitle();
            d(g2, (b2, a4) => (b2.options && b2.options.legendIndex || 0) - (a4.options && a4.options.legendIndex || 0));
            e2.reversed && g2.reverse();
            this.allItems = g2;
            this.display = m2 = !!g2.length;
            this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
            g2.forEach(this.renderItem, this);
            g2.forEach(this.layoutItem, this);
            g2 = (this.widthOption || this.offsetWidth) + f2;
            h2 = this.lastItemY + this.lastLineHeight + this.titleHeight;
            h2 = this.handleOverflow(h2);
            h2 += f2;
            q2 || (this.box = q2 = b.rect().addClass("highcharts-legend-box").attr({ r: e2.borderRadius }).add(k2));
            a3.styledMode || q2.attr({ stroke: e2.borderColor, "stroke-width": e2.borderWidth || 0, fill: e2.backgroundColor || "none" }).shadow(e2.shadow);
            if (0 < g2 && 0 < h2)
              q2[q2.placed ? "animate" : "attr"](q2.crisp.call({}, { x: 0, y: 0, width: g2, height: h2 }, q2.strokeWidth()));
            k2[m2 ? "show" : "hide"]();
            a3.styledMode && "none" === k2.getStyle("display") && (g2 = h2 = 0);
            this.legendWidth = g2;
            this.legendHeight = h2;
            m2 && this.align();
            this.proximate || this.positionItems();
            I(this, "afterRender");
          }
          align(a3 = this.chart.spacingBox) {
            const b = this.chart, c = this.options;
            let d2 = a3.y;
            /(lth|ct|rth)/.test(this.getAlignment()) && 0 < b.titleOffset[0] ? d2 += b.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < b.titleOffset[2] && (d2 -= b.titleOffset[2]);
            d2 !== a3.y && (a3 = z(a3, { y: d2 }));
            b.hasRendered || (this.group.placed = false);
            this.group.align(z(c, { width: this.legendWidth, height: this.legendHeight, verticalAlign: this.proximate ? "top" : c.verticalAlign }), true, a3);
          }
          handleOverflow(a3) {
            const b = this, c = this.chart, d2 = c.renderer, f2 = this.options;
            var g2 = f2.y;
            const h2 = "top" === f2.verticalAlign, k2 = this.padding, q2 = f2.maxHeight, m2 = f2.navigation, n2 = e(m2.animation, true), t2 = m2.arrowSize || 12, r2 = this.pages, x2 = this.allItems, v2 = function(a4) {
              "number" === typeof a4 ? w2.attr({ height: a4 }) : w2 && (b.clipRect = w2.destroy(), b.contentGroup.clip());
              b.contentGroup.div && (b.contentGroup.div.style.clip = a4 ? "rect(" + k2 + "px,9999px," + (k2 + a4) + "px,0)" : "auto");
            }, D = function(a4) {
              b[a4] = d2.circle(0, 0, 1.3 * t2).translate(t2 / 2, t2 / 2).add(z2);
              c.styledMode || b[a4].attr("fill", "rgba(0,0,0,0.0001)");
              return b[a4];
            };
            let P, J, u2;
            g2 = c.spacingBox.height + (h2 ? -g2 : g2) - k2;
            let z2 = this.nav, w2 = this.clipRect;
            "horizontal" !== f2.layout || "middle" === f2.verticalAlign || f2.floating || (g2 /= 2);
            q2 && (g2 = Math.min(g2, q2));
            r2.length = 0;
            a3 && 0 < g2 && a3 > g2 && false !== m2.enabled ? (this.clipHeight = P = Math.max(g2 - 20 - this.titleHeight - k2, 0), this.currentPage = e(this.currentPage, 1), this.fullHeight = a3, x2.forEach((a4, b2) => {
              u2 = a4.legendItem || {};
              a4 = u2.y || 0;
              const c2 = Math.round(u2.label.getBBox().height);
              let d3 = r2.length;
              if (!d3 || a4 - r2[d3 - 1] > P && (J || a4) !== r2[d3 - 1])
                r2.push(J || a4), d3++;
              u2.pageIx = d3 - 1;
              J && ((x2[b2 - 1].legendItem || {}).pageIx = d3 - 1);
              b2 === x2.length - 1 && a4 + c2 - r2[d3 - 1] > P && a4 > r2[d3 - 1] && (r2.push(a4), u2.pageIx = d3);
              a4 !== J && (J = a4);
            }), w2 || (w2 = b.clipRect = d2.clipRect(0, k2 - 2, 9999, 0), b.contentGroup.clip(w2)), v2(P), z2 || (this.nav = z2 = d2.g().attr({ zIndex: 1 }).add(this.group), this.up = d2.symbol("triangle", 0, 0, t2, t2).add(z2), D("upTracker").on("click", function() {
              b.scroll(-1, n2);
            }), this.pager = d2.text("", 15, 10).addClass("highcharts-legend-navigation"), !c.styledMode && m2.style && this.pager.css(m2.style), this.pager.add(z2), this.down = d2.symbol("triangle-down", 0, 0, t2, t2).add(z2), D("downTracker").on("click", function() {
              b.scroll(1, n2);
            })), b.scroll(0), a3 = g2) : z2 && (v2(), this.nav = z2.destroy(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0);
            return a3;
          }
          scroll(a3, b) {
            const c = this.chart, d2 = this.pages, f2 = d2.length, g2 = this.clipHeight, h2 = this.options.navigation, k2 = this.pager, m2 = this.padding;
            let n2 = this.currentPage + a3;
            n2 > f2 && (n2 = f2);
            0 < n2 && ("undefined" !== typeof b && A(b, c), this.nav.attr({ translateX: m2, translateY: g2 + this.padding + 7 + this.titleHeight, visibility: "inherit" }), [this.up, this.upTracker].forEach(function(a4) {
              a4.attr({ "class": 1 === n2 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" });
            }), k2.attr({ text: n2 + "/" + f2 }), [this.down, this.downTracker].forEach(function(a4) {
              a4.attr({ x: 18 + this.pager.getBBox().width, "class": n2 === f2 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" });
            }, this), c.styledMode || (this.up.attr({ fill: 1 === n2 ? h2.inactiveColor : h2.activeColor }), this.upTracker.css({ cursor: 1 === n2 ? "default" : "pointer" }), this.down.attr({ fill: n2 === f2 ? h2.inactiveColor : h2.activeColor }), this.downTracker.css({ cursor: n2 === f2 ? "default" : "pointer" })), this.scrollOffset = -d2[n2 - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: this.scrollOffset }), this.currentPage = n2, this.positionCheckboxes(), a3 = w(e(b, c.renderer.globalAnimation, true)), q(
              () => {
                I(this, "afterScroll", { currentPage: n2 });
              },
              a3.duration
            ));
          }
          setItemEvents(a3, b, d2) {
            const c = this, e2 = a3.legendItem || {}, f2 = c.chart.renderer.boxWrapper, g2 = a3 instanceof K, h2 = "highcharts-legend-" + (g2 ? "point" : "series") + "-active", k2 = c.chart.styledMode;
            d2 = d2 ? [b, e2.symbol] : [e2.group];
            const p = (b2) => {
              c.allItems.forEach((c2) => {
                a3 !== c2 && [c2].concat(c2.linkedSeries || []).forEach((a4) => {
                  a4.setState(b2, !g2);
                });
              });
            };
            for (const e3 of d2)
              if (e3)
                e3.on("mouseover", function() {
                  a3.visible && p("inactive");
                  a3.setState("hover");
                  a3.visible && f2.addClass(h2);
                  k2 || b.css(c.options.itemHoverStyle);
                }).on("mouseout", function() {
                  c.chart.styledMode || b.css(z(a3.visible ? c.itemStyle : c.itemHiddenStyle));
                  p("");
                  f2.removeClass(h2);
                  a3.setState();
                }).on("click", function(b2) {
                  const c2 = function() {
                    a3.setVisible && a3.setVisible();
                    p(a3.visible ? "inactive" : "");
                  };
                  f2.removeClass(h2);
                  b2 = { browserEvent: b2 };
                  a3.firePointEvent ? a3.firePointEvent("legendItemClick", b2, c2) : I(a3, "legendItemClick", b2, c2);
                });
          }
          createCheckboxForItem(a3) {
            a3.checkbox = r("input", { type: "checkbox", className: "highcharts-legend-checkbox", checked: a3.selected, defaultChecked: a3.selected }, this.options.itemCheckboxStyle, this.chart.container);
            h(a3.checkbox, "click", function(b) {
              I(a3.series || a3, "checkboxClick", { checked: b.target.checked, item: a3 }, function() {
                a3.select();
              });
            });
          }
        }
        (function(a3) {
          const b = [];
          a3.compose = function(c) {
            E.pushUnique(b, c) && h(c, "beforeMargins", function() {
              this.legend = new a3(this, this.options.legend);
            });
          };
        })(x || (x = {}));
        "";
        return x;
      });
      M(a, "Core/Series/SeriesRegistry.js", [a["Core/Globals.js"], a["Core/Defaults.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function(a2, y, H, K) {
        const { defaultOptions: w } = y, { extendClass: E, merge: C } = K;
        var A;
        (function(u) {
          function v(a3, h) {
            const f = w.plotOptions || {}, m = h.defaultOptions, n = h.prototype;
            n.type = a3;
            n.pointClass || (n.pointClass = H);
            m && (f[a3] = m);
            u.seriesTypes[a3] = h;
          }
          u.seriesTypes = a2.seriesTypes;
          u.registerSeriesType = v;
          u.seriesType = function(a3, h, r, m, n) {
            const f = w.plotOptions || {};
            h = h || "";
            f[a3] = C(f[h], r);
            v(a3, E(u.seriesTypes[h] || function() {
            }, m));
            u.seriesTypes[a3].prototype.type = a3;
            n && (u.seriesTypes[a3].prototype.pointClass = E(H, n));
            return u.seriesTypes[a3];
          };
        })(A || (A = {}));
        return A;
      });
      M(a, "Core/Chart/Chart.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Axis/Axis.js"],
        a["Core/Defaults.js"],
        a["Core/FormatUtilities.js"],
        a["Core/Foundation.js"],
        a["Core/Globals.js"],
        a["Core/Renderer/RendererRegistry.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Time.js"],
        a["Core/Utilities.js"],
        a["Core/Renderer/HTML/AST.js"]
      ], function(a2, y, H, K, B, E, C, A, u, v, f, h) {
        const { animate: r, animObject: m, setAnimation: n } = a2, { defaultOptions: k, defaultTime: g } = H, { numberFormat: w } = K, { registerEventOptions: F } = B, {
          charts: z,
          doc: e,
          marginNames: t,
          svg: d,
          win: q
        } = E, { seriesTypes: x } = A, { addEvent: c, attr: b, cleanRecursively: p, createElement: l, css: L, defined: N, discardElement: O, erase: Z, error: S, extend: U, find: G, fireEvent: Q, getStyle: M2, isArray: fa, isNumber: Y, isObject: D, isString: P, merge: J, objectEach: X, pick: R, pInt: V, relativeLength: ha, removeEvent: aa, splat: ca, syncTimeout: ia, uniqueKey: ja } = f;
        class da {
          static chart(a3, b2, c2) {
            return new da(a3, b2, c2);
          }
          constructor(a3, b2, c2) {
            this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
            this.sharedClips = {};
            this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
            this.getArgs(a3, b2, c2);
          }
          getArgs(a3, b2, c2) {
            P(a3) || a3.nodeName ? (this.renderTo = a3, this.init(b2, c2)) : this.init(
              a3,
              b2
            );
          }
          init(a3, b2) {
            const c2 = a3.plotOptions || {};
            Q(this, "init", { args: arguments }, function() {
              const d2 = J(k, a3), e2 = d2.chart;
              X(d2.plotOptions, function(a4, b3) {
                D(a4) && (a4.tooltip = c2[b3] && J(c2[b3].tooltip) || void 0);
              });
              d2.tooltip.userOptions = a3.chart && a3.chart.forExport && a3.tooltip.userOptions || a3.tooltip;
              this.userOptions = a3;
              this.margin = [];
              this.spacing = [];
              this.bounds = { h: {}, v: {} };
              this.labelCollectors = [];
              this.callback = b2;
              this.isResizing = 0;
              const f2 = e2.zooming = e2.zooming || {};
              a3.chart && !a3.chart.zooming && (f2.resetButton = e2.resetZoomButton);
              f2.key = R(
                f2.key,
                e2.zoomKey
              );
              f2.pinchType = R(f2.pinchType, e2.pinchType);
              f2.singleTouch = R(f2.singleTouch, e2.zoomBySingleTouch);
              f2.type = R(f2.type, e2.zoomType);
              this.options = d2;
              this.axes = [];
              this.series = [];
              this.time = a3.time && Object.keys(a3.time).length ? new v(a3.time) : E.time;
              this.numberFormatter = e2.numberFormatter || w;
              this.styledMode = e2.styledMode;
              this.hasCartesianSeries = e2.showAxes;
              this.index = z.length;
              z.push(this);
              E.chartCount++;
              F(this, e2);
              this.xAxis = [];
              this.yAxis = [];
              this.pointCount = this.colorCounter = this.symbolCounter = 0;
              Q(this, "afterInit");
              this.firstRender();
            });
          }
          initSeries(a3) {
            var b2 = this.options.chart;
            b2 = a3.type || b2.type;
            const c2 = x[b2];
            c2 || S(17, true, this, { missingModuleFor: b2 });
            b2 = new c2();
            "function" === typeof b2.init && b2.init(this, a3);
            return b2;
          }
          setSeriesData() {
            this.getSeriesOrderByLinks().forEach(function(a3) {
              a3.points || a3.data || !a3.enabledDataSorting || a3.setData(a3.options.data, false);
            });
          }
          getSeriesOrderByLinks() {
            return this.series.concat().sort(function(a3, b2) {
              return a3.linkedSeries.length || b2.linkedSeries.length ? b2.linkedSeries.length - a3.linkedSeries.length : 0;
            });
          }
          orderSeries(a3) {
            const b2 = this.series;
            for (let c2 = a3 || 0, d2 = b2.length; c2 < d2; ++c2)
              b2[c2] && (b2[c2].index = c2, b2[c2].name = b2[c2].getName());
          }
          isInsidePlot(a3, b2, c2 = {}) {
            const { inverted: d2, plotBox: e2, plotLeft: f2, plotTop: g2, scrollablePlotBox: l2 } = this;
            var h2 = 0;
            let k2 = 0;
            c2.visiblePlotOnly && this.scrollingContainer && ({ scrollLeft: h2, scrollTop: k2 } = this.scrollingContainer);
            const p2 = c2.series, q2 = c2.visiblePlotOnly && l2 || e2;
            var m2 = c2.inverted ? b2 : a3;
            b2 = c2.inverted ? a3 : b2;
            a3 = { x: m2, y: b2, isInsidePlot: true, options: c2 };
            if (!c2.ignoreX) {
              const b3 = p2 && (d2 && !this.polar ? p2.yAxis : p2.xAxis) || { pos: f2, len: Infinity };
              m2 = c2.paneCoordinates ? b3.pos + m2 : f2 + m2;
              m2 >= Math.max(h2 + f2, b3.pos) && m2 <= Math.min(h2 + f2 + q2.width, b3.pos + b3.len) || (a3.isInsidePlot = false);
            }
            !c2.ignoreY && a3.isInsidePlot && (h2 = !d2 && c2.axis && !c2.axis.isXAxis && c2.axis || p2 && (d2 ? p2.xAxis : p2.yAxis) || { pos: g2, len: Infinity }, c2 = c2.paneCoordinates ? h2.pos + b2 : g2 + b2, c2 >= Math.max(k2 + g2, h2.pos) && c2 <= Math.min(k2 + g2 + q2.height, h2.pos + h2.len) || (a3.isInsidePlot = false));
            Q(this, "afterIsInsidePlot", a3);
            return a3.isInsidePlot;
          }
          redraw(a3) {
            Q(this, "beforeRedraw");
            const b2 = this.hasCartesianSeries ? this.axes : this.colorAxis || [], c2 = this.series, d2 = this.pointer, e2 = this.legend, f2 = this.userOptions.legend, g2 = this.renderer, l2 = g2.isHidden(), h2 = [];
            let k2, p2, q2 = this.isDirtyBox, m2 = this.isDirtyLegend, D2;
            g2.rootFontSize = g2.boxWrapper.getStyle("font-size");
            this.setResponsive && this.setResponsive(false);
            n(this.hasRendered ? a3 : false, this);
            l2 && this.temporaryDisplay();
            this.layOutTitles();
            for (a3 = c2.length; a3--; )
              if (D2 = c2[a3], D2.options.stacking || D2.options.centerInCategory) {
                if (p2 = true, D2.isDirty) {
                  k2 = true;
                  break;
                }
              }
            if (k2)
              for (a3 = c2.length; a3--; )
                D2 = c2[a3], D2.options.stacking && (D2.isDirty = true);
            c2.forEach(function(a4) {
              a4.isDirty && ("point" === a4.options.legendType ? ("function" === typeof a4.updateTotals && a4.updateTotals(), m2 = true) : f2 && (f2.labelFormatter || f2.labelFormat) && (m2 = true));
              a4.isDirtyData && Q(a4, "updatedData");
            });
            m2 && e2 && e2.options.enabled && (e2.render(), this.isDirtyLegend = false);
            p2 && this.getStacks();
            b2.forEach(function(a4) {
              a4.updateNames();
              a4.setScale();
            });
            this.getMargins();
            b2.forEach(function(a4) {
              a4.isDirty && (q2 = true);
            });
            b2.forEach(function(a4) {
              const b3 = a4.min + "," + a4.max;
              a4.extKey !== b3 && (a4.extKey = b3, h2.push(function() {
                Q(a4, "afterSetExtremes", U(a4.eventArgs, a4.getExtremes()));
                delete a4.eventArgs;
              }));
              (q2 || p2) && a4.redraw();
            });
            q2 && this.drawChartBox();
            Q(this, "predraw");
            c2.forEach(function(a4) {
              (q2 || a4.isDirty) && a4.visible && a4.redraw();
              a4.isDirtyData = false;
            });
            d2 && d2.reset(true);
            g2.draw();
            Q(this, "redraw");
            Q(this, "render");
            l2 && this.temporaryDisplay(true);
            h2.forEach(function(a4) {
              a4.call();
            });
          }
          get(a3) {
            function b2(b3) {
              return b3.id === a3 || b3.options && b3.options.id === a3;
            }
            const c2 = this.series;
            let d2 = G(this.axes, b2) || G(this.series, b2);
            for (let a4 = 0; !d2 && a4 < c2.length; a4++)
              d2 = G(c2[a4].points || [], b2);
            return d2;
          }
          getAxes() {
            const a3 = this;
            var b2 = this.options;
            const c2 = b2.xAxis = ca(b2.xAxis || {});
            b2 = b2.yAxis = ca(b2.yAxis || {});
            Q(this, "getAxes");
            c2.forEach(function(a4, b3) {
              a4.index = b3;
              a4.isX = true;
            });
            b2.forEach(function(a4, b3) {
              a4.index = b3;
            });
            c2.concat(b2).forEach(function(b3) {
              new y(a3, b3);
            });
            Q(this, "afterGetAxes");
          }
          getSelectedPoints() {
            return this.series.reduce((a3, b2) => {
              b2.getPointsCollection().forEach((b3) => {
                R(b3.selectedStaging, b3.selected) && a3.push(b3);
              });
              return a3;
            }, []);
          }
          getSelectedSeries() {
            return this.series.filter(function(a3) {
              return a3.selected;
            });
          }
          setTitle(a3, b2, c2) {
            this.applyDescription("title", a3);
            this.applyDescription("subtitle", b2);
            this.applyDescription("caption", void 0);
            this.layOutTitles(c2);
          }
          applyDescription(a3, b2) {
            const c2 = this;
            var d2 = "title" === a3 ? { color: "#333333", fontSize: this.options.isStock ? "1em" : "1.2em", fontWeight: "bold" } : { color: "#666666", fontSize: "0.8em" };
            d2 = this.options[a3] = J(!this.styledMode && { style: d2 }, this.options[a3], b2);
            let e2 = this[a3];
            e2 && b2 && (this[a3] = e2 = e2.destroy());
            d2 && !e2 && (e2 = this.renderer.text(d2.text, 0, 0, d2.useHTML).attr({ align: d2.align, "class": "highcharts-" + a3, zIndex: d2.zIndex || 4 }).add(), e2.update = function(b3) {
              c2[{ title: "setTitle", subtitle: "setSubtitle", caption: "setCaption" }[a3]](b3);
            }, this.styledMode || e2.css(d2.style), this[a3] = e2);
          }
          layOutTitles(a3) {
            const b2 = [0, 0, 0], c2 = this.renderer, d2 = this.spacingBox;
            ["title", "subtitle", "caption"].forEach(function(a4) {
              const e3 = this[a4], f2 = this.options[a4], g2 = f2.verticalAlign || "top";
              a4 = "title" === a4 ? "top" === g2 ? -3 : 0 : "top" === g2 ? b2[0] + 2 : 0;
              if (e3) {
                e3.css({ width: (f2.width || d2.width + (f2.widthAdjust || 0)) + "px" });
                const l2 = c2.fontMetrics(e3).b, h2 = Math.round(e3.getBBox(f2.useHTML).height);
                e3.align(U({ y: "bottom" === g2 ? l2 : a4 + l2, height: h2 }, f2), false, "spacingBox");
                f2.floating || ("top" === g2 ? b2[0] = Math.ceil(b2[0] + h2) : "bottom" === g2 && (b2[2] = Math.ceil(b2[2] + h2)));
              }
            }, this);
            b2[0] && "top" === (this.options.title.verticalAlign || "top") && (b2[0] += this.options.title.margin);
            b2[2] && "bottom" === this.options.caption.verticalAlign && (b2[2] += this.options.caption.margin);
            const e2 = !this.titleOffset || this.titleOffset.join(",") !== b2.join(",");
            this.titleOffset = b2;
            Q(this, "afterLayOutTitles");
            !this.isDirtyBox && e2 && (this.isDirtyBox = this.isDirtyLegend = e2, this.hasRendered && R(a3, true) && this.isDirtyBox && this.redraw());
          }
          getContainerBox() {
            return { width: M2(this.renderTo, "width", true) || 0, height: M2(this.renderTo, "height", true) || 0 };
          }
          getChartSize() {
            var a3 = this.options.chart;
            const b2 = a3.width;
            a3 = a3.height;
            const c2 = this.getContainerBox();
            this.chartWidth = Math.max(0, b2 || c2.width || 600);
            this.chartHeight = Math.max(0, ha(a3, this.chartWidth) || (1 < c2.height ? c2.height : 400));
            this.containerBox = c2;
          }
          temporaryDisplay(a3) {
            let b2 = this.renderTo;
            if (a3)
              for (; b2 && b2.style; )
                b2.hcOrigStyle && (L(b2, b2.hcOrigStyle), delete b2.hcOrigStyle), b2.hcOrigDetached && (e.body.removeChild(b2), b2.hcOrigDetached = false), b2 = b2.parentNode;
            else
              for (; b2 && b2.style; ) {
                e.body.contains(b2) || b2.parentNode || (b2.hcOrigDetached = true, e.body.appendChild(b2));
                if ("none" === M2(b2, "display", false) || b2.hcOricDetached)
                  b2.hcOrigStyle = { display: b2.style.display, height: b2.style.height, overflow: b2.style.overflow }, a3 = { display: "block", overflow: "hidden" }, b2 !== this.renderTo && (a3.height = 0), L(b2, a3), b2.offsetWidth || b2.style.setProperty("display", "block", "important");
                b2 = b2.parentNode;
                if (b2 === e.body)
                  break;
              }
          }
          setClassName(a3) {
            this.container.className = "highcharts-container " + (a3 || "");
          }
          getContainer() {
            const a3 = this.options, c2 = a3.chart;
            var f2 = ja();
            let g2, k2 = this.renderTo;
            k2 || (this.renderTo = k2 = c2.renderTo);
            P(k2) && (this.renderTo = k2 = e.getElementById(k2));
            k2 || S(13, true, this);
            var p2 = V(b(k2, "data-highcharts-chart"));
            Y(p2) && z[p2] && z[p2].hasRendered && z[p2].destroy();
            b(k2, "data-highcharts-chart", this.index);
            k2.innerHTML = h.emptyHTML;
            c2.skipClone || k2.offsetWidth || this.temporaryDisplay();
            this.getChartSize();
            p2 = this.chartWidth;
            const q2 = this.chartHeight;
            L(k2, { overflow: "hidden" });
            this.styledMode || (g2 = U({ position: "relative", overflow: "hidden", width: p2 + "px", height: q2 + "px", textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)", userSelect: "none", "touch-action": "manipulation", outline: "none" }, c2.style || {}));
            this.container = f2 = l("div", { id: f2 }, g2, k2);
            this._cursor = f2.style.cursor;
            this.renderer = new (c2.renderer || !d ? C.getRendererType(c2.renderer) : u)(f2, p2, q2, void 0, c2.forExport, a3.exporting && a3.exporting.allowHTML, this.styledMode);
            this.containerBox = this.getContainerBox();
            n(void 0, this);
            this.setClassName(c2.className);
            if (this.styledMode)
              for (const b2 in a3.defs)
                this.renderer.definition(a3.defs[b2]);
            else
              this.renderer.setStyle(c2.style);
            this.renderer.chartIndex = this.index;
            Q(this, "afterGetContainer");
          }
          getMargins(a3) {
            const { spacing: b2, margin: c2, titleOffset: d2 } = this;
            this.resetMargins();
            d2[0] && !N(c2[0]) && (this.plotTop = Math.max(this.plotTop, d2[0] + b2[0]));
            d2[2] && !N(c2[2]) && (this.marginBottom = Math.max(this.marginBottom, d2[2] + b2[2]));
            this.legend && this.legend.display && this.legend.adjustMargins(c2, b2);
            Q(this, "getMargins");
            a3 || this.getAxisMargins();
          }
          getAxisMargins() {
            const a3 = this, b2 = a3.axisOffset = [0, 0, 0, 0], c2 = a3.colorAxis, d2 = a3.margin, e2 = function(a4) {
              a4.forEach(function(a5) {
                a5.visible && a5.getOffset();
              });
            };
            a3.hasCartesianSeries ? e2(a3.axes) : c2 && c2.length && e2(c2);
            t.forEach(function(c3, e3) {
              N(d2[e3]) || (a3[c3] += b2[e3]);
            });
            a3.setChartSize();
          }
          reflow(a3) {
            const b2 = this;
            var c2 = b2.options.chart;
            c2 = N(c2.width) && N(c2.height);
            const d2 = b2.containerBox, e2 = b2.getContainerBox();
            delete b2.pointer.chartPosition;
            if (!c2 && !b2.isPrinting && d2 && e2.width) {
              if (e2.width !== d2.width || e2.height !== d2.height)
                f.clearTimeout(b2.reflowTimeout), b2.reflowTimeout = ia(function() {
                  b2.container && b2.setSize(void 0, void 0, false);
                }, a3 ? 100 : 0);
              b2.containerBox = e2;
            }
          }
          setReflow() {
            const a3 = this;
            var b2 = (b3) => {
              var c2;
              (null === (c2 = a3.options) || void 0 === c2 ? 0 : c2.chart.reflow) && a3.hasLoaded && a3.reflow(b3);
            };
            "function" === typeof ResizeObserver ? new ResizeObserver(b2).observe(a3.renderTo) : (b2 = c(q, "resize", b2), c(this, "destroy", b2));
          }
          setSize(a3, b2, c2) {
            const d2 = this, e2 = d2.renderer;
            d2.isResizing += 1;
            n(c2, d2);
            c2 = e2.globalAnimation;
            d2.oldChartHeight = d2.chartHeight;
            d2.oldChartWidth = d2.chartWidth;
            "undefined" !== typeof a3 && (d2.options.chart.width = a3);
            "undefined" !== typeof b2 && (d2.options.chart.height = b2);
            d2.getChartSize();
            d2.styledMode || (c2 ? r : L)(d2.container, { width: d2.chartWidth + "px", height: d2.chartHeight + "px" }, c2);
            d2.setChartSize(true);
            e2.setSize(d2.chartWidth, d2.chartHeight, c2);
            d2.axes.forEach(function(a4) {
              a4.isDirty = true;
              a4.setScale();
            });
            d2.isDirtyLegend = true;
            d2.isDirtyBox = true;
            d2.layOutTitles();
            d2.getMargins();
            d2.redraw(c2);
            d2.oldChartHeight = null;
            Q(d2, "resize");
            ia(function() {
              d2 && Q(d2, "endResize", null, function() {
                --d2.isResizing;
              });
            }, m(c2).duration);
          }
          setChartSize(a3) {
            var b2 = this.inverted;
            const c2 = this.renderer;
            var d2 = this.chartWidth, e2 = this.chartHeight;
            const f2 = this.options.chart, g2 = this.spacing, l2 = this.clipOffset;
            let h2, k2, p2, q2;
            this.plotLeft = h2 = Math.round(this.plotLeft);
            this.plotTop = k2 = Math.round(this.plotTop);
            this.plotWidth = p2 = Math.max(0, Math.round(d2 - h2 - this.marginRight));
            this.plotHeight = q2 = Math.max(0, Math.round(e2 - k2 - this.marginBottom));
            this.plotSizeX = b2 ? q2 : p2;
            this.plotSizeY = b2 ? p2 : q2;
            this.plotBorderWidth = f2.plotBorderWidth || 0;
            this.spacingBox = c2.spacingBox = {
              x: g2[3],
              y: g2[0],
              width: d2 - g2[3] - g2[1],
              height: e2 - g2[0] - g2[2]
            };
            this.plotBox = c2.plotBox = { x: h2, y: k2, width: p2, height: q2 };
            b2 = 2 * Math.floor(this.plotBorderWidth / 2);
            d2 = Math.ceil(Math.max(b2, l2[3]) / 2);
            e2 = Math.ceil(Math.max(b2, l2[0]) / 2);
            this.clipBox = { x: d2, y: e2, width: Math.floor(this.plotSizeX - Math.max(b2, l2[1]) / 2 - d2), height: Math.max(0, Math.floor(this.plotSizeY - Math.max(b2, l2[2]) / 2 - e2)) };
            a3 || (this.axes.forEach(function(a4) {
              a4.setAxisSize();
              a4.setAxisTranslation();
            }), c2.alignElements());
            Q(this, "afterSetChartSize", { skipAxes: a3 });
          }
          resetMargins() {
            Q(this, "resetMargins");
            const a3 = this, b2 = a3.options.chart;
            ["margin", "spacing"].forEach(function(c2) {
              const d2 = b2[c2], e2 = D(d2) ? d2 : [d2, d2, d2, d2];
              ["Top", "Right", "Bottom", "Left"].forEach(function(d3, f2) {
                a3[c2][f2] = R(b2[c2 + d3], e2[f2]);
              });
            });
            t.forEach(function(b3, c2) {
              a3[b3] = R(a3.margin[c2], a3.spacing[c2]);
            });
            a3.axisOffset = [0, 0, 0, 0];
            a3.clipOffset = [0, 0, 0, 0];
          }
          drawChartBox() {
            const a3 = this.options.chart, b2 = this.renderer, c2 = this.chartWidth, d2 = this.chartHeight, e2 = this.styledMode, f2 = this.plotBGImage;
            var g2 = a3.backgroundColor;
            const l2 = a3.plotBackgroundColor, h2 = a3.plotBackgroundImage, k2 = this.plotLeft, p2 = this.plotTop, q2 = this.plotWidth, m2 = this.plotHeight, n2 = this.plotBox, D2 = this.clipRect, t2 = this.clipBox;
            let r2 = this.chartBackground, J2 = this.plotBackground, x2 = this.plotBorder, v2, P2, u2 = "animate";
            r2 || (this.chartBackground = r2 = b2.rect().addClass("highcharts-background").add(), u2 = "attr");
            if (e2)
              v2 = P2 = r2.strokeWidth();
            else {
              v2 = a3.borderWidth || 0;
              P2 = v2 + (a3.shadow ? 8 : 0);
              g2 = { fill: g2 || "none" };
              if (v2 || r2["stroke-width"])
                g2.stroke = a3.borderColor, g2["stroke-width"] = v2;
              r2.attr(g2).shadow(a3.shadow);
            }
            r2[u2]({ x: P2 / 2, y: P2 / 2, width: c2 - P2 - v2 % 2, height: d2 - P2 - v2 % 2, r: a3.borderRadius });
            u2 = "animate";
            J2 || (u2 = "attr", this.plotBackground = J2 = b2.rect().addClass("highcharts-plot-background").add());
            J2[u2](n2);
            e2 || (J2.attr({ fill: l2 || "none" }).shadow(a3.plotShadow), h2 && (f2 ? (h2 !== f2.attr("href") && f2.attr("href", h2), f2.animate(n2)) : this.plotBGImage = b2.image(h2, k2, p2, q2, m2).add()));
            D2 ? D2.animate({ width: t2.width, height: t2.height }) : this.clipRect = b2.clipRect(t2);
            u2 = "animate";
            x2 || (u2 = "attr", this.plotBorder = x2 = b2.rect().addClass("highcharts-plot-border").attr({ zIndex: 1 }).add());
            e2 || x2.attr({ stroke: a3.plotBorderColor, "stroke-width": a3.plotBorderWidth || 0, fill: "none" });
            x2[u2](x2.crisp({ x: k2, y: p2, width: q2, height: m2 }, -x2.strokeWidth()));
            this.isDirtyBox = false;
            Q(this, "afterDrawChartBox");
          }
          propFromSeries() {
            const a3 = this, b2 = a3.options.chart, c2 = a3.options.series;
            let d2, e2, f2;
            ["inverted", "angular", "polar"].forEach(function(g2) {
              e2 = x[b2.type];
              f2 = b2[g2] || e2 && e2.prototype[g2];
              for (d2 = c2 && c2.length; !f2 && d2--; )
                (e2 = x[c2[d2].type]) && e2.prototype[g2] && (f2 = true);
              a3[g2] = f2;
            });
          }
          linkSeries(a3) {
            const b2 = this, c2 = b2.series;
            c2.forEach(function(a4) {
              a4.linkedSeries.length = 0;
            });
            c2.forEach(function(a4) {
              let c3 = a4.options.linkedTo;
              P(c3) && (c3 = ":previous" === c3 ? b2.series[a4.index - 1] : b2.get(c3)) && c3.linkedParent !== a4 && (c3.linkedSeries.push(a4), a4.linkedParent = c3, c3.enabledDataSorting && a4.setDataSortingOptions(), a4.visible = R(a4.options.visible, c3.options.visible, a4.visible));
            });
            Q(this, "afterLinkSeries", { isUpdating: a3 });
          }
          renderSeries() {
            this.series.forEach(function(a3) {
              a3.translate();
              a3.render();
            });
          }
          render() {
            const a3 = this.axes, b2 = this.colorAxis, c2 = this.renderer, d2 = function(a4) {
              a4.forEach(function(a5) {
                a5.visible && a5.render();
              });
            };
            let e2 = 0;
            this.setTitle();
            Q(this, "beforeMargins");
            this.getStacks && this.getStacks();
            this.getMargins(true);
            this.setChartSize();
            const f2 = this.plotWidth;
            a3.some(function(a4) {
              if (a4.horiz && a4.visible && a4.options.labels.enabled && a4.series.length)
                return e2 = 21, true;
            });
            const g2 = this.plotHeight = Math.max(this.plotHeight - e2, 0);
            a3.forEach(function(a4) {
              a4.setScale();
            });
            this.getAxisMargins();
            const l2 = 1.1 < f2 / this.plotWidth, h2 = 1.05 < g2 / this.plotHeight;
            if (l2 || h2)
              a3.forEach(function(a4) {
                (a4.horiz && l2 || !a4.horiz && h2) && a4.setTickInterval(true);
              }), this.getMargins();
            this.drawChartBox();
            this.hasCartesianSeries ? d2(a3) : b2 && b2.length && d2(b2);
            this.seriesGroup || (this.seriesGroup = c2.g("series-group").attr({ zIndex: 3 }).shadow(this.options.chart.seriesGroupShadow).add());
            this.renderSeries();
            this.addCredits();
            this.setResponsive && this.setResponsive();
            this.hasRendered = true;
          }
          addCredits(a3) {
            const b2 = this, c2 = J(true, this.options.credits, a3);
            c2.enabled && !this.credits && (this.credits = this.renderer.text(c2.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
              c2.href && (q.location.href = c2.href);
            }).attr({
              align: c2.position.align,
              zIndex: 8
            }), b2.styledMode || this.credits.css(c2.style), this.credits.add().align(c2.position), this.credits.update = function(a4) {
              b2.credits = b2.credits.destroy();
              b2.addCredits(a4);
            });
          }
          destroy() {
            const a3 = this, b2 = a3.axes, c2 = a3.series, d2 = a3.container, e2 = d2 && d2.parentNode;
            let f2;
            Q(a3, "destroy");
            a3.renderer.forExport ? Z(z, a3) : z[a3.index] = void 0;
            E.chartCount--;
            a3.renderTo.removeAttribute("data-highcharts-chart");
            aa(a3);
            for (f2 = b2.length; f2--; )
              b2[f2] = b2[f2].destroy();
            this.scroller && this.scroller.destroy && this.scroller.destroy();
            for (f2 = c2.length; f2--; )
              c2[f2] = c2[f2].destroy();
            "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function(b3) {
              const c3 = a3[b3];
              c3 && c3.destroy && (a3[b3] = c3.destroy());
            });
            d2 && (d2.innerHTML = h.emptyHTML, aa(d2), e2 && O(d2));
            X(a3, function(b3, c3) {
              delete a3[c3];
            });
          }
          firstRender() {
            const a3 = this, b2 = a3.options;
            a3.getContainer();
            a3.resetMargins();
            a3.setChartSize();
            a3.propFromSeries();
            a3.getAxes();
            (fa(b2.series) ? b2.series : []).forEach(function(b3) {
              a3.initSeries(b3);
            });
            a3.linkSeries();
            a3.setSeriesData();
            Q(a3, "beforeRender");
            a3.render();
            a3.pointer.getChartPosition();
            if (!a3.renderer.imgCount && !a3.hasLoaded)
              a3.onload();
            a3.temporaryDisplay(true);
          }
          onload() {
            this.callbacks.concat([this.callback]).forEach(function(a3) {
              a3 && "undefined" !== typeof this.index && a3.apply(this, [this]);
            }, this);
            Q(this, "load");
            Q(this, "render");
            N(this.index) && this.setReflow();
            this.warnIfA11yModuleNotLoaded();
            this.hasLoaded = true;
          }
          warnIfA11yModuleNotLoaded() {
            const { options: a3, title: b2 } = this;
            a3 && !this.accessibility && (this.renderer.boxWrapper.attr({
              role: "img",
              "aria-label": (b2 && b2.element.textContent || "").replace(/</g, "&lt;")
            }), a3.accessibility && false === a3.accessibility.enabled || S('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', false, this));
          }
          addSeries(a3, b2, c2) {
            const d2 = this;
            let e2;
            a3 && (b2 = R(b2, true), Q(d2, "addSeries", { options: a3 }, function() {
              e2 = d2.initSeries(a3);
              d2.isDirtyLegend = true;
              d2.linkSeries();
              e2.enabledDataSorting && e2.setData(a3.data, false);
              Q(d2, "afterAddSeries", { series: e2 });
              b2 && d2.redraw(c2);
            }));
            return e2;
          }
          addAxis(a3, b2, c2, d2) {
            return this.createAxis(b2 ? "xAxis" : "yAxis", { axis: a3, redraw: c2, animation: d2 });
          }
          addColorAxis(a3, b2, c2) {
            return this.createAxis("colorAxis", { axis: a3, redraw: b2, animation: c2 });
          }
          createAxis(a3, b2) {
            a3 = new y(this, J(b2.axis, { index: this[a3].length, isX: "xAxis" === a3 }));
            R(b2.redraw, true) && this.redraw(b2.animation);
            return a3;
          }
          showLoading(a3) {
            const b2 = this, d2 = b2.options, e2 = d2.loading, f2 = function() {
              g2 && L(g2, { left: b2.plotLeft + "px", top: b2.plotTop + "px", width: b2.plotWidth + "px", height: b2.plotHeight + "px" });
            };
            let g2 = b2.loadingDiv, k2 = b2.loadingSpan;
            g2 || (b2.loadingDiv = g2 = l("div", { className: "highcharts-loading highcharts-loading-hidden" }, null, b2.container));
            k2 || (b2.loadingSpan = k2 = l("span", { className: "highcharts-loading-inner" }, null, g2), c(b2, "redraw", f2));
            g2.className = "highcharts-loading";
            h.setElementHTML(k2, R(a3, d2.lang.loading, ""));
            b2.styledMode || (L(g2, U(e2.style, { zIndex: 10 })), L(k2, e2.labelStyle), b2.loadingShown || (L(g2, { opacity: 0, display: "" }), r(g2, { opacity: e2.style.opacity || 0.5 }, { duration: e2.showDuration || 0 })));
            b2.loadingShown = true;
            f2();
          }
          hideLoading() {
            const a3 = this.options, b2 = this.loadingDiv;
            b2 && (b2.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || r(b2, { opacity: 0 }, { duration: a3.loading.hideDuration || 100, complete: function() {
              L(b2, { display: "none" });
            } }));
            this.loadingShown = false;
          }
          update(a3, b2, c2, d2) {
            const e2 = this, f2 = { credits: "addCredits", title: "setTitle", subtitle: "setSubtitle", caption: "setCaption" }, l2 = a3.isResponsiveOptions, h2 = [];
            let k2, q2;
            Q(
              e2,
              "update",
              { options: a3 }
            );
            l2 || e2.setResponsive(false, true);
            a3 = p(a3, e2.options);
            e2.userOptions = J(e2.userOptions, a3);
            var m2 = a3.chart;
            if (m2) {
              J(true, e2.options.chart, m2);
              "className" in m2 && e2.setClassName(m2.className);
              if ("inverted" in m2 || "polar" in m2 || "type" in m2) {
                e2.propFromSeries();
                var n2 = true;
              }
              "alignTicks" in m2 && (n2 = true);
              "events" in m2 && F(this, m2);
              X(m2, function(a4, b3) {
                -1 !== e2.propsRequireUpdateSeries.indexOf("chart." + b3) && (k2 = true);
                -1 !== e2.propsRequireDirtyBox.indexOf(b3) && (e2.isDirtyBox = true);
                -1 !== e2.propsRequireReflow.indexOf(b3) && (l2 ? e2.isDirtyBox = true : q2 = true);
              });
              !e2.styledMode && m2.style && e2.renderer.setStyle(e2.options.chart.style || {});
            }
            !e2.styledMode && a3.colors && (this.options.colors = a3.colors);
            a3.time && (this.time === g && (this.time = new v(a3.time)), J(true, e2.options.time, a3.time));
            X(a3, function(b3, c3) {
              if (e2[c3] && "function" === typeof e2[c3].update)
                e2[c3].update(b3, false);
              else if ("function" === typeof e2[f2[c3]])
                e2[f2[c3]](b3);
              else
                "colors" !== c3 && -1 === e2.collectionsWithUpdate.indexOf(c3) && J(true, e2.options[c3], a3[c3]);
              "chart" !== c3 && -1 !== e2.propsRequireUpdateSeries.indexOf(c3) && (k2 = true);
            });
            this.collectionsWithUpdate.forEach(function(b3) {
              let d3;
              a3[b3] && (d3 = [], e2[b3].forEach(function(a4, b4) {
                a4.options.isInternal || d3.push(R(a4.options.index, b4));
              }), ca(a3[b3]).forEach(function(a4, f3) {
                const g2 = N(a4.id);
                let l3;
                g2 && (l3 = e2.get(a4.id));
                !l3 && e2[b3] && (l3 = e2[b3][d3 ? d3[f3] : f3]) && g2 && N(l3.options.id) && (l3 = void 0);
                l3 && l3.coll === b3 && (l3.update(a4, false), c2 && (l3.touched = true));
                !l3 && c2 && e2.collectionsWithInit[b3] && (e2.collectionsWithInit[b3][0].apply(e2, [a4].concat(e2.collectionsWithInit[b3][1] || []).concat([false])).touched = true);
              }), c2 && e2[b3].forEach(function(a4) {
                a4.touched || a4.options.isInternal ? delete a4.touched : h2.push(a4);
              }));
            });
            h2.forEach(function(a4) {
              a4.chart && a4.remove && a4.remove(false);
            });
            n2 && e2.axes.forEach(function(a4) {
              a4.update({}, false);
            });
            k2 && e2.getSeriesOrderByLinks().forEach(function(a4) {
              a4.chart && a4.update({}, false);
            }, this);
            n2 = m2 && m2.width;
            m2 = m2 && (P(m2.height) ? ha(m2.height, n2 || e2.chartWidth) : m2.height);
            q2 || Y(n2) && n2 !== e2.chartWidth || Y(m2) && m2 !== e2.chartHeight ? e2.setSize(n2, m2, d2) : R(b2, true) && e2.redraw(d2);
            Q(e2, "afterUpdate", { options: a3, redraw: b2, animation: d2 });
          }
          setSubtitle(a3, b2) {
            this.applyDescription("subtitle", a3);
            this.layOutTitles(b2);
          }
          setCaption(a3, b2) {
            this.applyDescription(
              "caption",
              a3
            );
            this.layOutTitles(b2);
          }
          showResetZoom() {
            function a3() {
              b2.zoomOut();
            }
            const b2 = this, c2 = k.lang, d2 = b2.options.chart.zooming.resetButton, e2 = d2.theme, f2 = "chart" === d2.relativeTo || "spacingBox" === d2.relativeTo ? null : "scrollablePlotBox";
            Q(this, "beforeShowResetZoom", null, function() {
              b2.resetZoomButton = b2.renderer.button(c2.resetZoom, null, null, a3, e2).attr({ align: d2.position.align, title: c2.resetZoomTitle }).addClass("highcharts-reset-zoom").add().align(d2.position, false, f2);
            });
            Q(this, "afterShowResetZoom");
          }
          zoomOut() {
            Q(
              this,
              "selection",
              { resetSelection: true },
              this.zoom
            );
          }
          zoom(a3) {
            const b2 = this, c2 = b2.pointer;
            let d2 = false, e2;
            !a3 || a3.resetSelection ? (b2.axes.forEach(function(a4) {
              e2 = a4.zoom();
            }), c2.initiated = false) : a3.xAxis.concat(a3.yAxis).forEach(function(a4) {
              const f3 = a4.axis;
              if (c2[f3.isXAxis ? "zoomX" : "zoomY"] && N(c2.mouseDownX) && N(c2.mouseDownY) && b2.isInsidePlot(c2.mouseDownX - b2.plotLeft, c2.mouseDownY - b2.plotTop, { axis: f3 }) || !N(b2.inverted ? c2.mouseDownX : c2.mouseDownY))
                e2 = f3.zoom(a4.min, a4.max), f3.displayBtn && (d2 = true);
            });
            const f2 = b2.resetZoomButton;
            d2 && !f2 ? b2.showResetZoom() : !d2 && D(f2) && (b2.resetZoomButton = f2.destroy());
            e2 && b2.redraw(R(b2.options.chart.animation, a3 && a3.animation, 100 > b2.pointCount));
          }
          pan(a3, b2) {
            const c2 = this, d2 = c2.hoverPoints;
            b2 = "object" === typeof b2 ? b2 : { enabled: b2, type: "x" };
            const e2 = c2.options.chart;
            e2 && e2.panning && (e2.panning = b2);
            const f2 = b2.type;
            let g2;
            Q(this, "pan", { originalEvent: a3 }, function() {
              d2 && d2.forEach(function(a4) {
                a4.setState();
              });
              let b3 = c2.xAxis;
              "xy" === f2 ? b3 = b3.concat(c2.yAxis) : "y" === f2 && (b3 = c2.yAxis);
              const e3 = {};
              b3.forEach(function(b4) {
                if (b4.options.panningEnabled && !b4.options.isInternal) {
                  var d3 = b4.horiz, l2 = a3[d3 ? "chartX" : "chartY"];
                  d3 = d3 ? "mouseDownX" : "mouseDownY";
                  var h2 = c2[d3], k2 = b4.minPointOffset || 0, p2 = b4.reversed && !c2.inverted || !b4.reversed && c2.inverted ? -1 : 1, m2 = b4.getExtremes(), q2 = b4.toValue(h2 - l2, true) + k2 * p2, n2 = b4.toValue(h2 + b4.len - l2, true) - (k2 * p2 || b4.isXAxis && b4.pointRangePadding || 0), D2 = n2 < q2;
                  p2 = b4.hasVerticalPanning();
                  h2 = D2 ? n2 : q2;
                  q2 = D2 ? q2 : n2;
                  var r2 = b4.panningState;
                  !p2 || b4.isXAxis || r2 && !r2.isDirty || b4.series.forEach(function(a4) {
                    var b5 = a4.getProcessedData(true);
                    b5 = a4.getExtremes(b5.yData, true);
                    r2 || (r2 = { startMin: Number.MAX_VALUE, startMax: -Number.MAX_VALUE });
                    Y(b5.dataMin) && Y(b5.dataMax) && (r2.startMin = Math.min(R(a4.options.threshold, Infinity), b5.dataMin, r2.startMin), r2.startMax = Math.max(R(a4.options.threshold, -Infinity), b5.dataMax, r2.startMax));
                  });
                  p2 = Math.min(R(r2 && r2.startMin, m2.dataMin), k2 ? m2.min : b4.toValue(b4.toPixels(m2.min) - b4.minPixelPadding));
                  n2 = Math.max(R(r2 && r2.startMax, m2.dataMax), k2 ? m2.max : b4.toValue(b4.toPixels(m2.max) + b4.minPixelPadding));
                  b4.panningState = r2;
                  b4.isOrdinal || (k2 = p2 - h2, 0 < k2 && (q2 += k2, h2 = p2), k2 = q2 - n2, 0 < k2 && (q2 = n2, h2 -= k2), b4.series.length && h2 !== m2.min && q2 !== m2.max && h2 >= p2 && q2 <= n2 && (b4.setExtremes(h2, q2, false, false, { trigger: "pan" }), !c2.resetZoomButton && h2 !== p2 && q2 !== n2 && f2.match("y") && (c2.showResetZoom(), b4.displayBtn = false), g2 = true), e3[d3] = l2);
                }
              });
              X(e3, (a4, b4) => {
                c2[b4] = a4;
              });
              g2 && c2.redraw(false);
              L(c2.container, { cursor: "move" });
            });
          }
        }
        U(da.prototype, {
          callbacks: [],
          collectionsWithInit: { xAxis: [da.prototype.addAxis, [true]], yAxis: [da.prototype.addAxis, [false]], series: [da.prototype.addSeries] },
          collectionsWithUpdate: ["xAxis", "yAxis", "series"],
          propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
          propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
          propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
        });
        "";
        return da;
      });
      M(a, "Core/Legend/LegendSymbol.js", [a["Core/Utilities.js"]], function(a2) {
        const { extend: w, merge: H, pick: K } = a2;
        var B;
        (function(a3) {
          a3.drawLineMarker = function(a4) {
            var A = this.legendItem = this.legendItem || {}, u = this.options;
            const v = a4.symbolWidth, f = a4.symbolHeight, h = f / 2, r = this.chart.renderer, m = A.group;
            a4 = a4.baseline - Math.round(0.3 * a4.fontMetrics.b);
            let n = {}, k = u.marker, g = 0;
            this.chart.styledMode || (n = { "stroke-width": Math.min(u.lineWidth || 0, 24) }, u.dashStyle ? n.dashstyle = u.dashStyle : "square" !== u.linecap && (n["stroke-linecap"] = "round"));
            A.line = r.path().addClass("highcharts-graph").attr(n).add(m);
            n["stroke-linecap"] && (g = Math.min(A.line.strokeWidth(), v) / 2);
            v && A.line.attr({ d: [["M", g, a4], ["L", v - g, a4]] });
            k && false !== k.enabled && v && (u = Math.min(K(
              k.radius,
              h
            ), h), 0 === this.symbol.indexOf("url") && (k = H(k, { width: f, height: f }), u = 0), A.symbol = A = r.symbol(this.symbol, v / 2 - u, a4 - u, 2 * u, 2 * u, w({ context: "legend" }, k)).addClass("highcharts-point").add(m), A.isMarker = true);
          };
          a3.drawRectangle = function(a4, w2) {
            w2 = w2.legendItem || {};
            const u = a4.symbolHeight, v = a4.options.squareSymbol;
            w2.symbol = this.chart.renderer.rect(v ? (a4.symbolWidth - u) / 2 : 0, a4.baseline - u + 1, v ? u : a4.symbolWidth, u, K(a4.options.symbolRadius, u / 2)).addClass("highcharts-point").attr({ zIndex: 3 }).add(w2.group);
          };
        })(B || (B = {}));
        return B;
      });
      M(a, "Core/Series/SeriesDefaults.js", [], function() {
        return { lineWidth: 1, allowPointSelect: false, crisp: true, showCheckbox: false, animation: { duration: 1e3 }, events: {}, marker: { enabledThreshold: 2, lineColor: "#ffffff", lineWidth: 0, radius: 4, states: { normal: { animation: true }, hover: { animation: { duration: 150 }, enabled: true, radiusPlus: 2, lineWidthPlus: 1 }, select: { fillColor: "#cccccc", lineColor: "#000000", lineWidth: 2 } } }, point: { events: {} }, dataLabels: { animation: {}, align: "center", borderWidth: 0, defer: true, formatter: function() {
          const { numberFormatter: a2 } = this.series.chart;
          return "number" !== typeof this.y ? "" : a2(this.y, -1);
        }, padding: 5, style: { fontSize: "0.7em", fontWeight: "bold", color: "contrast", textOutline: "1px contrast" }, verticalAlign: "bottom", x: 0, y: 0 }, cropThreshold: 300, opacity: 1, pointRange: 0, softThreshold: true, states: { normal: { animation: true }, hover: { animation: { duration: 150 }, lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: 0.25 } }, select: { animation: { duration: 0 } }, inactive: { animation: { duration: 150 }, opacity: 0.2 } }, stickyTracking: true, turboThreshold: 1e3, findNearestPointBy: "x" };
      });
      M(a, "Core/Series/Series.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Defaults.js"], a["Core/Foundation.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/Point.js"], a["Core/Series/SeriesDefaults.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function(a2, y, H, K, B, E, C, A, u, v) {
        const { animObject: f, setAnimation: h } = a2, { defaultOptions: r } = y, { registerEventOptions: m } = H, { hasTouch: n, svg: k, win: g } = K, { seriesTypes: w } = A, {
          arrayMax: F,
          arrayMin: z,
          clamp: e,
          cleanRecursively: t,
          correctFloat: d,
          defined: q,
          erase: x,
          error: c,
          extend: b,
          find: p,
          fireEvent: l,
          getNestedProperty: L,
          isArray: N,
          isNumber: O,
          isString: Z,
          merge: S,
          objectEach: U,
          pick: G,
          removeEvent: Q,
          splat: M2,
          syncTimeout: fa
        } = v;
        class Y {
          constructor() {
            this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
          }
          init(a3, c2) {
            l(
              this,
              "init",
              { options: c2 }
            );
            const d2 = this, e2 = a3.series;
            this.eventsToUnbind = [];
            d2.chart = a3;
            d2.options = d2.setOptions(c2);
            c2 = d2.options;
            d2.linkedSeries = [];
            d2.bindAxes();
            b(d2, { name: c2.name, state: "", visible: false !== c2.visible, selected: true === c2.selected });
            m(this, c2);
            const f2 = c2.events;
            if (f2 && f2.click || c2.point && c2.point.events && c2.point.events.click || c2.allowPointSelect)
              a3.runTrackerClick = true;
            d2.getColor();
            d2.getSymbol();
            d2.parallelArrays.forEach(function(a4) {
              d2[a4 + "Data"] || (d2[a4 + "Data"] = []);
            });
            d2.isCartesian && (a3.hasCartesianSeries = true);
            let g2;
            e2.length && (g2 = e2[e2.length - 1]);
            d2._i = G(g2 && g2._i, -1) + 1;
            d2.opacity = d2.options.opacity;
            a3.orderSeries(this.insert(e2));
            c2.dataSorting && c2.dataSorting.enabled ? d2.setDataSortingOptions() : d2.points || d2.data || d2.setData(c2.data, false);
            l(this, "afterInit");
          }
          is(a3) {
            return w[a3] && this instanceof w[a3];
          }
          insert(a3) {
            const b2 = this.options.index;
            let c2;
            if (O(b2)) {
              for (c2 = a3.length; c2--; )
                if (b2 >= G(a3[c2].options.index, a3[c2]._i)) {
                  a3.splice(c2 + 1, 0, this);
                  break;
                }
              -1 === c2 && a3.unshift(this);
              c2 += 1;
            } else
              a3.push(this);
            return G(c2, a3.length - 1);
          }
          bindAxes() {
            const a3 = this, b2 = a3.options, d2 = a3.chart;
            let e2;
            l(this, "bindAxes", null, function() {
              (a3.axisTypes || []).forEach(function(f2) {
                let g2 = 0;
                d2[f2].forEach(function(c2) {
                  e2 = c2.options;
                  if (b2[f2] === g2 && !e2.isInternal || "undefined" !== typeof b2[f2] && b2[f2] === e2.id || "undefined" === typeof b2[f2] && 0 === e2.index)
                    a3.insert(c2.series), a3[f2] = c2, c2.isDirty = true;
                  e2.isInternal || g2++;
                });
                a3[f2] || a3.optionalAxis === f2 || c(18, true, d2);
              });
            });
            l(this, "afterBindAxes");
          }
          updateParallelArrays(a3, b2, c2) {
            const d2 = a3.series, e2 = O(b2) ? function(c3) {
              const e3 = "y" === c3 && d2.toYData ? d2.toYData(a3) : a3[c3];
              d2[c3 + "Data"][b2] = e3;
            } : function(a4) {
              Array.prototype[b2].apply(d2[a4 + "Data"], c2);
            };
            d2.parallelArrays.forEach(e2);
          }
          hasData() {
            return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
          }
          autoIncrement(a3) {
            var b2 = this.options;
            const c2 = b2.pointIntervalUnit, d2 = b2.relativeXValue, e2 = this.chart.time;
            let f2 = this.xIncrement, g2;
            f2 = G(f2, b2.pointStart, 0);
            this.pointInterval = g2 = G(this.pointInterval, b2.pointInterval, 1);
            d2 && O(a3) && (g2 *= a3);
            c2 && (b2 = new e2.Date(f2), "day" === c2 ? e2.set("Date", b2, e2.get("Date", b2) + g2) : "month" === c2 ? e2.set(
              "Month",
              b2,
              e2.get("Month", b2) + g2
            ) : "year" === c2 && e2.set("FullYear", b2, e2.get("FullYear", b2) + g2), g2 = b2.getTime() - f2);
            if (d2 && O(a3))
              return f2 + g2;
            this.xIncrement = f2 + g2;
            return f2;
          }
          setDataSortingOptions() {
            const a3 = this.options;
            b(this, { requireSorting: false, sorted: false, enabledDataSorting: true, allowDG: false });
            q(a3.pointRange) || (a3.pointRange = 1);
          }
          setOptions(a3) {
            var b2 = this.chart, c2 = b2.options, d2 = c2.plotOptions, e2 = b2.userOptions || {};
            a3 = S(a3);
            b2 = b2.styledMode;
            const f2 = { plotOptions: d2, userOptions: a3 };
            l(this, "setOptions", f2);
            const g2 = f2.plotOptions[this.type], h2 = e2.plotOptions || {};
            this.userOptions = f2.userOptions;
            e2 = S(g2, d2.series, e2.plotOptions && e2.plotOptions[this.type], a3);
            this.tooltipOptions = S(r.tooltip, r.plotOptions.series && r.plotOptions.series.tooltip, r.plotOptions[this.type].tooltip, c2.tooltip.userOptions, d2.series && d2.series.tooltip, d2[this.type].tooltip, a3.tooltip);
            this.stickyTracking = G(a3.stickyTracking, h2[this.type] && h2[this.type].stickyTracking, h2.series && h2.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : e2.stickyTracking);
            null === g2.marker && delete e2.marker;
            this.zoneAxis = e2.zoneAxis;
            d2 = this.zones = (e2.zones || []).slice();
            !e2.negativeColor && !e2.negativeFillColor || e2.zones || (c2 = { value: e2[this.zoneAxis + "Threshold"] || e2.threshold || 0, className: "highcharts-negative" }, b2 || (c2.color = e2.negativeColor, c2.fillColor = e2.negativeFillColor), d2.push(c2));
            d2.length && q(d2[d2.length - 1].value) && d2.push(b2 ? {} : { color: this.color, fillColor: this.fillColor });
            l(this, "afterSetOptions", { options: e2 });
            return e2;
          }
          getName() {
            return G(this.options.name, "Series " + (this.index + 1));
          }
          getCyclic(a3, b2, c2) {
            const d2 = this.chart, e2 = this.userOptions, f2 = a3 + "Index", g2 = a3 + "Counter", l2 = c2 ? c2.length : G(d2.options.chart[a3 + "Count"], d2[a3 + "Count"]);
            if (!b2) {
              var h2 = G(e2[f2], e2["_" + f2]);
              q(h2) || (d2.series.length || (d2[g2] = 0), e2["_" + f2] = h2 = d2[g2] % l2, d2[g2] += 1);
              c2 && (b2 = c2[h2]);
            }
            "undefined" !== typeof h2 && (this[f2] = h2);
            this[a3] = b2;
          }
          getColor() {
            this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || r.plotOptions[this.type].color, this.chart.options.colors);
          }
          getPointsCollection() {
            return (this.hasGroupedData ? this.points : this.data) || [];
          }
          getSymbol() {
            this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
          }
          findPointIndex(a3, b2) {
            const c2 = a3.id, d2 = a3.x, e2 = this.points;
            var f2 = this.options.dataSorting, g2;
            let l2, h2;
            if (c2)
              f2 = this.chart.get(c2), f2 instanceof E && (g2 = f2);
            else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
              if (g2 = (b3) => !b3.touched && b3.index === a3.index, f2 && f2.matchByName ? g2 = (b3) => !b3.touched && b3.name === a3.name : this.options.relativeXValue && (g2 = (b3) => !b3.touched && b3.options.x === a3.x), g2 = p(e2, g2), !g2)
                return;
            }
            g2 && (h2 = g2 && g2.index, "undefined" !== typeof h2 && (l2 = true));
            "undefined" === typeof h2 && O(d2) && (h2 = this.xData.indexOf(d2, b2));
            -1 !== h2 && "undefined" !== typeof h2 && this.cropped && (h2 = h2 >= this.cropStart ? h2 - this.cropStart : h2);
            !l2 && O(h2) && e2[h2] && e2[h2].touched && (h2 = void 0);
            return h2;
          }
          updateData(a3, b2) {
            const c2 = this.options, d2 = c2.dataSorting, e2 = this.points, f2 = [], g2 = this.requireSorting, l2 = a3.length === e2.length;
            let h2, k2, p2, m2 = true;
            this.xIncrement = null;
            a3.forEach(function(a4, b3) {
              var k3 = q(a4) && this.pointClass.prototype.optionsToObject.call(
                { series: this },
                a4
              ) || {};
              const m3 = k3.x;
              if (k3.id || O(m3)) {
                if (k3 = this.findPointIndex(k3, p2), -1 === k3 || "undefined" === typeof k3 ? f2.push(a4) : e2[k3] && a4 !== c2.data[k3] ? (e2[k3].update(a4, false, null, false), e2[k3].touched = true, g2 && (p2 = k3 + 1)) : e2[k3] && (e2[k3].touched = true), !l2 || b3 !== k3 || d2 && d2.enabled || this.hasDerivedData)
                  h2 = true;
              } else
                f2.push(a4);
            }, this);
            if (h2)
              for (a3 = e2.length; a3--; )
                (k2 = e2[a3]) && !k2.touched && k2.remove && k2.remove(false, b2);
            else
              !l2 || d2 && d2.enabled ? m2 = false : (a3.forEach(function(a4, b3) {
                a4 === e2[b3].y || e2[b3].destroyed || e2[b3].update(a4, false, null, false);
              }), f2.length = 0);
            e2.forEach(function(a4) {
              a4 && (a4.touched = false);
            });
            if (!m2)
              return false;
            f2.forEach(function(a4) {
              this.addPoint(a4, false, null, null, false);
            }, this);
            null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = F(this.xData), this.autoIncrement());
            return true;
          }
          setData(a3, b2 = true, d2, e2) {
            var f2;
            const g2 = this, l2 = g2.points, h2 = l2 && l2.length || 0, k2 = g2.options, p2 = g2.chart, m2 = k2.dataSorting, q2 = g2.xAxis, n2 = k2.turboThreshold, r2 = this.xData, t2 = this.yData;
            var D = g2.pointArrayMap;
            D = D && D.length;
            const x2 = k2.keys;
            let v2, u2 = 0, J = 1, z2 = null;
            if (!p2.options.chart.allowMutatingData) {
              k2.data && delete g2.options.data;
              g2.userOptions.data && delete g2.userOptions.data;
              var w2 = S(true, a3);
            }
            a3 = w2 || a3 || [];
            w2 = a3.length;
            m2 && m2.enabled && (a3 = this.sortData(a3));
            p2.options.chart.allowMutatingData && false !== e2 && w2 && h2 && !g2.cropped && !g2.hasGroupedData && g2.visible && !g2.boosted && (v2 = this.updateData(a3, d2));
            if (!v2) {
              g2.xIncrement = null;
              g2.colorCounter = 0;
              this.parallelArrays.forEach(function(a4) {
                g2[a4 + "Data"].length = 0;
              });
              if (n2 && w2 > n2)
                if (z2 = g2.getFirstValidPoint(a3), O(z2))
                  for (d2 = 0; d2 < w2; d2++)
                    r2[d2] = this.autoIncrement(), t2[d2] = a3[d2];
                else if (N(z2))
                  if (D)
                    if (z2.length === D)
                      for (d2 = 0; d2 < w2; d2++)
                        r2[d2] = this.autoIncrement(), t2[d2] = a3[d2];
                    else
                      for (d2 = 0; d2 < w2; d2++)
                        e2 = a3[d2], r2[d2] = e2[0], t2[d2] = e2.slice(1, D + 1);
                  else if (x2 && (u2 = x2.indexOf("x"), J = x2.indexOf("y"), u2 = 0 <= u2 ? u2 : 0, J = 0 <= J ? J : 1), 1 === z2.length && (J = 0), u2 === J)
                    for (d2 = 0; d2 < w2; d2++)
                      r2[d2] = this.autoIncrement(), t2[d2] = a3[d2][J];
                  else
                    for (d2 = 0; d2 < w2; d2++)
                      e2 = a3[d2], r2[d2] = e2[u2], t2[d2] = e2[J];
                else
                  c(12, false, p2);
              else
                for (d2 = 0; d2 < w2; d2++)
                  e2 = { series: g2 }, g2.pointClass.prototype.applyOptions.apply(e2, [a3[d2]]), g2.updateParallelArrays(e2, d2);
              t2 && Z(t2[0]) && c(14, true, p2);
              g2.data = [];
              g2.options.data = g2.userOptions.data = a3;
              for (d2 = h2; d2--; )
                null === (f2 = l2[d2]) || void 0 === f2 ? void 0 : f2.destroy();
              q2 && (q2.minRange = q2.userMinRange);
              g2.isDirty = p2.isDirtyBox = true;
              g2.isDirtyData = !!l2;
              d2 = false;
            }
            "point" === k2.legendType && (this.processData(), this.generatePoints());
            b2 && p2.redraw(d2);
          }
          sortData(a3) {
            const b2 = this, c2 = b2.options.dataSorting.sortKey || "y", d2 = function(a4, b3) {
              return q(b3) && a4.pointClass.prototype.optionsToObject.call({ series: a4 }, b3) || {};
            };
            a3.forEach(function(c3, e2) {
              a3[e2] = d2(b2, c3);
              a3[e2].index = e2;
            }, this);
            a3.concat().sort((a4, b3) => {
              a4 = L(c2, a4);
              b3 = L(c2, b3);
              return b3 < a4 ? -1 : b3 > a4 ? 1 : 0;
            }).forEach(function(a4, b3) {
              a4.x = b3;
            }, this);
            b2.linkedSeries && b2.linkedSeries.forEach(function(b3) {
              const c3 = b3.options, e2 = c3.data;
              c3.dataSorting && c3.dataSorting.enabled || !e2 || (e2.forEach(function(c4, f2) {
                e2[f2] = d2(b3, c4);
                a3[f2] && (e2[f2].x = a3[f2].x, e2[f2].index = f2);
              }), b3.setData(e2, false));
            });
            return a3;
          }
          getProcessedData(a3) {
            var b2 = this.xAxis, d2 = this.options, e2 = d2.cropThreshold;
            const f2 = a3 || this.getExtremesFromAll || d2.getExtremesFromAll, g2 = this.isCartesian;
            a3 = b2 && b2.val2lin;
            d2 = !(!b2 || !b2.logarithmic);
            let l2 = 0, h2;
            let k2, p2, m2 = this.xData, q2 = this.yData, n2 = this.requireSorting;
            var r2 = false;
            const t2 = m2.length;
            b2 && (r2 = b2.getExtremes(), k2 = r2.min, p2 = r2.max, r2 = !(!b2.categories || b2.names.length));
            if (g2 && this.sorted && !f2 && (!e2 || t2 > e2 || this.forceCrop)) {
              if (m2[t2 - 1] < k2 || m2[0] > p2)
                m2 = [], q2 = [];
              else if (this.yData && (m2[0] < k2 || m2[t2 - 1] > p2)) {
                var D = this.cropData(this.xData, this.yData, k2, p2);
                m2 = D.xData;
                q2 = D.yData;
                l2 = D.start;
                D = true;
              }
            }
            for (e2 = m2.length || 1; --e2; )
              b2 = d2 ? a3(m2[e2]) - a3(m2[e2 - 1]) : m2[e2] - m2[e2 - 1], 0 < b2 && ("undefined" === typeof h2 || b2 < h2) ? h2 = b2 : 0 > b2 && n2 && !r2 && (c(15, false, this.chart), n2 = false);
            return { xData: m2, yData: q2, cropped: D, cropStart: l2, closestPointRange: h2 };
          }
          processData(a3) {
            const b2 = this.xAxis;
            if (this.isCartesian && !this.isDirty && !b2.isDirty && !this.yAxis.isDirty && !a3)
              return false;
            a3 = this.getProcessedData();
            this.cropped = a3.cropped;
            this.cropStart = a3.cropStart;
            this.processedXData = a3.xData;
            this.processedYData = a3.yData;
            this.closestPointRange = this.basePointRange = a3.closestPointRange;
            l(this, "afterProcessData");
          }
          cropData(a3, b2, c2, d2, e2) {
            const f2 = a3.length;
            let g2, l2 = 0, h2 = f2;
            e2 = G(e2, this.cropShoulder);
            for (g2 = 0; g2 < f2; g2++)
              if (a3[g2] >= c2) {
                l2 = Math.max(0, g2 - e2);
                break;
              }
            for (c2 = g2; c2 < f2; c2++)
              if (a3[c2] > d2) {
                h2 = c2 + e2;
                break;
              }
            return { xData: a3.slice(l2, h2), yData: b2.slice(
              l2,
              h2
            ), start: l2, end: h2 };
          }
          generatePoints() {
            var a3 = this.options;
            const c2 = this.processedData || a3.data, d2 = this.processedXData, e2 = this.processedYData, f2 = this.pointClass, g2 = d2.length, h2 = this.cropStart || 0, k2 = this.hasGroupedData, p2 = a3.keys, m2 = [];
            a3 = a3.dataGrouping && a3.dataGrouping.groupAll ? h2 : 0;
            let q2;
            let n2, r2, t2 = this.data;
            if (!t2 && !k2) {
              var x2 = [];
              x2.length = c2.length;
              t2 = this.data = x2;
            }
            p2 && k2 && (this.options.keys = false);
            for (r2 = 0; r2 < g2; r2++)
              x2 = h2 + r2, k2 ? (n2 = new f2().init(this, [d2[r2]].concat(M2(e2[r2]))), n2.dataGroup = this.groupMap[a3 + r2], n2.dataGroup.options && (n2.options = n2.dataGroup.options, b(n2, n2.dataGroup.options), delete n2.dataLabels)) : (n2 = t2[x2]) || "undefined" === typeof c2[x2] || (t2[x2] = n2 = new f2().init(this, c2[x2], d2[r2])), n2 && (n2.index = k2 ? a3 + r2 : x2, m2[r2] = n2);
            this.options.keys = p2;
            if (t2 && (g2 !== (q2 = t2.length) || k2))
              for (r2 = 0; r2 < q2; r2++)
                r2 !== h2 || k2 || (r2 += g2), t2[r2] && (t2[r2].destroyElements(), t2[r2].plotX = void 0);
            this.data = t2;
            this.points = m2;
            l(this, "afterGeneratePoints");
          }
          getXExtremes(a3) {
            return { min: z(a3), max: F(a3) };
          }
          getExtremes(a3, b2) {
            const c2 = this.xAxis;
            var d2 = this.yAxis;
            const e2 = this.processedXData || this.xData, f2 = [], g2 = this.requireSorting ? this.cropShoulder : 0;
            d2 = d2 ? d2.positiveValuesOnly : false;
            let h2, k2 = 0, p2 = 0, m2 = 0;
            a3 = a3 || this.stackedYData || this.processedYData || [];
            const q2 = a3.length;
            if (c2) {
              var n2 = c2.getExtremes();
              k2 = n2.min;
              p2 = n2.max;
            }
            for (h2 = 0; h2 < q2; h2++) {
              var r2 = e2[h2];
              n2 = a3[h2];
              var t2 = (O(n2) || N(n2)) && (n2.length || 0 < n2 || !d2);
              r2 = b2 || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !c2 || (e2[h2 + g2] || r2) >= k2 && (e2[h2 - g2] || r2) <= p2;
              if (t2 && r2)
                if (t2 = n2.length)
                  for (; t2--; )
                    O(n2[t2]) && (f2[m2++] = n2[t2]);
                else
                  f2[m2++] = n2;
            }
            a3 = { activeYData: f2, dataMin: z(f2), dataMax: F(f2) };
            l(
              this,
              "afterGetExtremes",
              { dataExtremes: a3 }
            );
            return a3;
          }
          applyExtremes() {
            const a3 = this.getExtremes();
            this.dataMin = a3.dataMin;
            this.dataMax = a3.dataMax;
            return a3;
          }
          getFirstValidPoint(a3) {
            const b2 = a3.length;
            let c2 = 0, d2 = null;
            for (; null === d2 && c2 < b2; )
              d2 = a3[c2], c2++;
            return d2;
          }
          translate() {
            var a3;
            this.processedXData || this.processData();
            this.generatePoints();
            const b2 = this.options, c2 = b2.stacking, f2 = this.xAxis, g2 = f2.categories, h2 = this.enabledDataSorting, k2 = this.yAxis, p2 = this.points, m2 = p2.length, n2 = this.pointPlacementToXValue(), r2 = !!n2, t2 = b2.threshold, x2 = b2.startFromThreshold ? t2 : 0, v2 = this.zoneAxis || "y";
            let u2, z2, w2, F2, L2 = Number.MAX_VALUE;
            for (u2 = 0; u2 < m2; u2++) {
              const l2 = p2[u2], m3 = l2.x;
              let D, J, P = l2.y, I = l2.low;
              const A2 = c2 && (null === (a3 = k2.stacking) || void 0 === a3 ? void 0 : a3.stacks[(this.negStacks && P < (x2 ? 0 : t2) ? "-" : "") + this.stackKey]);
              z2 = f2.translate(m3, false, false, false, true, n2);
              l2.plotX = O(z2) ? d(e(z2, -1e5, 1e5)) : void 0;
              c2 && this.visible && A2 && A2[m3] && (F2 = this.getStackIndicator(F2, m3, this.index), !l2.isNull && F2.key && (D = A2[m3], J = D.points[F2.key]), D && N(J) && (I = J[0], P = J[1], I === x2 && F2.key === A2[m3].base && (I = G(O(t2) ? t2 : k2.min)), k2.positiveValuesOnly && q(I) && 0 >= I && (I = void 0), l2.total = l2.stackTotal = G(D.total), l2.percentage = q(l2.y) && D.total ? l2.y / D.total * 100 : void 0, l2.stackY = P, this.irregularWidths || D.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis)));
              l2.yBottom = q(I) ? e(k2.translate(I, false, true, false, true), -1e5, 1e5) : void 0;
              this.dataModify && (P = this.dataModify.modifyValue(P, u2));
              let y2;
              O(P) && void 0 !== l2.plotX && (y2 = k2.translate(P, false, true, false, true), y2 = O(y2) ? e(y2, -1e5, 1e5) : void 0);
              l2.plotY = y2;
              l2.isInside = this.isPointInside(l2);
              l2.clientX = r2 ? d(f2.translate(
                m3,
                false,
                false,
                false,
                true,
                n2
              )) : z2;
              l2.negative = l2[v2] < (b2[v2 + "Threshold"] || t2 || 0);
              l2.category = G(g2 && g2[l2.x], l2.x);
              l2.isNull || false === l2.visible || ("undefined" !== typeof w2 && (L2 = Math.min(L2, Math.abs(z2 - w2))), w2 = z2);
              l2.zone = this.zones.length ? l2.getZone() : void 0;
              !l2.graphic && this.group && h2 && (l2.isNew = true);
            }
            this.closestPointRangePx = L2;
            l(this, "afterTranslate");
          }
          getValidPoints(a3, b2, c2) {
            const d2 = this.chart;
            return (a3 || this.points || []).filter(function(a4) {
              const { plotX: e2, plotY: f2 } = a4;
              return !c2 && (a4.isNull || !O(f2)) || b2 && !d2.isInsidePlot(e2, f2, { inverted: d2.inverted }) ? false : false !== a4.visible;
            });
          }
          getClipBox() {
            const {
              chart: a3,
              xAxis: b2,
              yAxis: c2
            } = this, d2 = S(a3.clipBox);
            b2 && b2.len !== a3.plotSizeX && (d2.width = b2.len);
            c2 && c2.len !== a3.plotSizeY && (d2.height = c2.len);
            return d2;
          }
          getSharedClipKey() {
            return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
          }
          setClip() {
            const { chart: a3, group: b2, markerGroup: c2 } = this, d2 = a3.sharedClips, e2 = a3.renderer, f2 = this.getClipBox(), g2 = this.getSharedClipKey();
            let l2 = d2[g2];
            l2 ? l2.animate(f2) : d2[g2] = l2 = e2.clipRect(f2);
            b2 && b2.clip(false === this.options.clip ? void 0 : l2);
            c2 && c2.clip();
          }
          animate(a3) {
            const { chart: b2, group: c2, markerGroup: d2 } = this, e2 = b2.inverted;
            var g2 = f(this.options.animation), l2 = [this.getSharedClipKey(), g2.duration, g2.easing, g2.defer].join();
            let h2 = b2.sharedClips[l2], k2 = b2.sharedClips[l2 + "m"];
            if (a3 && c2)
              g2 = this.getClipBox(), h2 ? h2.attr("height", g2.height) : (g2.width = 0, e2 && (g2.x = b2.plotHeight), h2 = b2.renderer.clipRect(g2), b2.sharedClips[l2] = h2, k2 = b2.renderer.clipRect({ x: -99, y: -99, width: e2 ? b2.plotWidth + 199 : 99, height: e2 ? 99 : b2.plotHeight + 199 }), b2.sharedClips[l2 + "m"] = k2), c2.clip(h2), d2 && d2.clip(k2);
            else if (h2 && !h2.hasClass("highcharts-animating")) {
              l2 = this.getClipBox();
              const a4 = g2.step;
              d2 && d2.element.childNodes.length && (g2.step = function(b3, c3) {
                a4 && a4.apply(c3, arguments);
                "width" === c3.prop && k2 && k2.element && k2.attr(e2 ? "height" : "width", b3 + 99);
              });
              h2.addClass("highcharts-animating").animate(l2, g2);
            }
          }
          afterAnimate() {
            this.setClip();
            U(this.chart.sharedClips, (a3, b2, c2) => {
              a3 && !this.chart.container.querySelector(`[clip-path="url(#${a3.id})"]`) && (a3.destroy(), delete c2[b2]);
            });
            this.finishedAnimating = true;
            l(this, "afterAnimate");
          }
          drawPoints(a3 = this.points) {
            const b2 = this.chart, c2 = b2.styledMode, { colorAxis: d2, options: e2 } = this, f2 = e2.marker, g2 = this[this.specialGroup || "markerGroup"], l2 = this.xAxis, h2 = G(f2.enabled, !l2 || l2.isRadial ? true : null, this.closestPointRangePx >= f2.enabledThreshold * f2.radius);
            let k2, p2, m2, q2;
            let n2, r2;
            if (false !== f2.enabled || this._hasPointMarkers)
              for (k2 = 0; k2 < a3.length; k2++) {
                p2 = a3[k2];
                q2 = (m2 = p2.graphic) ? "animate" : "attr";
                var t2 = p2.marker || {};
                n2 = !!p2.marker;
                if ((h2 && "undefined" === typeof t2.enabled || t2.enabled) && !p2.isNull && false !== p2.visible) {
                  const a4 = G(t2.symbol, this.symbol, "rect");
                  r2 = this.markerAttribs(p2, p2.selected && "select");
                  this.enabledDataSorting && (p2.startXPos = l2.reversed ? -(r2.width || 0) : l2.width);
                  const e3 = false !== p2.isInside;
                  !m2 && e3 && (0 < (r2.width || 0) || p2.hasImage) && (p2.graphic = m2 = b2.renderer.symbol(a4, r2.x, r2.y, r2.width, r2.height, n2 ? t2 : f2).add(g2), this.enabledDataSorting && b2.hasRendered && (m2.attr({ x: p2.startXPos }), q2 = "animate"));
                  m2 && "animate" === q2 && m2[e3 ? "show" : "hide"](e3).animate(r2);
                  if (m2)
                    if (t2 = this.pointAttribs(p2, c2 || !p2.selected ? void 0 : "select"), c2)
                      d2 && m2.css({ fill: t2.fill });
                    else
                      m2[q2](t2);
                  m2 && m2.addClass(p2.getClassName(), true);
                } else
                  m2 && (p2.graphic = m2.destroy());
              }
          }
          markerAttribs(a3, b2) {
            const c2 = this.options;
            var d2 = c2.marker;
            const e2 = a3.marker || {}, f2 = e2.symbol || d2.symbol, g2 = {};
            let l2 = G(e2.radius, d2 && d2.radius);
            b2 && (d2 = d2.states[b2], b2 = e2.states && e2.states[b2], l2 = G(b2 && b2.radius, d2 && d2.radius, l2 && l2 + (d2 && d2.radiusPlus || 0)));
            a3.hasImage = f2 && 0 === f2.indexOf("url");
            a3.hasImage && (l2 = 0);
            a3 = a3.pos();
            O(l2) && a3 && (g2.x = a3[0] - l2, g2.y = a3[1] - l2, c2.crisp && (g2.x = Math.floor(g2.x)));
            l2 && (g2.width = g2.height = 2 * l2);
            return g2;
          }
          pointAttribs(a3, b2) {
            var c2 = this.options.marker, d2 = a3 && a3.options;
            const e2 = d2 && d2.marker || {};
            var f2 = d2 && d2.color, g2 = a3 && a3.color;
            const l2 = a3 && a3.zone && a3.zone.color;
            let h2 = this.color;
            a3 = G(e2.lineWidth, c2.lineWidth);
            d2 = 1;
            h2 = f2 || l2 || g2 || h2;
            f2 = e2.fillColor || c2.fillColor || h2;
            g2 = e2.lineColor || c2.lineColor || h2;
            b2 = b2 || "normal";
            c2 = c2.states[b2] || {};
            b2 = e2.states && e2.states[b2] || {};
            a3 = G(b2.lineWidth, c2.lineWidth, a3 + G(b2.lineWidthPlus, c2.lineWidthPlus, 0));
            f2 = b2.fillColor || c2.fillColor || f2;
            g2 = b2.lineColor || c2.lineColor || g2;
            d2 = G(b2.opacity, c2.opacity, d2);
            return { stroke: g2, "stroke-width": a3, fill: f2, opacity: d2 };
          }
          destroy(a3) {
            const b2 = this, c2 = b2.chart, d2 = /AppleWebKit\/533/.test(g.navigator.userAgent), e2 = b2.data || [];
            let f2, h2, k2, p2;
            l(
              b2,
              "destroy",
              { keepEventsForUpdate: a3 }
            );
            this.removeEvents(a3);
            (b2.axisTypes || []).forEach(function(a4) {
              (p2 = b2[a4]) && p2.series && (x(p2.series, b2), p2.isDirty = p2.forceRedraw = true);
            });
            b2.legendItem && b2.chart.legend.destroyItem(b2);
            for (h2 = e2.length; h2--; )
              (k2 = e2[h2]) && k2.destroy && k2.destroy();
            b2.clips && b2.clips.forEach((a4) => a4.destroy());
            v.clearTimeout(b2.animationTimeout);
            U(b2, function(a4, b3) {
              a4 instanceof u && !a4.survive && (f2 = d2 && "group" === b3 ? "hide" : "destroy", a4[f2]());
            });
            c2.hoverSeries === b2 && (c2.hoverSeries = void 0);
            x(c2.series, b2);
            c2.orderSeries();
            U(b2, function(c3, d3) {
              a3 && "hcEvents" === d3 || delete b2[d3];
            });
          }
          applyZones() {
            const a3 = this, b2 = this.chart, c2 = b2.renderer, d2 = this.zones, f2 = this.clips || [], g2 = this.graph, l2 = this.area, h2 = Math.max(b2.plotWidth, b2.plotHeight), k2 = this[(this.zoneAxis || "y") + "Axis"], p2 = b2.inverted;
            let m2, q2, n2, r2, t2, x2, v2, u2, z2, w2, F2, L2 = false;
            d2.length && (g2 || l2) && k2 && "undefined" !== typeof k2.min ? (t2 = k2.reversed, x2 = k2.horiz, g2 && !this.showLine && g2.hide(), l2 && l2.hide(), r2 = k2.getExtremes(), d2.forEach(function(d3, D) {
              m2 = t2 ? x2 ? b2.plotWidth : 0 : x2 ? 0 : k2.toPixels(r2.min) || 0;
              m2 = e(G(q2, m2), 0, h2);
              q2 = e(Math.round(k2.toPixels(G(
                d3.value,
                r2.max
              ), true) || 0), 0, h2);
              L2 && (m2 = q2 = k2.toPixels(r2.max));
              v2 = Math.abs(m2 - q2);
              u2 = Math.min(m2, q2);
              z2 = Math.max(m2, q2);
              k2.isXAxis ? (n2 = { x: p2 ? z2 : u2, y: 0, width: v2, height: h2 }, x2 || (n2.x = b2.plotHeight - n2.x)) : (n2 = { x: 0, y: p2 ? z2 : u2, width: h2, height: v2 }, x2 && (n2.y = b2.plotWidth - n2.y));
              f2[D] ? f2[D].animate(n2) : f2[D] = c2.clipRect(n2);
              w2 = a3["zone-area-" + D];
              F2 = a3["zone-graph-" + D];
              g2 && F2 && F2.clip(f2[D]);
              l2 && w2 && w2.clip(f2[D]);
              L2 = d3.value > r2.max;
              a3.resetZones && 0 === q2 && (q2 = void 0);
            }), this.clips = f2) : a3.visible && (g2 && g2.show(), l2 && l2.show());
          }
          plotGroup(a3, b2, c2, d2, e2) {
            let f2 = this[a3];
            const g2 = !f2;
            c2 = {
              visibility: c2,
              zIndex: d2 || 0.1
            };
            "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (c2.opacity = this.opacity);
            g2 && (this[a3] = f2 = this.chart.renderer.g().add(e2));
            f2.addClass("highcharts-" + b2 + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (q(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (f2.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true);
            f2.attr(c2)[g2 ? "attr" : "animate"](this.getPlotBox(b2));
            return f2;
          }
          getPlotBox(a3) {
            let b2 = this.xAxis, c2 = this.yAxis;
            const d2 = this.chart;
            a3 = d2.inverted && !d2.polar && b2 && false !== this.invertible && "series" === a3;
            d2.inverted && (b2 = c2, c2 = this.xAxis);
            return { translateX: b2 ? b2.left : d2.plotLeft, translateY: c2 ? c2.top : d2.plotTop, rotation: a3 ? 90 : 0, rotationOriginX: a3 ? (b2.len - c2.len) / 2 : 0, rotationOriginY: a3 ? (b2.len + c2.len) / 2 : 0, scaleX: a3 ? -1 : 1, scaleY: 1 };
          }
          removeEvents(a3) {
            a3 || Q(this);
            this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function(a4) {
              a4();
            }), this.eventsToUnbind.length = 0);
          }
          render() {
            const a3 = this;
            var b2 = a3.chart;
            const c2 = a3.options, d2 = f(c2.animation), e2 = a3.visible ? "inherit" : "hidden", g2 = c2.zIndex, h2 = a3.hasRendered;
            b2 = b2.seriesGroup;
            let k2 = a3.finishedAnimating ? 0 : d2.duration;
            l(this, "render");
            a3.plotGroup("group", "series", e2, g2, b2);
            a3.markerGroup = a3.plotGroup("markerGroup", "markers", e2, g2, b2);
            false !== c2.clip && a3.setClip();
            a3.animate && k2 && a3.animate(true);
            a3.drawGraph && (a3.drawGraph(), a3.applyZones());
            a3.visible && a3.drawPoints();
            a3.drawDataLabels && a3.drawDataLabels();
            a3.redrawPoints && a3.redrawPoints();
            a3.drawTracker && false !== a3.options.enableMouseTracking && a3.drawTracker();
            a3.animate && k2 && a3.animate();
            h2 || (k2 && d2.defer && (k2 += d2.defer), a3.animationTimeout = fa(function() {
              a3.afterAnimate();
            }, k2 || 0));
            a3.isDirty = false;
            a3.hasRendered = true;
            l(a3, "afterRender");
          }
          redraw() {
            const a3 = this.isDirty || this.isDirtyData;
            this.translate();
            this.render();
            a3 && delete this.kdTree;
          }
          searchPoint(a3, b2) {
            const c2 = this.xAxis, d2 = this.yAxis, e2 = this.chart.inverted;
            return this.searchKDTree({ clientX: e2 ? c2.len - a3.chartY + c2.pos : a3.chartX - c2.pos, plotY: e2 ? d2.len - a3.chartX + d2.pos : a3.chartY - d2.pos }, b2, a3);
          }
          buildKDTree(a3) {
            function b2(a4, d3, e2) {
              var f2 = a4 && a4.length;
              let g2;
              if (f2)
                return g2 = c2.kdAxisArray[d3 % e2], a4.sort(function(a5, b3) {
                  return a5[g2] - b3[g2];
                }), f2 = Math.floor(f2 / 2), { point: a4[f2], left: b2(a4.slice(0, f2), d3 + 1, e2), right: b2(a4.slice(f2 + 1), d3 + 1, e2) };
            }
            this.buildingKdTree = true;
            const c2 = this, d2 = -1 < c2.options.findNearestPointBy.indexOf("y") ? 2 : 1;
            delete c2.kdTree;
            fa(function() {
              c2.kdTree = b2(c2.getValidPoints(null, !c2.directTouch), d2, d2);
              c2.buildingKdTree = false;
            }, c2.options.kdNow || a3 && "touchstart" === a3.type ? 0 : 1);
          }
          searchKDTree(a3, b2, c2) {
            function d2(a4, b3, c3, h2) {
              const k2 = b3.point;
              var p2 = e2.kdAxisArray[c3 % h2];
              let m2 = k2;
              var n2 = q(a4[f2]) && q(k2[f2]) ? Math.pow(a4[f2] - k2[f2], 2) : null;
              var r2 = q(a4[g2]) && q(k2[g2]) ? Math.pow(a4[g2] - k2[g2], 2) : null;
              r2 = (n2 || 0) + (r2 || 0);
              k2.dist = q(r2) ? Math.sqrt(r2) : Number.MAX_VALUE;
              k2.distX = q(n2) ? Math.sqrt(n2) : Number.MAX_VALUE;
              p2 = a4[p2] - k2[p2];
              r2 = 0 > p2 ? "left" : "right";
              n2 = 0 > p2 ? "right" : "left";
              b3[r2] && (r2 = d2(a4, b3[r2], c3 + 1, h2), m2 = r2[l2] < m2[l2] ? r2 : k2);
              b3[n2] && Math.sqrt(p2 * p2) < m2[l2] && (a4 = d2(a4, b3[n2], c3 + 1, h2), m2 = a4[l2] < m2[l2] ? a4 : m2);
              return m2;
            }
            const e2 = this, f2 = this.kdAxisArray[0], g2 = this.kdAxisArray[1], l2 = b2 ? "distX" : "dist";
            b2 = -1 < e2.options.findNearestPointBy.indexOf("y") ? 2 : 1;
            this.kdTree || this.buildingKdTree || this.buildKDTree(c2);
            if (this.kdTree)
              return d2(a3, this.kdTree, b2, b2);
          }
          pointPlacementToXValue() {
            const { options: { pointPlacement: a3, pointRange: b2 }, xAxis: c2 } = this;
            let d2 = a3;
            "between" === d2 && (d2 = c2.reversed ? -0.5 : 0.5);
            return O(d2) ? d2 * (b2 || c2.pointRange) : 0;
          }
          isPointInside(a3) {
            const { chart: b2, xAxis: c2, yAxis: d2 } = this;
            return "undefined" !== typeof a3.plotY && "undefined" !== typeof a3.plotX && 0 <= a3.plotY && a3.plotY <= (d2 ? d2.len : b2.plotHeight) && 0 <= a3.plotX && a3.plotX <= (c2 ? c2.len : b2.plotWidth);
          }
          drawTracker() {
            const a3 = this, b2 = a3.options, c2 = b2.trackByArea, d2 = [].concat(c2 ? a3.areaPath : a3.graphPath), e2 = a3.chart, f2 = e2.pointer, g2 = e2.renderer, h2 = e2.options.tooltip.snap, p2 = a3.tracker, m2 = function(b3) {
              if (e2.hoverSeries !== a3)
                a3.onMouseOver();
            }, q2 = "rgba(192,192,192," + (k ? 1e-4 : 2e-3) + ")";
            p2 ? p2.attr({ d: d2 }) : a3.graph && (a3.tracker = g2.path(d2).attr({ visibility: a3.visible ? "inherit" : "hidden", zIndex: 2 }).addClass(c2 ? "highcharts-tracker-area" : "highcharts-tracker-line").add(a3.group), e2.styledMode || a3.tracker.attr({ "stroke-linecap": "round", "stroke-linejoin": "round", stroke: q2, fill: c2 ? q2 : "none", "stroke-width": a3.graph.strokeWidth() + (c2 ? 0 : 2 * h2) }), [
              a3.tracker,
              a3.markerGroup,
              a3.dataLabelsGroup
            ].forEach(function(a4) {
              if (a4 && (a4.addClass("highcharts-tracker").on("mouseover", m2).on("mouseout", function(a5) {
                f2.onTrackerMouseOut(a5);
              }), b2.cursor && !e2.styledMode && a4.css({ cursor: b2.cursor }), n))
                a4.on("touchstart", m2);
            }));
            l(this, "afterDrawTracker");
          }
          addPoint(a3, b2, c2, d2, e2) {
            const f2 = this.options, g2 = this.data, h2 = this.chart;
            var k2 = this.xAxis;
            k2 = k2 && k2.hasNames && k2.names;
            const p2 = f2.data, m2 = this.xData;
            let q2, n2;
            b2 = G(b2, true);
            const r2 = { series: this };
            this.pointClass.prototype.applyOptions.apply(r2, [a3]);
            const t2 = r2.x;
            n2 = m2.length;
            if (this.requireSorting && t2 < m2[n2 - 1])
              for (q2 = true; n2 && m2[n2 - 1] > t2; )
                n2--;
            this.updateParallelArrays(r2, "splice", [n2, 0, 0]);
            this.updateParallelArrays(r2, n2);
            k2 && r2.name && (k2[t2] = r2.name);
            p2.splice(n2, 0, a3);
            if (q2 || this.processedData)
              this.data.splice(n2, 0, null), this.processData();
            "point" === f2.legendType && this.generatePoints();
            c2 && (g2[0] && g2[0].remove ? g2[0].remove(false) : (g2.shift(), this.updateParallelArrays(r2, "shift"), p2.shift()));
            false !== e2 && l(this, "addPoint", { point: r2 });
            this.isDirtyData = this.isDirty = true;
            b2 && h2.redraw(d2);
          }
          removePoint(a3, b2, c2) {
            const d2 = this, e2 = d2.data, f2 = e2[a3], g2 = d2.points, l2 = d2.chart, k2 = function() {
              g2 && g2.length === e2.length && g2.splice(a3, 1);
              e2.splice(a3, 1);
              d2.options.data.splice(a3, 1);
              d2.updateParallelArrays(f2 || { series: d2 }, "splice", [a3, 1]);
              f2 && f2.destroy();
              d2.isDirty = true;
              d2.isDirtyData = true;
              b2 && l2.redraw();
            };
            h(c2, l2);
            b2 = G(b2, true);
            f2 ? f2.firePointEvent("remove", null, k2) : k2();
          }
          remove(a3, b2, c2, d2) {
            function e2() {
              f2.destroy(d2);
              g2.isDirtyLegend = g2.isDirtyBox = true;
              g2.linkSeries(d2);
              G(a3, true) && g2.redraw(b2);
            }
            const f2 = this, g2 = f2.chart;
            false !== c2 ? l(f2, "remove", null, e2) : e2();
          }
          update(a3, d2) {
            a3 = t(
              a3,
              this.userOptions
            );
            l(this, "update", { options: a3 });
            const e2 = this, f2 = e2.chart;
            var g2 = e2.userOptions;
            const h2 = e2.initialType || e2.type;
            var k2 = f2.options.plotOptions;
            const p2 = w[h2].prototype;
            var m2 = e2.finishedAnimating && { animation: false };
            const q2 = {};
            let n2, r2 = ["eventOptions", "navigatorSeries", "baseSeries"], x2 = a3.type || g2.type || f2.options.chart.type;
            const v2 = !(this.hasDerivedData || x2 && x2 !== this.type || "undefined" !== typeof a3.pointStart || "undefined" !== typeof a3.pointInterval || "undefined" !== typeof a3.relativeXValue || a3.joinBy || a3.mapData || e2.hasOptionChanged("dataGrouping") || e2.hasOptionChanged("pointStart") || e2.hasOptionChanged("pointInterval") || e2.hasOptionChanged("pointIntervalUnit") || e2.hasOptionChanged("keys"));
            x2 = x2 || h2;
            v2 && (r2.push("data", "isDirtyData", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), false !== a3.visible && r2.push("area", "graph"), e2.parallelArrays.forEach(function(a4) {
              r2.push(a4 + "Data");
            }), a3.data && (a3.dataSorting && b(e2.options.dataSorting, a3.dataSorting), this.setData(a3.data, false)));
            a3 = S(g2, m2, { index: "undefined" === typeof g2.index ? e2.index : g2.index, pointStart: G(k2 && k2.series && k2.series.pointStart, g2.pointStart, e2.xData[0]) }, !v2 && { data: e2.options.data }, a3);
            v2 && a3.data && (a3.data = e2.options.data);
            r2 = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(r2);
            r2.forEach(function(a4) {
              r2[a4] = e2[a4];
              delete e2[a4];
            });
            k2 = false;
            if (w[x2]) {
              if (k2 = x2 !== e2.type, e2.remove(false, false, false, true), k2)
                if (Object.setPrototypeOf)
                  Object.setPrototypeOf(
                    e2,
                    w[x2].prototype
                  );
                else {
                  m2 = Object.hasOwnProperty.call(e2, "hcEvents") && e2.hcEvents;
                  for (n2 in p2)
                    e2[n2] = void 0;
                  b(e2, w[x2].prototype);
                  m2 ? e2.hcEvents = m2 : delete e2.hcEvents;
                }
            } else
              c(17, true, f2, { missingModuleFor: x2 });
            r2.forEach(function(a4) {
              e2[a4] = r2[a4];
            });
            e2.init(f2, a3);
            if (v2 && this.points) {
              a3 = e2.options;
              if (false === a3.visible)
                q2.graphic = 1, q2.dataLabel = 1;
              else if (!e2._hasPointLabels) {
                const { marker: b2, dataLabels: c2 } = a3;
                g2 = g2.marker || {};
                !b2 || false !== b2.enabled && g2.symbol === b2.symbol && g2.height === b2.height && g2.width === b2.width || (q2.graphic = 1);
                c2 && false === c2.enabled && (q2.dataLabel = 1);
              }
              for (const b2 of this.points)
                b2 && b2.series && (b2.resolveColor(), Object.keys(q2).length && b2.destroyElements(q2), false === a3.showInLegend && b2.legendItem && f2.legend.destroyItem(b2));
            }
            e2.initialType = h2;
            f2.linkSeries();
            k2 && e2.linkedSeries.length && (e2.isDirtyData = true);
            l(this, "afterUpdate");
            G(d2, true) && f2.redraw(v2 ? void 0 : false);
          }
          setName(a3) {
            this.name = this.options.name = this.userOptions.name = a3;
            this.chart.isDirtyLegend = true;
          }
          hasOptionChanged(a3) {
            const b2 = this.options[a3], c2 = this.chart.options.plotOptions, d2 = this.userOptions[a3];
            return d2 ? b2 !== d2 : b2 !== G(c2 && c2[this.type] && c2[this.type][a3], c2 && c2.series && c2.series[a3], b2);
          }
          onMouseOver() {
            const a3 = this.chart, b2 = a3.hoverSeries;
            a3.pointer.setHoverChartIndex();
            if (b2 && b2 !== this)
              b2.onMouseOut();
            this.options.events.mouseOver && l(this, "mouseOver");
            this.setState("hover");
            a3.hoverSeries = this;
          }
          onMouseOut() {
            const a3 = this.options, b2 = this.chart, c2 = b2.tooltip, d2 = b2.hoverPoint;
            b2.hoverSeries = null;
            if (d2)
              d2.onMouseOut();
            this && a3.events.mouseOut && l(this, "mouseOut");
            !c2 || this.stickyTracking || c2.shared && !this.noSharedTooltip || c2.hide();
            b2.series.forEach(function(a4) {
              a4.setState(
                "",
                true
              );
            });
          }
          setState(a3, b2) {
            const c2 = this;
            var d2 = c2.options;
            const e2 = c2.graph, f2 = d2.inactiveOtherPoints, g2 = d2.states, l2 = G(g2[a3 || "normal"] && g2[a3 || "normal"].animation, c2.chart.options.chart.animation);
            let h2 = d2.lineWidth, k2 = 0, p2 = d2.opacity;
            a3 = a3 || "";
            if (c2.state !== a3 && ([c2.group, c2.markerGroup, c2.dataLabelsGroup].forEach(function(b3) {
              b3 && (c2.state && b3.removeClass("highcharts-series-" + c2.state), a3 && b3.addClass("highcharts-series-" + a3));
            }), c2.state = a3, !c2.chart.styledMode)) {
              if (g2[a3] && false === g2[a3].enabled)
                return;
              a3 && (h2 = g2[a3].lineWidth || h2 + (g2[a3].lineWidthPlus || 0), p2 = G(g2[a3].opacity, p2));
              if (e2 && !e2.dashstyle && O(h2))
                for (d2 = { "stroke-width": h2 }, e2.animate(d2, l2); c2["zone-graph-" + k2]; )
                  c2["zone-graph-" + k2].animate(d2, l2), k2 += 1;
              f2 || [c2.group, c2.markerGroup, c2.dataLabelsGroup, c2.labelBySeries].forEach(function(a4) {
                a4 && a4.animate({ opacity: p2 }, l2);
              });
            }
            b2 && f2 && c2.points && c2.setAllPointsToState(a3 || void 0);
          }
          setAllPointsToState(a3) {
            this.points.forEach(function(b2) {
              b2.setState && b2.setState(a3);
            });
          }
          setVisible(a3, b2) {
            const c2 = this, d2 = c2.chart, e2 = d2.options.chart.ignoreHiddenSeries, f2 = c2.visible, g2 = (c2.visible = a3 = c2.options.visible = c2.userOptions.visible = "undefined" === typeof a3 ? !f2 : a3) ? "show" : "hide";
            ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function(a4) {
              if (c2[a4])
                c2[a4][g2]();
            });
            if (d2.hoverSeries === c2 || (d2.hoverPoint && d2.hoverPoint.series) === c2)
              c2.onMouseOut();
            c2.legendItem && d2.legend.colorizeItem(c2, a3);
            c2.isDirty = true;
            c2.options.stacking && d2.series.forEach(function(a4) {
              a4.options.stacking && a4.visible && (a4.isDirty = true);
            });
            c2.linkedSeries.forEach(function(b3) {
              b3.setVisible(a3, false);
            });
            e2 && (d2.isDirtyBox = true);
            l(c2, g2);
            false !== b2 && d2.redraw();
          }
          show() {
            this.setVisible(true);
          }
          hide() {
            this.setVisible(false);
          }
          select(a3) {
            this.selected = a3 = this.options.selected = "undefined" === typeof a3 ? !this.selected : a3;
            this.checkbox && (this.checkbox.checked = a3);
            l(this, a3 ? "select" : "unselect");
          }
          shouldShowTooltip(a3, b2, c2 = {}) {
            c2.series = this;
            c2.visiblePlotOnly = true;
            return this.chart.isInsidePlot(a3, b2, c2);
          }
        }
        Y.defaultOptions = C;
        Y.types = A.seriesTypes;
        Y.registerType = A.registerSeriesType;
        b(Y.prototype, { axisTypes: ["xAxis", "yAxis"], coll: "series", colorCounter: 0, cropShoulder: 1, directTouch: false, drawLegendSymbol: B.drawLineMarker, isCartesian: true, kdAxisArray: ["clientX", "plotY"], parallelArrays: [
          "x",
          "y"
        ], pointClass: E, requireSorting: true, sorted: true });
        A.series = Y;
        "";
        "";
        return Y;
      });
      M(a, "Extensions/ScrollablePlotArea.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/Chart/Chart.js"], a["Core/Series/Series.js"], a["Core/Renderer/RendererRegistry.js"], a["Core/Utilities.js"]], function(a2, y, H, K, B, E) {
        const { stop: w } = a2, { addEvent: A, createElement: u, defined: v, merge: f, pick: h } = E;
        A(H, "afterSetChartSize", function(a3) {
          var h2 = this.options.chart.scrollablePlotArea, n = h2 && h2.minWidth;
          h2 = h2 && h2.minHeight;
          let k;
          if (!this.renderer.forExport) {
            if (n) {
              if (this.scrollablePixelsX = n = Math.max(0, n - this.chartWidth))
                this.scrollablePlotBox = this.renderer.scrollablePlotBox = f(this.plotBox), this.plotBox.width = this.plotWidth += n, this.inverted ? this.clipBox.height += n : this.clipBox.width += n, k = { 1: { name: "right", value: n } };
            } else
              h2 && (this.scrollablePixelsY = n = Math.max(0, h2 - this.chartHeight), v(n) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = f(this.plotBox), this.plotBox.height = this.plotHeight += n, this.inverted ? this.clipBox.width += n : this.clipBox.height += n, k = { 2: { name: "bottom", value: n } }));
            k && !a3.skipAxes && this.axes.forEach(function(a4) {
              k[a4.side] ? a4.getPlotLinePath = function() {
                let f2 = k[a4.side].name, g = this[f2], h3;
                this[f2] = g - k[a4.side].value;
                h3 = y.prototype.getPlotLinePath.apply(this, arguments);
                this[f2] = g;
                return h3;
              } : (a4.setAxisSize(), a4.setAxisTranslation());
            });
          }
        });
        A(H, "render", function() {
          this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
        });
        H.prototype.setUpScrolling = function() {
          const a3 = { WebkitOverflowScrolling: "touch", overflowX: "hidden", overflowY: "hidden" };
          this.scrollablePixelsX && (a3.overflowX = "auto");
          this.scrollablePixelsY && (a3.overflowY = "auto");
          this.scrollingParent = u("div", { className: "highcharts-scrolling-parent" }, { position: "relative" }, this.renderTo);
          this.scrollingContainer = u("div", { className: "highcharts-scrolling" }, a3, this.scrollingParent);
          let f2;
          A(this.scrollingContainer, "scroll", () => {
            this.pointer && (delete this.pointer.chartPosition, this.hoverPoint && (f2 = this.hoverPoint), this.pointer.runPointActions(void 0, f2, true));
          });
          this.innerContainer = u("div", { className: "highcharts-inner-container" }, null, this.scrollingContainer);
          this.innerContainer.appendChild(this.container);
          this.setUpScrolling = null;
        };
        H.prototype.moveFixedElements = function() {
          let a3 = this.container, f2 = this.fixedRenderer, h2 = ".highcharts-breadcrumbs-group .highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "), k;
          this.scrollablePixelsX && !this.inverted ? k = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? k = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? k = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (k = ".highcharts-yaxis");
          k && h2.push(`${k}:not(.highcharts-radial-axis)`, `${k}-labels:not(.highcharts-radial-axis-labels)`);
          h2.forEach(function(g) {
            [].forEach.call(a3.querySelectorAll(g), function(a4) {
              (a4.namespaceURI === f2.SVG_NS ? f2.box : f2.box.parentNode).appendChild(a4);
              a4.style.pointerEvents = "auto";
            });
          });
        };
        H.prototype.applyFixed = function() {
          var a3 = !this.fixedDiv, f2 = this.options.chart, n = f2.scrollablePlotArea, k = B.getRendererType();
          a3 ? (this.fixedDiv = u("div", { className: "highcharts-fixed" }, { position: "absolute", overflow: "hidden", pointerEvents: "none", zIndex: (f2.style && f2.style.zIndex || 0) + 2, top: 0 }, null, true), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = f2 = new k(
            this.fixedDiv,
            this.chartWidth,
            this.chartHeight,
            this.options.chart.style
          ), this.scrollableMask = f2.path().attr({ fill: this.options.chart.backgroundColor || "#fff", "fill-opacity": h(n.opacity, 0.85), zIndex: -1 }).addClass("highcharts-scrollable-mask").add(), A(this, "afterShowResetZoom", this.moveFixedElements), A(this, "afterApplyDrilldown", this.moveFixedElements), A(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
          if (this.scrollableDirty || a3)
            this.scrollableDirty = false, this.moveFixedElements();
          f2 = this.chartWidth + (this.scrollablePixelsX || 0);
          k = this.chartHeight + (this.scrollablePixelsY || 0);
          w(this.container);
          this.container.style.width = f2 + "px";
          this.container.style.height = k + "px";
          this.renderer.boxWrapper.attr({ width: f2, height: k, viewBox: [0, 0, f2, k].join(" ") });
          this.chartBackground.attr({ width: f2, height: k });
          this.scrollingContainer.style.height = this.chartHeight + "px";
          a3 && (n.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * n.scrollPositionX), n.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * n.scrollPositionY));
          k = this.axisOffset;
          a3 = this.plotTop - k[0] - 1;
          n = this.plotLeft - k[3] - 1;
          f2 = this.plotTop + this.plotHeight + k[2] + 1;
          k = this.plotLeft + this.plotWidth + k[1] + 1;
          let g = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0), v2 = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
          a3 = this.scrollablePixelsX ? [["M", 0, a3], ["L", this.plotLeft - 1, a3], ["L", this.plotLeft - 1, f2], ["L", 0, f2], ["Z"], ["M", g, a3], ["L", this.chartWidth, a3], ["L", this.chartWidth, f2], ["L", g, f2], ["Z"]] : this.scrollablePixelsY ? [["M", n, 0], ["L", n, this.plotTop - 1], ["L", k, this.plotTop - 1], ["L", k, 0], ["Z"], ["M", n, v2], ["L", n, this.chartHeight], ["L", k, this.chartHeight], ["L", k, v2], ["Z"]] : [["M", 0, 0]];
          "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({ d: a3 });
        };
        A(y, "afterInit", function() {
          this.chart.scrollableDirty = true;
        });
        A(K, "show", function() {
          this.chart.scrollableDirty = true;
        });
        "";
      });
      M(a, "Core/Axis/Stacking/StackItem.js", [a["Core/FormatUtilities.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y, H) {
        const { format: w } = a2, { series: B } = y, { destroyObjectProperties: E, fireEvent: C, isNumber: A, pick: u } = H;
        class v {
          constructor(a3, h, r, m, n) {
            const f = a3.chart.inverted, g = a3.reversed;
            this.axis = a3;
            a3 = this.isNegative = !!r !== !!g;
            this.options = h = h || {};
            this.x = m;
            this.cumulative = this.total = null;
            this.points = {};
            this.hasValidPoints = false;
            this.stack = n;
            this.rightCliff = this.leftCliff = 0;
            this.alignOptions = { align: h.align || (f ? a3 ? "left" : "right" : "center"), verticalAlign: h.verticalAlign || (f ? "middle" : a3 ? "bottom" : "top"), y: h.y, x: h.x };
            this.textAlign = h.textAlign || (f ? a3 ? "right" : "left" : "center");
          }
          destroy() {
            E(this, this.axis);
          }
          render(a3) {
            const f = this.axis.chart, r = this.options;
            var m = r.format;
            m = m ? w(m, this, f) : r.formatter.call(this);
            this.label ? this.label.attr({ text: m, visibility: "hidden" }) : (this.label = f.renderer.label(m, null, void 0, r.shape, void 0, void 0, r.useHTML, false, "stack-labels"), m = { r: r.borderRadius || 0, text: m, padding: u(r.padding, 5), visibility: "hidden" }, f.styledMode || (m.fill = r.backgroundColor, m.stroke = r.borderColor, m["stroke-width"] = r.borderWidth, this.label.css(r.style || {})), this.label.attr(m), this.label.added || this.label.add(a3));
            this.label.labelrank = f.plotSizeY;
            C(this, "afterRender");
          }
          setOffset(a3, h, r, m, n, k) {
            const { alignOptions: f, axis: v2, label: w2, options: z, textAlign: e } = this, t = v2.chart;
            r = this.getStackBox({ xOffset: a3, width: h, boxBottom: r, boxTop: m, defaultX: n, xAxis: k });
            var { verticalAlign: d } = f;
            if (w2 && r) {
              m = w2.getBBox();
              n = w2.padding;
              k = "justify" === u(z.overflow, "justify");
              f.x = z.x || 0;
              f.y = z.y || 0;
              const { x: a4, y: g } = this.adjustStackPosition({ labelBox: m, verticalAlign: d, textAlign: e });
              r.x -= a4;
              r.y -= g;
              w2.align(f, false, r);
              (d = t.isInsidePlot(w2.alignAttr.x + f.x + a4, w2.alignAttr.y + f.y + g)) || (k = false);
              k && B.prototype.justifyDataLabel.call(v2, w2, f, w2.alignAttr, m, r);
              w2.attr({ x: w2.alignAttr.x, y: w2.alignAttr.y, rotation: z.rotation, rotationOriginX: m.width / 2, rotationOriginY: m.height / 2 });
              u(!k && z.crop, true) && (d = A(w2.x) && A(w2.y) && t.isInsidePlot(w2.x - n + w2.width, w2.y) && t.isInsidePlot(w2.x + n, w2.y));
              w2[d ? "show" : "hide"]();
            }
            C(this, "afterSetOffset", { xOffset: a3, width: h });
          }
          adjustStackPosition({ labelBox: a3, verticalAlign: h, textAlign: r }) {
            const f = {
              bottom: 0,
              middle: 1,
              top: 2,
              right: 1,
              center: 0,
              left: -1
            };
            return { x: a3.width / 2 + a3.width / 2 * f[r], y: a3.height / 2 * f[h] };
          }
          getStackBox(a3) {
            var f = this.axis;
            const r = f.chart, { boxTop: m, defaultX: n, xOffset: k, width: g, boxBottom: v2 } = a3;
            var w2 = f.stacking.usePercentage ? 100 : u(m, this.total, 0);
            w2 = f.toPixels(w2);
            a3 = a3.xAxis || r.xAxis[0];
            const z = u(n, a3.translate(this.x)) + k;
            f = f.toPixels(v2 || A(f.min) && f.logarithmic && f.logarithmic.lin2log(f.min) || 0);
            f = Math.abs(w2 - f);
            const e = this.isNegative;
            return r.inverted ? { x: (e ? w2 : w2 - f) - r.plotLeft, y: a3.height - z - g, width: f, height: g } : { x: z + a3.transB - r.plotLeft, y: (e ? w2 - f : w2) - r.plotTop, width: g, height: f };
          }
        }
        "";
        return v;
      });
      M(a, "Core/Axis/Stacking/StackingAxis.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Axis/Axis.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Axis/Stacking/StackItem.js"], a["Core/Utilities.js"]], function(a2, y, H, K, B) {
        function w() {
          const a3 = this, c2 = a3.inverted;
          a3.yAxis.forEach((a4) => {
            a4.stacking && a4.stacking.stacks && a4.hasVisibleSeries && (a4.stacking.oldStacks = a4.stacking.stacks);
          });
          a3.series.forEach((b) => {
            const d2 = b.xAxis && b.xAxis.options || {};
            !b.options.stacking || true !== b.visible && false !== a3.options.chart.ignoreHiddenSeries || (b.stackKey = [b.type, q(b.options.stack, ""), c2 ? d2.top : d2.left, c2 ? d2.height : d2.width].join());
          });
        }
        function C() {
          const a3 = this.stacking;
          if (a3) {
            var c2 = a3.stacks;
            d(c2, function(a4, b) {
              F(a4);
              c2[b] = null;
            });
            a3 && a3.stackTotalGroup && a3.stackTotalGroup.destroy();
          }
        }
        function A() {
          "yAxis" !== this.coll || this.stacking || (this.stacking = new x(this));
        }
        function u(a3, c2, d2, e2) {
          !I(a3) || a3.x !== c2 || e2 && a3.stackKey !== e2 ? a3 = { x: c2, index: 0, key: e2, stackKey: e2 } : a3.index++;
          a3.key = [d2, c2, a3.index].join();
          return a3;
        }
        function v() {
          const a3 = this, c2 = a3.stackKey, d2 = a3.yAxis.stacking.stacks, e2 = a3.processedXData, f2 = a3[a3.options.stacking + "Stacker"];
          let g2;
          f2 && [c2, "-" + c2].forEach((b) => {
            let c3 = e2.length;
            let l;
            for (; c3--; ) {
              var h2 = e2[c3];
              g2 = a3.getStackIndicator(g2, h2, a3.index, b);
              (l = (h2 = d2[b] && d2[b][h2]) && h2.points[g2.key]) && f2.call(a3, l, h2, c3);
            }
          });
        }
        function f(a3, c2, d2) {
          c2 = c2.total ? 100 / c2.total : 0;
          a3[0] = g(a3[0] * c2);
          a3[1] = g(a3[1] * c2);
          this.stackedYData[d2] = a3[1];
        }
        function h() {
          const a3 = this.yAxis.stacking;
          this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? n.setStackedPoints.call(this, "group") : a3 && d(a3.stacks, (b, c2) => {
            "group" === c2.slice(-5) && (d(b, (a4) => a4.destroy()), delete a3.stacks[c2]);
          });
        }
        function r(a3) {
          var b = this.chart;
          const c2 = a3 || this.options.stacking;
          if (c2 && (true === this.visible || false === b.options.chart.ignoreHiddenSeries)) {
            var d2 = this.processedXData, f2 = this.processedYData, h2 = [], k2 = f2.length, m2 = this.options, n2 = m2.threshold, r2 = q(m2.startFromThreshold && n2, 0);
            m2 = m2.stack;
            a3 = a3 ? `${this.type},${c2}` : this.stackKey;
            var t2 = "-" + a3, x2 = this.negStacks;
            b = "group" === c2 ? b.yAxis[0] : this.yAxis;
            var v2 = b.stacking.stacks, u2 = b.stacking.oldStacks, w2, z2;
            b.stacking.stacksTouched += 1;
            for (z2 = 0; z2 < k2; z2++) {
              var F2 = d2[z2];
              var A2 = f2[z2];
              var y2 = this.getStackIndicator(y2, F2, this.index);
              var B2 = y2.key;
              var C2 = (w2 = x2 && A2 < (r2 ? 0 : n2)) ? t2 : a3;
              v2[C2] || (v2[C2] = {});
              v2[C2][F2] || (u2[C2] && u2[C2][F2] ? (v2[C2][F2] = u2[C2][F2], v2[C2][F2].total = null) : v2[C2][F2] = new K(b, b.options.stackLabels, !!w2, F2, m2));
              C2 = v2[C2][F2];
              null !== A2 ? (C2.points[B2] = C2.points[this.index] = [q(C2.cumulative, r2)], I(C2.cumulative) || (C2.base = B2), C2.touched = b.stacking.stacksTouched, 0 < y2.index && false === this.singleStacks && (C2.points[B2][0] = C2.points[this.index + "," + F2 + ",0"][0])) : C2.points[B2] = C2.points[this.index] = null;
              "percent" === c2 ? (w2 = w2 ? a3 : t2, x2 && v2[w2] && v2[w2][F2] ? (w2 = v2[w2][F2], C2.total = w2.total = Math.max(w2.total, C2.total) + Math.abs(A2) || 0) : C2.total = g(C2.total + (Math.abs(A2) || 0))) : "group" === c2 ? (e(A2) && (A2 = A2[0]), null !== A2 && (C2.total = (C2.total || 0) + 1)) : C2.total = g(C2.total + (A2 || 0));
              C2.cumulative = "group" === c2 ? (C2.total || 1) - 1 : g(q(C2.cumulative, r2) + (A2 || 0));
              null !== A2 && (C2.points[B2].push(C2.cumulative), h2[z2] = C2.cumulative, C2.hasValidPoints = true);
            }
            "percent" === c2 && (b.stacking.usePercentage = true);
            "group" !== c2 && (this.stackedYData = h2);
            b.stacking.oldStacks = {};
          }
        }
        const { getDeferredAnimation: m } = a2, { series: { prototype: n } } = H, { addEvent: k, correctFloat: g, defined: I, destroyObjectProperties: F, fireEvent: z, isArray: e, isNumber: t, objectEach: d, pick: q } = B;
        class x {
          constructor(a3) {
            this.oldStacks = {};
            this.stacks = {};
            this.stacksTouched = 0;
            this.axis = a3;
          }
          buildStacks() {
            const a3 = this.axis, c2 = a3.series, d2 = a3.options.reversedStacks, e2 = c2.length;
            let f2, g2;
            this.usePercentage = false;
            for (g2 = e2; g2--; )
              f2 = c2[d2 ? g2 : e2 - g2 - 1], f2.setStackedPoints(), f2.setGroupedPoints();
            for (g2 = 0; g2 < e2; g2++)
              c2[g2].modifyStacks();
            z(a3, "afterBuildStacks");
          }
          cleanStacks() {
            let a3;
            this.oldStacks && (a3 = this.stacks = this.oldStacks);
            d(a3, function(a4) {
              d(a4, function(a5) {
                a5.cumulative = a5.total;
              });
            });
          }
          resetStacks() {
            d(this.stacks, (a3) => {
              d(a3, (b, c2) => {
                t(b.touched) && b.touched < this.stacksTouched ? (b.destroy(), delete a3[c2]) : (b.total = null, b.cumulative = null);
              });
            });
          }
          renderStackTotals() {
            var a3 = this.axis;
            const c2 = a3.chart, e2 = c2.renderer, f2 = this.stacks;
            a3 = m(c2, a3.options.stackLabels && a3.options.stackLabels.animation || false);
            const g2 = this.stackTotalGroup = this.stackTotalGroup || e2.g("stack-labels").attr({ zIndex: 6, opacity: 0 }).add();
            g2.translate(c2.plotLeft, c2.plotTop);
            d(f2, function(a4) {
              d(a4, function(a5) {
                a5.render(g2);
              });
            });
            g2.animate({ opacity: 1 }, a3);
          }
        }
        var c;
        (function(a3) {
          const b = [];
          a3.compose = function(a4, c2, d2) {
            B.pushUnique(b, a4) && (k(a4, "init", A), k(a4, "destroy", C));
            B.pushUnique(b, c2) && (c2.prototype.getStacks = w);
            B.pushUnique(b, d2) && (a4 = d2.prototype, a4.getStackIndicator = u, a4.modifyStacks = v, a4.percentStacker = f, a4.setGroupedPoints = h, a4.setStackedPoints = r);
          };
        })(c || (c = {}));
        return c;
      });
      M(a, "Series/Line/LineSeries.js", [a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y, H) {
        const { defined: w, merge: B } = H;
        class E extends a2 {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          drawGraph() {
            const a3 = this, w2 = this.options, u = (this.gappedPath || this.getGraphPath).call(this), v = this.chart.styledMode;
            let f = [["graph", "highcharts-graph"]];
            v || f[0].push(w2.lineColor || this.color || "#cccccc", w2.dashStyle);
            f = a3.getZonesGraphs(f);
            f.forEach(function(f2, r) {
              var h = f2[0];
              let n = a3[h];
              const k = n ? "animate" : "attr";
              n ? (n.endX = a3.preventGraphAnimation ? null : u.xMap, n.animate({ d: u })) : u.length && (a3[h] = n = a3.chart.renderer.path(u).addClass(f2[1]).attr({ zIndex: 1 }).add(a3.group));
              n && !v && (h = { stroke: f2[2], "stroke-width": w2.lineWidth || 0, fill: a3.fillGraph && a3.color || "none" }, f2[3] ? h.dashstyle = f2[3] : "square" !== w2.linecap && (h["stroke-linecap"] = h["stroke-linejoin"] = "round"), n[k](h).shadow(2 > r && w2.shadow));
              n && (n.startX = u.xMap, n.isArea = u.isArea);
            });
          }
          getGraphPath(a3, A, u) {
            const v = this, f = v.options, h = [], r = [];
            let m, n = f.step;
            a3 = a3 || v.points;
            const k = a3.reversed;
            k && a3.reverse();
            (n = { right: 1, center: 2 }[n] || n && 3) && k && (n = 4 - n);
            a3 = this.getValidPoints(a3, false, !(f.connectNulls && !A && !u));
            a3.forEach(function(g, k2) {
              const F = g.plotX, z = g.plotY, e = a3[k2 - 1], t = g.isNull || "number" !== typeof z;
              (g.leftCliff || e && e.rightCliff) && !u && (m = true);
              t && !w(A) && 0 < k2 ? m = !f.connectNulls : t && !A ? m = true : (0 === k2 || m ? k2 = [["M", g.plotX, g.plotY]] : v.getPointSpline ? k2 = [v.getPointSpline(a3, g, k2)] : n ? (k2 = 1 === n ? [["L", e.plotX, z]] : 2 === n ? [[
                "L",
                (e.plotX + F) / 2,
                e.plotY
              ], ["L", (e.plotX + F) / 2, z]] : [["L", F, e.plotY]], k2.push(["L", F, z])) : k2 = [["L", F, z]], r.push(g.x), n && (r.push(g.x), 2 === n && r.push(g.x)), h.push.apply(h, k2), m = false);
            });
            h.xMap = r;
            return v.graphPath = h;
          }
          getZonesGraphs(a3) {
            this.zones.forEach(function(w2, u) {
              u = ["zone-graph-" + u, "highcharts-graph highcharts-zone-graph-" + u + " " + (w2.className || "")];
              this.chart.styledMode || u.push(w2.color || this.color, w2.dashStyle || this.options.dashStyle);
              a3.push(u);
            }, this);
            return a3;
          }
        }
        E.defaultOptions = B(a2.defaultOptions, {});
        y.registerSeriesType(
          "line",
          E
        );
        "";
        return E;
      });
      M(a, "Series/Area/AreaSeries.js", [a["Core/Color/Color.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y, H, K) {
        const { parse: w } = a2, { seriesTypes: { line: E } } = H, { extend: C, merge: A, objectEach: u, pick: v } = K;
        class f extends E {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          drawGraph() {
            this.areaPath = [];
            super.drawGraph.apply(this);
            const a3 = this, f2 = this.areaPath, m = this.options, n = [[
              "area",
              "highcharts-area",
              this.color,
              m.fillColor
            ]];
            this.zones.forEach(function(f3, g) {
              n.push(["zone-area-" + g, "highcharts-area highcharts-zone-area-" + g + " " + f3.className, f3.color || a3.color, f3.fillColor || m.fillColor]);
            });
            n.forEach(function(h) {
              const g = h[0], k = {};
              let n2 = a3[g];
              const r = n2 ? "animate" : "attr";
              n2 ? (n2.endX = a3.preventGraphAnimation ? null : f2.xMap, n2.animate({ d: f2 })) : (k.zIndex = 0, n2 = a3[g] = a3.chart.renderer.path(f2).addClass(h[1]).add(a3.group), n2.isArea = true);
              a3.chart.styledMode || (k.fill = v(h[3], w(h[2]).setOpacity(v(m.fillOpacity, 0.75)).get()));
              n2[r](k);
              n2.startX = f2.xMap;
              n2.shiftUnit = m.step ? 2 : 1;
            });
          }
          getGraphPath(a3) {
            var f2 = E.prototype.getGraphPath, h = this.options;
            const n = h.stacking, k = this.yAxis, g = [], w2 = [], u2 = this.index, z = k.stacking.stacks[this.stackKey], e = h.threshold, t = Math.round(k.getThreshold(h.threshold));
            h = v(h.connectNulls, "percent" === n);
            var d = function(b, c2, d2) {
              var f3 = a3[b];
              b = n && z[f3.x].points[u2];
              const l = f3[d2 + "Null"] || 0;
              d2 = f3[d2 + "Cliff"] || 0;
              let h2, p;
              f3 = true;
              d2 || l ? (h2 = (l ? b[0] : b[1]) + d2, p = b[0] + d2, f3 = !!l) : !n && a3[c2] && a3[c2].isNull && (h2 = p = e);
              "undefined" !== typeof h2 && (w2.push({ plotX: q, plotY: null === h2 ? t : k.getThreshold(h2), isNull: f3, isCliff: true }), g.push({ plotX: q, plotY: null === p ? t : k.getThreshold(p), doCurve: false }));
            };
            let q;
            a3 = a3 || this.points;
            n && (a3 = this.getStackPoints(a3));
            for (let b = 0, e2 = a3.length; b < e2; ++b) {
              n || (a3[b].leftCliff = a3[b].rightCliff = a3[b].leftNull = a3[b].rightNull = void 0);
              var x = a3[b].isNull;
              q = v(a3[b].rectPlotX, a3[b].plotX);
              var c = n ? v(a3[b].yBottom, t) : t;
              if (!x || h)
                h || d(b, b - 1, "left"), x && !n && h || (w2.push(a3[b]), g.push({ x: b, plotX: q, plotY: c })), h || d(b, b + 1, "right");
            }
            d = f2.call(this, w2, true, true);
            g.reversed = true;
            x = f2.call(
              this,
              g,
              true,
              true
            );
            (c = x[0]) && "M" === c[0] && (x[0] = ["L", c[1], c[2]]);
            x = d.concat(x);
            x.length && x.push(["Z"]);
            f2 = f2.call(this, w2, false, h);
            x.xMap = d.xMap;
            this.areaPath = x;
            return f2;
          }
          getStackPoints(a3) {
            const f2 = this, h = [], n = [], k = this.xAxis, g = this.yAxis, w2 = g.stacking.stacks[this.stackKey], F = {}, z = g.series, e = z.length, t = g.options.reversedStacks ? 1 : -1, d = z.indexOf(f2);
            a3 = a3 || this.points;
            if (this.options.stacking) {
              for (let d2 = 0; d2 < a3.length; d2++)
                a3[d2].leftNull = a3[d2].rightNull = void 0, F[a3[d2].x] = a3[d2];
              u(w2, function(a4, c) {
                null !== a4.total && n.push(c);
              });
              n.sort(function(a4, c) {
                return a4 - c;
              });
              const q = z.map((a4) => a4.visible);
              n.forEach(function(a4, c) {
                let b = 0, p, l;
                if (F[a4] && !F[a4].isNull)
                  h.push(F[a4]), [-1, 1].forEach(function(b2) {
                    const g2 = 1 === b2 ? "rightNull" : "leftNull", h2 = w2[n[c + b2]];
                    let k2 = 0;
                    if (h2) {
                      let b3 = d;
                      for (; 0 <= b3 && b3 < e; ) {
                        const c2 = z[b3].index;
                        p = h2.points[c2];
                        p || (c2 === f2.index ? F[a4][g2] = true : q[b3] && (l = w2[a4].points[c2]) && (k2 -= l[1] - l[0]));
                        b3 += t;
                      }
                    }
                    F[a4][1 === b2 ? "rightCliff" : "leftCliff"] = k2;
                  });
                else {
                  let c2 = d;
                  for (; 0 <= c2 && c2 < e; ) {
                    if (p = w2[a4].points[z[c2].index]) {
                      b = p[1];
                      break;
                    }
                    c2 += t;
                  }
                  b = v(b, 0);
                  b = g.translate(b, 0, 1, 0, 1);
                  h.push({
                    isNull: true,
                    plotX: k.translate(a4, 0, 0, 0, 1),
                    x: a4,
                    plotY: b,
                    yBottom: b
                  });
                }
              });
            }
            return h;
          }
        }
        f.defaultOptions = A(E.defaultOptions, { threshold: 0 });
        C(f.prototype, { singleStacks: false, drawLegendSymbol: y.drawRectangle });
        H.registerSeriesType("area", f);
        "";
        return f;
      });
      M(a, "Series/Spline/SplineSeries.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y) {
        const { line: w } = a2.seriesTypes, { merge: K, pick: B } = y;
        class E extends w {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          getPointSpline(a3, w2, u) {
            const v = w2.plotX || 0, f = w2.plotY || 0, h = a3[u - 1];
            u = a3[u + 1];
            let r, m;
            let n;
            if (h && !h.isNull && false !== h.doCurve && !w2.isCliff && u && !u.isNull && false !== u.doCurve && !w2.isCliff) {
              a3 = h.plotY || 0;
              var k = u.plotX || 0;
              u = u.plotY || 0;
              let g = 0;
              r = (1.5 * v + (h.plotX || 0)) / 2.5;
              m = (1.5 * f + a3) / 2.5;
              k = (1.5 * v + k) / 2.5;
              n = (1.5 * f + u) / 2.5;
              k !== r && (g = (n - m) * (k - v) / (k - r) + f - n);
              m += g;
              n += g;
              m > a3 && m > f ? (m = Math.max(a3, f), n = 2 * f - m) : m < a3 && m < f && (m = Math.min(a3, f), n = 2 * f - m);
              n > u && n > f ? (n = Math.max(u, f), m = 2 * f - n) : n < u && n < f && (n = Math.min(u, f), m = 2 * f - n);
              w2.rightContX = k;
              w2.rightContY = n;
            }
            w2 = ["C", B(
              h.rightContX,
              h.plotX,
              0
            ), B(h.rightContY, h.plotY, 0), B(r, v, 0), B(m, f, 0), v, f];
            h.rightContX = h.rightContY = void 0;
            return w2;
          }
        }
        E.defaultOptions = K(w.defaultOptions);
        a2.registerSeriesType("spline", E);
        "";
        return E;
      });
      M(a, "Series/AreaSpline/AreaSplineSeries.js", [a["Series/Spline/SplineSeries.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y, H, K) {
        const { area: w, area: { prototype: E } } = H.seriesTypes, { extend: C, merge: A } = K;
        class u extends a2 {
          constructor() {
            super(...arguments);
            this.options = this.points = this.data = void 0;
          }
        }
        u.defaultOptions = A(a2.defaultOptions, w.defaultOptions);
        C(u.prototype, { getGraphPath: E.getGraphPath, getStackPoints: E.getStackPoints, drawGraph: E.drawGraph, drawLegendSymbol: y.drawRectangle });
        H.registerSeriesType("areaspline", u);
        "";
        return u;
      });
      M(a, "Series/Column/ColumnSeriesDefaults.js", [], function() {
        "";
        return { borderRadius: 3, centerInCategory: false, groupPadding: 0.2, marker: null, pointPadding: 0.1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: {
          hover: { halo: false, brightness: 0.1 },
          select: { color: "#cccccc", borderColor: "#000000" }
        }, dataLabels: { align: void 0, verticalAlign: void 0, y: void 0 }, startFromThreshold: true, stickyTracking: false, tooltip: { distance: 6 }, threshold: 0, borderColor: "#ffffff" };
      });
      M(a, "Series/Column/ColumnSeries.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Color/Color.js"], a["Series/Column/ColumnSeriesDefaults.js"], a["Core/Globals.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y, H, K, B, E, C, A) {
        const { animObject: w } = a2, { parse: v } = y, { hasTouch: f, noop: h } = K, { clamp: r, defined: m, extend: n, fireEvent: k, isArray: g, isNumber: I, merge: F, pick: z, objectEach: e } = A;
        class t extends E {
          constructor() {
            super(...arguments);
            this.points = this.options = this.group = this.data = this.borderWidth = void 0;
          }
          animate(a3) {
            const d = this, e2 = this.yAxis, c = e2.pos, b = d.options, f2 = this.chart.inverted, g2 = {}, h2 = f2 ? "translateX" : "translateY";
            let k2;
            a3 ? (g2.scaleY = 1e-3, a3 = r(e2.toPixels(b.threshold), c, c + e2.len), f2 ? g2.translateX = a3 - e2.len : g2.translateY = a3, d.clipBox && d.setClip(), d.group.attr(g2)) : (k2 = Number(d.group.attr(h2)), d.group.animate({ scaleY: 1 }, n(w(d.options.animation), { step: function(a4, b2) {
              d.group && (g2[h2] = k2 + b2.pos * (c - k2), d.group.attr(g2));
            } })));
          }
          init(a3, e2) {
            super.init.apply(this, arguments);
            const d = this;
            a3 = d.chart;
            a3.hasRendered && a3.series.forEach(function(a4) {
              a4.type === d.type && (a4.isDirty = true);
            });
          }
          getColumnMetrics() {
            const a3 = this;
            var e2 = a3.options;
            const f2 = a3.xAxis, c = a3.yAxis;
            var b = f2.options.reversedStacks;
            b = f2.reversed && !b || !f2.reversed && b;
            const g2 = {};
            let l, h2 = 0;
            false === e2.grouping ? h2 = 1 : a3.chart.series.forEach(function(b2) {
              const d = b2.yAxis, e3 = b2.options;
              let f3;
              b2.type !== a3.type || !b2.visible && a3.chart.options.chart.ignoreHiddenSeries || c.len !== d.len || c.pos !== d.pos || (e3.stacking && "group" !== e3.stacking ? (l = b2.stackKey, "undefined" === typeof g2[l] && (g2[l] = h2++), f3 = g2[l]) : false !== e3.grouping && (f3 = h2++), b2.columnIndex = f3);
            });
            const k2 = Math.min(Math.abs(f2.transA) * (f2.ordinal && f2.ordinal.slope || e2.pointRange || f2.closestPointRange || f2.tickInterval || 1), f2.len), m2 = k2 * e2.groupPadding, n2 = (k2 - 2 * m2) / (h2 || 1);
            e2 = Math.min(
              e2.maxPointWidth || f2.len,
              z(e2.pointWidth, n2 * (1 - 2 * e2.pointPadding))
            );
            a3.columnMetrics = { width: e2, offset: (n2 - e2) / 2 + (m2 + ((a3.columnIndex || 0) + (b ? 1 : 0)) * n2 - k2 / 2) * (b ? -1 : 1), paddedWidth: n2, columnCount: h2 };
            return a3.columnMetrics;
          }
          crispCol(a3, e2, f2, c) {
            var b = this.borderWidth, d = -(b % 2 ? 0.5 : 0);
            b = b % 2 ? 0.5 : 1;
            this.options.crisp && (f2 = Math.round(a3 + f2) + d, a3 = Math.round(a3) + d, f2 -= a3);
            c = Math.round(e2 + c) + b;
            d = 0.5 >= Math.abs(e2) && 0.5 < c;
            e2 = Math.round(e2) + b;
            c -= e2;
            d && c && (--e2, c += 1);
            return { x: a3, y: e2, width: f2, height: c };
          }
          adjustForMissingColumns(a3, f2, h2, c) {
            const b = this.options.stacking;
            if (!h2.isNull && 1 < c.columnCount) {
              const d = this.yAxis.options.reversedStacks;
              let l = 0, k2 = d ? 0 : -c.columnCount;
              e(this.yAxis.stacking && this.yAxis.stacking.stacks, (a4) => {
                if ("number" === typeof h2.x) {
                  const c2 = a4[h2.x.toString()];
                  c2 && (a4 = c2.points[this.index], b ? (a4 && (l = k2), c2.hasValidPoints && (d ? k2++ : k2--)) : g(a4) && (a4 = Object.keys(c2.points).filter((a5) => !a5.match(",") && c2.points[a5] && 1 < c2.points[a5].length).map(parseFloat).sort((a5, b2) => b2 - a5), l = a4.indexOf(this.index), k2 = a4.length));
                }
              });
              a3 = (h2.plotX || 0) + ((k2 - 1) * c.paddedWidth + f2) / 2 - f2 - l * c.paddedWidth;
            }
            return a3;
          }
          translate() {
            const a3 = this, e2 = a3.chart, f2 = a3.options;
            var c = a3.dense = 2 > a3.closestPointRange * a3.xAxis.transA;
            c = a3.borderWidth = z(f2.borderWidth, c ? 0 : 1);
            const b = a3.xAxis, g2 = a3.yAxis, l = f2.threshold, h2 = z(f2.minPointLength, 5), n2 = a3.getColumnMetrics(), t2 = n2.width, v2 = a3.pointXOffset = n2.offset, w2 = a3.dataMin, u = a3.dataMax;
            let F2 = a3.barW = Math.max(t2, 1 + 2 * c), y2 = a3.translatedThreshold = g2.getThreshold(l);
            e2.inverted && (y2 -= 0.5);
            f2.pointPadding && (F2 = Math.ceil(F2));
            E.prototype.translate.apply(a3);
            a3.points.forEach(function(c2) {
              const d = z(c2.yBottom, y2);
              var k2 = 999 + Math.abs(d), p = c2.plotX || 0;
              k2 = r(c2.plotY, -k2, g2.len + k2);
              let q = Math.min(k2, d), x = Math.max(k2, d) - q, L = t2, A2 = p + v2, C2 = F2;
              h2 && Math.abs(x) < h2 && (x = h2, p = !g2.reversed && !c2.negative || g2.reversed && c2.negative, I(l) && I(u) && c2.y === l && u <= l && (g2.min || 0) < l && (w2 !== u || (g2.max || 0) <= l) && (p = !p), q = Math.abs(q - y2) > h2 ? d - h2 : y2 - (p ? h2 : 0));
              m(c2.options.pointWidth) && (L = C2 = Math.ceil(c2.options.pointWidth), A2 -= Math.round((L - t2) / 2));
              f2.centerInCategory && (A2 = a3.adjustForMissingColumns(A2, L, c2, n2));
              c2.barX = A2;
              c2.pointWidth = L;
              c2.tooltipPos = e2.inverted ? [r(g2.len + g2.pos - e2.plotLeft - k2, g2.pos - e2.plotLeft, g2.len + g2.pos - e2.plotLeft), b.len + b.pos - e2.plotTop - A2 - C2 / 2, x] : [b.left - e2.plotLeft + A2 + C2 / 2, r(k2 + g2.pos - e2.plotTop, g2.pos - e2.plotTop, g2.len + g2.pos - e2.plotTop), x];
              c2.shapeType = a3.pointClass.prototype.shapeType || "roundedRect";
              c2.shapeArgs = a3.crispCol(A2, c2.isNull ? y2 : q, C2, c2.isNull ? 0 : x);
            });
            k(this, "afterColumnTranslate");
          }
          drawGraph() {
            this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
          }
          pointAttribs(a3, e2) {
            const d = this.options;
            var c = this.pointAttrToOptions || {}, b = c.stroke || "borderColor";
            const f2 = c["stroke-width"] || "borderWidth";
            let g2, h2 = a3 && a3.color || this.color, k2 = a3 && a3[b] || d[b] || h2;
            c = a3 && a3.options.dashStyle || d.dashStyle;
            let n2 = a3 && a3[f2] || d[f2] || this[f2] || 0, m2 = z(a3 && a3.opacity, d.opacity, 1);
            a3 && this.zones.length && (g2 = a3.getZone(), h2 = a3.options.color || g2 && (g2.color || a3.nonZonedColor) || this.color, g2 && (k2 = g2.borderColor || k2, c = g2.dashStyle || c, n2 = g2.borderWidth || n2));
            e2 && a3 && (a3 = F(d.states[e2], a3.options.states && a3.options.states[e2] || {}), e2 = a3.brightness, h2 = a3.color || "undefined" !== typeof e2 && v(h2).brighten(a3.brightness).get() || h2, k2 = a3[b] || k2, n2 = a3[f2] || n2, c = a3.dashStyle || c, m2 = z(a3.opacity, m2));
            b = { fill: h2, stroke: k2, "stroke-width": n2, opacity: m2 };
            c && (b.dashstyle = c);
            return b;
          }
          drawPoints(a3 = this.points) {
            const d = this, e2 = this.chart, c = d.options, b = e2.renderer, f2 = c.animationLimit || 250;
            let g2;
            a3.forEach(function(a4) {
              let l = a4.graphic, h2 = !!l, k2 = l && e2.pointCount < f2 ? "animate" : "attr";
              if (I(a4.plotY) && null !== a4.y) {
                g2 = a4.shapeArgs;
                l && a4.hasNewShapeType() && (l = l.destroy());
                d.enabledDataSorting && (a4.startXPos = d.xAxis.reversed ? -(g2 ? g2.width || 0 : 0) : d.xAxis.width);
                l || (a4.graphic = l = b[a4.shapeType](g2).add(a4.group || d.group)) && d.enabledDataSorting && e2.hasRendered && e2.pointCount < f2 && (l.attr({ x: a4.startXPos }), h2 = true, k2 = "animate");
                if (l && h2)
                  l[k2](F(g2));
                e2.styledMode || l[k2](d.pointAttribs(a4, a4.selected && "select")).shadow(false !== a4.allowShadow && c.shadow);
                l && (l.addClass(a4.getClassName(), true), l.attr({ visibility: a4.visible ? "inherit" : "hidden" }));
              } else
                l && (a4.graphic = l.destroy());
            });
          }
          drawTracker(a3 = this.points) {
            const d = this, e2 = d.chart, c = e2.pointer, b = function(a4) {
              const b2 = c.getPointFromEvent(a4);
              "undefined" !== typeof b2 && (c.isDirectTouch = true, b2.onMouseOver(a4));
            };
            let h2;
            a3.forEach(function(a4) {
              h2 = g(a4.dataLabels) ? a4.dataLabels : a4.dataLabel ? [a4.dataLabel] : [];
              a4.graphic && (a4.graphic.element.point = a4);
              h2.forEach(function(b2) {
                b2.div ? b2.div.point = a4 : b2.element.point = a4;
              });
            });
            d._hasTracking || (d.trackerGroups.forEach(function(a4) {
              if (d[a4]) {
                d[a4].addClass("highcharts-tracker").on("mouseover", b).on("mouseout", function(a5) {
                  c.onTrackerMouseOut(a5);
                });
                if (f)
                  d[a4].on("touchstart", b);
                !e2.styledMode && d.options.cursor && d[a4].css({ cursor: d.options.cursor });
              }
            }), d._hasTracking = true);
            k(this, "afterDrawTracker");
          }
          remove() {
            const a3 = this, e2 = a3.chart;
            e2.hasRendered && e2.series.forEach(function(d) {
              d.type === a3.type && (d.isDirty = true);
            });
            E.prototype.remove.apply(a3, arguments);
          }
        }
        t.defaultOptions = F(E.defaultOptions, H);
        n(t.prototype, { cropShoulder: 0, directTouch: true, drawLegendSymbol: B.drawRectangle, getSymbol: h, negStacks: true, trackerGroups: ["group", "dataLabelsGroup"] });
        C.registerSeriesType("column", t);
        "";
        return t;
      });
      M(a, "Core/Series/DataLabel.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/FormatUtilities.js"], a["Core/Utilities.js"]], function(a2, y, H) {
        const { getDeferredAnimation: w } = a2, { format: B } = y, { defined: E, extend: C, fireEvent: A, isArray: u, isString: v, merge: f, objectEach: h, pick: r, splat: m } = H;
        var n;
        (function(a3) {
          function g(a4, b, d2, e2, f2) {
            const c = this.chart;
            var g2 = this.isCartesian && c.inverted;
            const h2 = this.enabledDataSorting;
            var k2 = a4.plotX, l = a4.plotY;
            const n3 = d2.rotation;
            var m2 = d2.align;
            l = E(k2) && E(l) && c.isInsidePlot(k2, Math.round(l), { inverted: g2, paneCoordinates: true, series: this });
            let p = "justify" === r(d2.overflow, h2 ? "none" : "justify");
            g2 = this.visible && false !== a4.visible && E(k2) && (a4.series.forceDL || h2 && !p || l || r(d2.inside, !!this.options.stacking) && e2 && c.isInsidePlot(k2, g2 ? e2.x + 1 : e2.y + e2.height - 1, { inverted: g2, paneCoordinates: true, series: this }));
            k2 = a4.pos();
            if (g2 && k2) {
              n3 && b.attr({ align: m2 });
              m2 = b.getBBox(true);
              var q2 = [0, 0];
              var t2 = c.renderer.fontMetrics(b).b;
              e2 = C({ x: k2[0], y: Math.round(k2[1]), width: 0, height: 0 }, e2);
              C(d2, { width: m2.width, height: m2.height });
              n3 ? (p = false, q2 = c.renderer.rotCorr(t2, n3), t2 = { x: e2.x + (d2.x || 0) + e2.width / 2 + q2.x, y: e2.y + (d2.y || 0) + { top: 0, middle: 0.5, bottom: 1 }[d2.verticalAlign] * e2.height }, q2 = [
                m2.x - Number(b.attr("x")),
                m2.y - Number(b.attr("y"))
              ], h2 && this.xAxis && !p && this.setDataLabelStartPos(a4, b, f2, l, t2), b[f2 ? "attr" : "animate"](t2)) : (h2 && this.xAxis && !p && this.setDataLabelStartPos(a4, b, f2, l, e2), b.align(d2, void 0, e2), t2 = b.alignAttr);
              if (p && 0 <= e2.height)
                this.justifyDataLabel(b, d2, t2, m2, e2, f2);
              else if (r(d2.crop, true)) {
                let { x: a5, y: b2 } = t2;
                a5 += q2[0];
                b2 += q2[1];
                g2 = c.isInsidePlot(a5, b2, { paneCoordinates: true, series: this }) && c.isInsidePlot(a5 + m2.width, b2 + m2.height, { paneCoordinates: true, series: this });
              }
              if (d2.shape && !n3)
                b[f2 ? "attr" : "animate"]({ anchorX: k2[0], anchorY: k2[1] });
            }
            f2 && h2 && (b.placed = false);
            g2 || h2 && !p ? b.show() : (b.hide(), b.placed = false);
          }
          function k(a4, b) {
            var c = b.filter;
            return c ? (b = c.operator, a4 = a4[c.property], c = c.value, ">" === b && a4 > c || "<" === b && a4 < c || ">=" === b && a4 >= c || "<=" === b && a4 <= c || "==" === b && a4 == c || "===" === b && a4 === c ? true : false) : true;
          }
          function n2() {
            return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6);
          }
          function z(a4) {
            const b = this.hasRendered || 0, c = this.initDataLabelsGroup().attr({ opacity: +b });
            !b && c && (this.visible && c.show(), this.options.animation ? c.animate({ opacity: 1 }, a4) : c.attr({ opacity: 1 }));
            return c;
          }
          function e(a4 = this.points) {
            const b = this, c = b.chart, e2 = b.options, f2 = c.renderer, { backgroundColor: g2, plotBackgroundColor: n3 } = c.options.chart, q2 = f2.getContrast(v(n3) && n3 || v(g2) && g2 || "#000000");
            let t2 = e2.dataLabels, x2, z2;
            var F = m(t2)[0];
            const y2 = F.animation;
            F = F.defer ? w(c, y2, b) : { defer: 0, duration: 0 };
            t2 = d(
              d(c.options.plotOptions && c.options.plotOptions.series && c.options.plotOptions.series.dataLabels, c.options.plotOptions && c.options.plotOptions[b.type] && c.options.plotOptions[b.type].dataLabels),
              t2
            );
            A(this, "drawDataLabels");
            if (u(t2) || t2.enabled || b._hasPointLabels)
              z2 = this.initDataLabels(F), a4.forEach((a5) => {
                x2 = m(d(t2, a5.dlOptions || a5.options && a5.options.dataLabels));
                x2.forEach((d2, g3) => {
                  const l = d2.enabled && (!a5.isNull || a5.dataLabelOnNull) && k(a5, d2), n4 = a5.connectors ? a5.connectors[g3] : a5.connector;
                  let m2, p, t3 = a5.dataLabels ? a5.dataLabels[g3] : a5.dataLabel, v2 = !t3;
                  const w2 = r(d2.distance, a5.labelDistance);
                  if (l) {
                    var x3 = a5.getLabelConfig();
                    var u2 = r(d2[a5.formatPrefix + "Format"], d2.format);
                    x3 = E(u2) ? B(u2, x3, c) : (d2[a5.formatPrefix + "Formatter"] || d2.formatter).call(
                      x3,
                      d2
                    );
                    u2 = d2.style;
                    m2 = d2.rotation;
                    c.styledMode || (u2.color = r(d2.color, u2.color, b.color, "#000000"), "contrast" === u2.color ? (a5.contrastColor = f2.getContrast(a5.color || b.color), u2.color = !E(w2) && d2.inside || 0 > w2 || e2.stacking ? a5.contrastColor : q2) : delete a5.contrastColor, e2.cursor && (u2.cursor = e2.cursor));
                    p = { r: d2.borderRadius || 0, rotation: m2, padding: d2.padding, zIndex: 1 };
                    if (!c.styledMode) {
                      const { backgroundColor: b2, borderColor: c2 } = d2;
                      p.fill = "auto" === b2 ? a5.color : b2;
                      p.stroke = "auto" === c2 ? a5.color : c2;
                      p["stroke-width"] = d2.borderWidth;
                    }
                    h(p, function(a6, b2) {
                      "undefined" === typeof a6 && delete p[b2];
                    });
                  }
                  !t3 || l && E(x3) && !!t3.div === !!d2.useHTML && (t3.rotation && d2.rotation || t3.rotation === d2.rotation) || (v2 = true, a5.dataLabel = t3 = a5.dataLabel && a5.dataLabel.destroy(), a5.dataLabels && (1 === a5.dataLabels.length ? delete a5.dataLabels : delete a5.dataLabels[g3]), g3 || delete a5.dataLabel, n4 && (a5.connector = a5.connector.destroy(), a5.connectors && (1 === a5.connectors.length ? delete a5.connectors : delete a5.connectors[g3])));
                  l && E(x3) ? (t3 ? p.text = x3 : (a5.dataLabels = a5.dataLabels || [], t3 = a5.dataLabels[g3] = m2 ? f2.text(x3, 0, 0, d2.useHTML).addClass("highcharts-data-label") : f2.label(x3, 0, 0, d2.shape, null, null, d2.useHTML, null, "data-label"), g3 || (a5.dataLabel = t3), t3.addClass(" highcharts-data-label-color-" + a5.colorIndex + " " + (d2.className || "") + (d2.useHTML ? " highcharts-tracker" : ""))), t3.options = d2, t3.attr(p), c.styledMode || t3.css(u2).shadow(d2.shadow), (g3 = d2[a5.formatPrefix + "TextPath"] || d2.textPath) && !d2.useHTML && (t3.setTextPath(a5.getDataLabelPath && a5.getDataLabelPath(t3) || a5.graphic, g3), a5.dataLabelPath && !g3.enabled && (a5.dataLabelPath = a5.dataLabelPath.destroy())), t3.added || t3.add(z2), b.alignDataLabel(
                    a5,
                    t3,
                    d2,
                    null,
                    v2
                  )) : t3 && t3.hide();
                });
              });
            A(this, "afterDrawDataLabels");
          }
          function t(a4, b, d2, e2, f2, g2) {
            const c = this.chart, h2 = b.align, k2 = b.verticalAlign, l = a4.box ? 0 : a4.padding || 0;
            let { x: n3 = 0, y: m2 = 0 } = b, p, q2;
            p = (d2.x || 0) + l;
            0 > p && ("right" === h2 && 0 <= n3 ? (b.align = "left", b.inside = true) : n3 -= p, q2 = true);
            p = (d2.x || 0) + e2.width - l;
            p > c.plotWidth && ("left" === h2 && 0 >= n3 ? (b.align = "right", b.inside = true) : n3 += c.plotWidth - p, q2 = true);
            p = d2.y + l;
            0 > p && ("bottom" === k2 && 0 <= m2 ? (b.verticalAlign = "top", b.inside = true) : m2 -= p, q2 = true);
            p = (d2.y || 0) + e2.height - l;
            p > c.plotHeight && ("top" === k2 && 0 >= m2 ? (b.verticalAlign = "bottom", b.inside = true) : m2 += c.plotHeight - p, q2 = true);
            q2 && (b.x = n3, b.y = m2, a4.placed = !g2, a4.align(b, void 0, f2));
            return q2;
          }
          function d(a4, b) {
            let c = [], d2;
            if (u(a4) && !u(b))
              c = a4.map(function(a5) {
                return f(a5, b);
              });
            else if (u(b) && !u(a4))
              c = b.map(function(b2) {
                return f(a4, b2);
              });
            else if (u(a4) || u(b))
              for (d2 = Math.max(a4.length, b.length); d2--; )
                c[d2] = f(a4[d2], b[d2]);
            else
              c = f(a4, b);
            return c;
          }
          function q(a4, b, d2, e2, f2) {
            const c = this.chart, g2 = c.inverted, h2 = this.xAxis, k2 = h2.reversed, l = g2 ? b.height / 2 : b.width / 2;
            a4 = (a4 = a4.pointWidth) ? a4 / 2 : 0;
            b.startXPos = g2 ? f2.x : k2 ? -l - a4 : h2.width - l + a4;
            b.startYPos = g2 ? k2 ? this.yAxis.height - l + a4 : -l - a4 : f2.y;
            e2 ? "hidden" === b.visibility && (b.show(), b.attr({ opacity: 0 }).animate({ opacity: 1 })) : b.attr({ opacity: 1 }).animate({ opacity: 0 }, void 0, b.hide);
            c.hasRendered && (d2 && b.attr({ x: b.startXPos, y: b.startYPos }), b.placed = true);
          }
          const x = [];
          a3.compose = function(a4) {
            H.pushUnique(x, a4) && (a4 = a4.prototype, a4.initDataLabelsGroup = n2, a4.initDataLabels = z, a4.alignDataLabel = g, a4.drawDataLabels = e, a4.justifyDataLabel = t, a4.setDataLabelStartPos = q);
          };
        })(n || (n = {}));
        "";
        return n;
      });
      M(
        a,
        "Series/Column/ColumnDataLabel.js",
        [a["Core/Series/DataLabel.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]],
        function(a2, y, H) {
          const { series: w } = y, { merge: B, pick: E } = H;
          var C;
          (function(y2) {
            function u(a3, h, r, m, n) {
              let f = this.chart.inverted;
              var g = a3.series;
              let v2 = (g.xAxis ? g.xAxis.len : this.chart.plotSizeX) || 0;
              g = (g.yAxis ? g.yAxis.len : this.chart.plotSizeY) || 0;
              var u2 = a3.dlBox || a3.shapeArgs;
              let z = E(a3.below, a3.plotY > E(this.translatedThreshold, g)), e = E(r.inside, !!this.options.stacking);
              u2 && (m = B(u2), 0 > m.y && (m.height += m.y, m.y = 0), u2 = m.y + m.height - g, 0 < u2 && u2 < m.height && (m.height -= u2), f && (m = { x: g - m.y - m.height, y: v2 - m.x - m.width, width: m.height, height: m.width }), e || (f ? (m.x += z ? 0 : m.width, m.width = 0) : (m.y += z ? m.height : 0, m.height = 0)));
              r.align = E(r.align, !f || e ? "center" : z ? "right" : "left");
              r.verticalAlign = E(r.verticalAlign, f || e ? "middle" : z ? "top" : "bottom");
              w.prototype.alignDataLabel.call(this, a3, h, r, m, n);
              r.inside && a3.contrastColor && h.css({ color: a3.contrastColor });
            }
            const v = [];
            y2.compose = function(f) {
              a2.compose(w);
              H.pushUnique(v, f) && (f.prototype.alignDataLabel = u);
            };
          })(C || (C = {}));
          return C;
        }
      );
      M(a, "Series/Bar/BarSeries.js", [a["Series/Column/ColumnSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y, H) {
        const { extend: w, merge: B } = H;
        class E extends a2 {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
        }
        E.defaultOptions = B(a2.defaultOptions, {});
        w(E.prototype, { inverted: true });
        y.registerSeriesType("bar", E);
        "";
        return E;
      });
      M(a, "Series/Scatter/ScatterSeriesDefaults.js", [], function() {
        "";
        return { lineWidth: 0, findNearestPointBy: "xy", jitter: {
          x: 0,
          y: 0
        }, marker: { enabled: true }, tooltip: { headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 0.8em"> {series.name}</span><br/>', pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>" } };
      });
      M(a, "Series/Scatter/ScatterSeries.js", [a["Series/Scatter/ScatterSeriesDefaults.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, y, H) {
        const { column: w, line: B } = y.seriesTypes, { addEvent: E, extend: C, merge: A } = H;
        class u extends B {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          applyJitter() {
            const a3 = this, f = this.options.jitter, h = this.points.length;
            f && this.points.forEach(function(r, m) {
              ["x", "y"].forEach(function(n, k) {
                let g = "plot" + n.toUpperCase(), v, w2;
                if (f[n] && !r.isNull) {
                  var u2 = a3[n + "Axis"];
                  w2 = f[n] * u2.transA;
                  u2 && !u2.isLog && (v = Math.max(0, r[g] - w2), u2 = Math.min(u2.len, r[g] + w2), k = 1e4 * Math.sin(m + k * h), k -= Math.floor(k), r[g] = v + (u2 - v) * k, "x" === n && (r.clientX = r.plotX));
                }
              });
            });
          }
          drawGraph() {
            this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());
          }
        }
        u.defaultOptions = A(B.defaultOptions, a2);
        C(u.prototype, { drawTracker: w.prototype.drawTracker, sorted: false, requireSorting: false, noSharedTooltip: true, trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], takeOrdinalPosition: false });
        E(u, "afterTranslate", function() {
          this.applyJitter();
        });
        y.registerSeriesType("scatter", u);
        return u;
      });
      M(a, "Series/CenteredUtilities.js", [a["Core/Globals.js"], a["Core/Series/Series.js"], a["Core/Utilities.js"]], function(a2, y, H) {
        const { deg2rad: w } = a2, { fireEvent: B, isNumber: E, pick: C, relativeLength: A } = H;
        var u;
        (function(a3) {
          a3.getCenter = function() {
            var a4 = this.options, h = this.chart;
            const r = 2 * (a4.slicedOffset || 0), m = h.plotWidth - 2 * r, n = h.plotHeight - 2 * r;
            var k = a4.center;
            const g = Math.min(m, n), v = a4.thickness;
            var w2 = a4.size;
            let u2 = a4.innerSize || 0;
            "string" === typeof w2 && (w2 = parseFloat(w2));
            "string" === typeof u2 && (u2 = parseFloat(u2));
            a4 = [C(k[0], "50%"), C(k[1], "50%"), C(w2 && 0 > w2 ? void 0 : a4.size, "100%"), C(u2 && 0 > u2 ? void 0 : a4.innerSize || 0, "0%")];
            !h.angular || this instanceof y || (a4[3] = 0);
            for (k = 0; 4 > k; ++k)
              w2 = a4[k], h = 2 > k || 2 === k && /%$/.test(w2), a4[k] = A(w2, [m, n, g, a4[2]][k]) + (h ? r : 0);
            a4[3] > a4[2] && (a4[3] = a4[2]);
            E(v) && 2 * v < a4[2] && 0 < v && (a4[3] = a4[2] - 2 * v);
            B(this, "afterGetCenter", { positions: a4 });
            return a4;
          };
          a3.getStartAndEndRadians = function(a4, h) {
            a4 = E(a4) ? a4 : 0;
            h = E(h) && h > a4 && 360 > h - a4 ? h : a4 + 360;
            return { start: w * (a4 + -90), end: w * (h + -90) };
          };
        })(u || (u = {}));
        "";
        return u;
      });
      M(a, "Series/Pie/PiePoint.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Series/Point.js"], a["Core/Utilities.js"]], function(a2, y, H) {
        const { setAnimation: w } = a2, { addEvent: B, defined: E, extend: C, isNumber: A, pick: u, relativeLength: v } = H;
        class f extends y {
          constructor() {
            super(...arguments);
            this.series = this.options = this.labelDistance = void 0;
          }
          getConnectorPath() {
            const a3 = this.labelPosition, f2 = this.series.options.dataLabels, m = this.connectorShapes;
            let n = f2.connectorShape;
            m[n] && (n = m[n]);
            return n.call(this, { x: a3.computed.x, y: a3.computed.y, alignment: a3.alignment }, a3.connectorPosition, f2);
          }
          getTranslate() {
            return this.sliced ? this.slicedTranslation : { translateX: 0, translateY: 0 };
          }
          haloPath(a3) {
            const f2 = this.shapeArgs;
            return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(
              f2.x,
              f2.y,
              f2.r + a3,
              f2.r + a3,
              { innerR: f2.r - 1, start: f2.start, end: f2.end, borderRadius: f2.borderRadius }
            );
          }
          init() {
            super.init.apply(this, arguments);
            this.name = u(this.name, "Slice");
            const a3 = (a4) => {
              this.slice("select" === a4.type);
            };
            B(this, "select", a3);
            B(this, "unselect", a3);
            return this;
          }
          isValid() {
            return A(this.y) && 0 <= this.y;
          }
          setVisible(a3, f2) {
            const h = this.series, n = h.chart, k = h.options.ignoreHiddenPoint;
            f2 = u(f2, k);
            a3 !== this.visible && (this.visible = this.options.visible = a3 = "undefined" === typeof a3 ? !this.visible : a3, h.options.data[h.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector"].forEach((f3) => {
              if (this[f3])
                this[f3][a3 ? "show" : "hide"](a3);
            }), this.legendItem && n.legend.colorizeItem(this, a3), a3 || "hover" !== this.state || this.setState(""), k && (h.isDirty = true), f2 && n.redraw());
          }
          slice(a3, f2, m) {
            const h = this.series;
            w(m, h.chart);
            u(f2, true);
            this.sliced = this.options.sliced = E(a3) ? a3 : !this.sliced;
            h.options.data[h.data.indexOf(this)] = this.options;
            this.graphic && this.graphic.animate(this.getTranslate());
          }
        }
        C(f.prototype, { connectorShapes: { fixedOffset: function(a3, f2, m) {
          const h = f2.breakAt;
          f2 = f2.touchingSliceAt;
          return [["M", a3.x, a3.y], m.softConnector ? ["C", a3.x + ("left" === a3.alignment ? -5 : 5), a3.y, 2 * h.x - f2.x, 2 * h.y - f2.y, h.x, h.y] : ["L", h.x, h.y], ["L", f2.x, f2.y]];
        }, straight: function(a3, f2) {
          f2 = f2.touchingSliceAt;
          return [["M", a3.x, a3.y], ["L", f2.x, f2.y]];
        }, crookedLine: function(a3, f2, m) {
          const { breakAt: h, touchingSliceAt: k } = f2;
          ({ series: f2 } = this);
          const [g, r, w2] = f2.center, u2 = w2 / 2, e = f2.chart.plotWidth, t = f2.chart.plotLeft;
          f2 = "left" === a3.alignment;
          const { x: d, y: q } = a3;
          m.crookDistance ? (a3 = v(m.crookDistance, 1), a3 = f2 ? g + u2 + (e + t - g - u2) * (1 - a3) : t + (g - u2) * a3) : a3 = g + (r - q) * Math.tan((this.angle || 0) - Math.PI / 2);
          m = [["M", d, q]];
          (f2 ? a3 <= d && a3 >= h.x : a3 >= d && a3 <= h.x) && m.push(["L", a3, q]);
          m.push(["L", h.x, h.y], ["L", k.x, k.y]);
          return m;
        } } });
        return f;
      });
      M(a, "Series/Pie/PieSeriesDefaults.js", [], function() {
        "";
        return { borderRadius: 3, center: [null, null], clip: false, colorByPoint: true, dataLabels: {
          allowOverlap: true,
          connectorPadding: 5,
          connectorShape: "crookedLine",
          crookDistance: void 0,
          distance: 30,
          enabled: true,
          formatter: function() {
            return this.point.isNull ? void 0 : this.point.name;
          },
          softConnector: true,
          x: 0
        }, fillColor: void 0, ignoreHiddenPoint: true, inactiveOtherPoints: true, legendType: "point", marker: null, size: null, showInLegend: false, slicedOffset: 10, stickyTracking: false, tooltip: { followPointer: true }, borderColor: "#ffffff", borderWidth: 1, lineWidth: void 0, states: { hover: { brightness: 0.1 } } };
      });
      M(a, "Series/Pie/PieSeries.js", [
        a["Series/CenteredUtilities.js"],
        a["Series/Column/ColumnSeries.js"],
        a["Core/Globals.js"],
        a["Core/Legend/LegendSymbol.js"],
        a["Series/Pie/PiePoint.js"],
        a["Series/Pie/PieSeriesDefaults.js"],
        a["Core/Series/Series.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Renderer/SVG/Symbols.js"],
        a["Core/Utilities.js"]
      ], function(a2, y, H, K, B, E, C, A, u, v) {
        const { getStartAndEndRadians: f } = a2;
        ({ noop: H } = H);
        const { clamp: h, extend: r, fireEvent: m, merge: n, pick: k, relativeLength: g } = v;
        class w extends C {
          constructor() {
            super(...arguments);
            this.points = this.options = this.maxLabelDistance = this.data = this.center = void 0;
          }
          animate(a3) {
            const f2 = this, e = f2.points, g2 = f2.startAngleRad;
            a3 || e.forEach(function(a4) {
              const d = a4.graphic, e2 = a4.shapeArgs;
              d && e2 && (d.attr({ r: k(
                a4.startR,
                f2.center && f2.center[3] / 2
              ), start: g2, end: g2 }), d.animate({ r: e2.r, start: e2.start, end: e2.end }, f2.options.animation));
            });
          }
          drawEmpty() {
            const a3 = this.startAngleRad, f2 = this.endAngleRad, e = this.options;
            let g2, d;
            0 === this.total && this.center ? (g2 = this.center[0], d = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(g2, d, this.center[1] / 2, 0, a3, f2).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({ d: u.arc(g2, d, this.center[2] / 2, 0, { start: a3, end: f2, innerR: this.center[3] / 2 }) }), this.chart.styledMode || this.graph.attr({
              "stroke-width": e.borderWidth,
              fill: e.fillColor || "none",
              stroke: e.color || "#cccccc"
            })) : this.graph && (this.graph = this.graph.destroy());
          }
          drawPoints() {
            const a3 = this.chart.renderer;
            this.points.forEach(function(f2) {
              f2.graphic && f2.hasNewShapeType() && (f2.graphic = f2.graphic.destroy());
              f2.graphic || (f2.graphic = a3[f2.shapeType](f2.shapeArgs).add(f2.series.group), f2.delayedRendering = true);
            });
          }
          generatePoints() {
            super.generatePoints();
            this.updateTotals();
          }
          getX(a3, f2, e) {
            const g2 = this.center, d = this.radii ? this.radii[e.index] || 0 : g2[2] / 2;
            a3 = Math.asin(h(
              (a3 - g2[1]) / (d + e.labelDistance),
              -1,
              1
            ));
            return g2[0] + (f2 ? -1 : 1) * Math.cos(a3) * (d + e.labelDistance) + (0 < e.labelDistance ? (f2 ? -1 : 1) * this.options.dataLabels.padding : 0);
          }
          hasData() {
            return !!this.processedXData.length;
          }
          redrawPoints() {
            const a3 = this, f2 = a3.chart;
            let e, g2, d, k2;
            this.drawEmpty();
            a3.group && !f2.styledMode && a3.group.shadow(a3.options.shadow);
            a3.points.forEach(function(h2) {
              const c = {};
              g2 = h2.graphic;
              !h2.isNull && g2 ? (k2 = h2.shapeArgs, e = h2.getTranslate(), f2.styledMode || (d = a3.pointAttribs(h2, h2.selected && "select")), h2.delayedRendering ? (g2.setRadialReference(a3.center).attr(k2).attr(e), f2.styledMode || g2.attr(d).attr({ "stroke-linejoin": "round" }), h2.delayedRendering = false) : (g2.setRadialReference(a3.center), f2.styledMode || n(true, c, d), n(true, c, k2, e), g2.animate(c)), g2.attr({ visibility: h2.visible ? "inherit" : "hidden" }), g2.addClass(h2.getClassName(), true)) : g2 && (h2.graphic = g2.destroy());
            });
          }
          sortByAngle(a3, f2) {
            a3.sort(function(a4, g2) {
              return "undefined" !== typeof a4.angle && (g2.angle - a4.angle) * f2;
            });
          }
          translate(a3) {
            m(this, "translate");
            this.generatePoints();
            var h2 = this.options;
            const e = h2.slicedOffset, n2 = e + (h2.borderWidth || 0);
            var d = f(
              h2.startAngle,
              h2.endAngle
            );
            const q = this.startAngleRad = d.start;
            d = (this.endAngleRad = d.end) - q;
            const r2 = this.points, c = h2.dataLabels.distance;
            h2 = h2.ignoreHiddenPoint;
            const b = r2.length;
            let p, l, w2, v2 = 0;
            a3 || (this.center = a3 = this.getCenter());
            for (l = 0; l < b; l++) {
              w2 = r2[l];
              var u2 = q + v2 * d;
              !w2.isValid() || h2 && !w2.visible || (v2 += w2.percentage / 100);
              var y2 = q + v2 * d;
              var A2 = { x: a3[0], y: a3[1], r: a3[2] / 2, innerR: a3[3] / 2, start: Math.round(1e3 * u2) / 1e3, end: Math.round(1e3 * y2) / 1e3 };
              w2.shapeType = "arc";
              w2.shapeArgs = A2;
              w2.labelDistance = k(
                w2.options.dataLabels && w2.options.dataLabels.distance,
                c
              );
              w2.labelDistance = g(w2.labelDistance, A2.r);
              this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, w2.labelDistance);
              y2 = (y2 + u2) / 2;
              y2 > 1.5 * Math.PI ? y2 -= 2 * Math.PI : y2 < -Math.PI / 2 && (y2 += 2 * Math.PI);
              w2.slicedTranslation = { translateX: Math.round(Math.cos(y2) * e), translateY: Math.round(Math.sin(y2) * e) };
              A2 = Math.cos(y2) * a3[2] / 2;
              p = Math.sin(y2) * a3[2] / 2;
              w2.tooltipPos = [a3[0] + 0.7 * A2, a3[1] + 0.7 * p];
              w2.half = y2 < -Math.PI / 2 || y2 > Math.PI / 2 ? 1 : 0;
              w2.angle = y2;
              u2 = Math.min(n2, w2.labelDistance / 5);
              w2.labelPosition = { natural: { x: a3[0] + A2 + Math.cos(y2) * w2.labelDistance, y: a3[1] + p + Math.sin(y2) * w2.labelDistance }, computed: {}, alignment: 0 > w2.labelDistance ? "center" : w2.half ? "right" : "left", connectorPosition: { breakAt: { x: a3[0] + A2 + Math.cos(y2) * u2, y: a3[1] + p + Math.sin(y2) * u2 }, touchingSliceAt: { x: a3[0] + A2, y: a3[1] + p } } };
            }
            m(this, "afterTranslate");
          }
          updateTotals() {
            const a3 = this.points, f2 = a3.length, e = this.options.ignoreHiddenPoint;
            let g2, d, h2 = 0;
            for (g2 = 0; g2 < f2; g2++)
              d = a3[g2], !d.isValid() || e && !d.visible || (h2 += d.y);
            this.total = h2;
            for (g2 = 0; g2 < f2; g2++)
              d = a3[g2], d.percentage = 0 < h2 && (d.visible || !e) ? d.y / h2 * 100 : 0, d.total = h2;
          }
        }
        w.defaultOptions = n(C.defaultOptions, E);
        r(w.prototype, { axisTypes: [], directTouch: true, drawGraph: void 0, drawLegendSymbol: K.drawRectangle, drawTracker: y.prototype.drawTracker, getCenter: a2.getCenter, getSymbol: H, isCartesian: false, noSharedTooltip: true, pointAttribs: y.prototype.pointAttribs, pointClass: B, requireSorting: false, searchPoint: H, trackerGroups: ["group", "dataLabelsGroup"] });
        A.registerSeriesType("pie", w);
        return w;
      });
      M(a, "Series/Pie/PieDataLabel.js", [
        a["Core/Series/DataLabel.js"],
        a["Core/Globals.js"],
        a["Core/Renderer/RendererUtilities.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Utilities.js"]
      ], function(a2, y, H, K, B) {
        const { noop: w } = y, { distribute: C } = H, { series: A } = K, { arrayMax: u, clamp: v, defined: f, merge: h, pick: r, relativeLength: m } = B;
        var n;
        (function(k) {
          function g() {
            const a3 = this, d = a3.data, e2 = a3.chart, g2 = a3.options.dataLabels || {}, c = g2.connectorPadding, b = e2.plotWidth, k2 = e2.plotHeight, l = e2.plotLeft, m2 = Math.round(e2.chartWidth / 3), n3 = a3.center, w2 = n3[2] / 2, v2 = n3[1], z2 = [[], []], y3 = [0, 0, 0, 0], F = a3.dataLabelPositioners;
            let B2, E, I, H2, D, K2, J, M2, R, V, T2, aa;
            a3.visible && (g2.enabled || a3._hasPointLabels) && (d.forEach(function(a4) {
              a4.dataLabel && a4.visible && a4.dataLabel.shortened && (a4.dataLabel.attr({ width: "auto" }).css({ width: "auto", textOverflow: "clip" }), a4.dataLabel.shortened = false);
            }), A.prototype.drawDataLabels.apply(a3), d.forEach(function(a4) {
              a4.dataLabel && (a4.visible ? (z2[a4.half].push(a4), a4.dataLabel._pos = null, !f(g2.style.width) && !f(a4.options.dataLabels && a4.options.dataLabels.style && a4.options.dataLabels.style.width) && a4.dataLabel.getBBox().width > m2 && (a4.dataLabel.css({ width: Math.round(0.7 * m2) + "px" }), a4.dataLabel.shortened = true)) : (a4.dataLabel = a4.dataLabel.destroy(), a4.dataLabels && 1 === a4.dataLabels.length && delete a4.dataLabels));
            }), z2.forEach((d2, h2) => {
              const m3 = d2.length, p = [];
              let q, t = 0;
              if (m3) {
                a3.sortByAngle(d2, h2 - 0.5);
                if (0 < a3.maxLabelDistance) {
                  var u2 = Math.max(0, v2 - w2 - a3.maxLabelDistance);
                  q = Math.min(v2 + w2 + a3.maxLabelDistance, e2.plotHeight);
                  d2.forEach(function(a4) {
                    0 < a4.labelDistance && a4.dataLabel && (a4.top = Math.max(0, v2 - w2 - a4.labelDistance), a4.bottom = Math.min(v2 + w2 + a4.labelDistance, e2.plotHeight), t = a4.dataLabel.getBBox().height || 21, a4.distributeBox = { target: a4.labelPosition.natural.y - a4.top + t / 2, size: t, rank: a4.y }, p.push(a4.distributeBox));
                  });
                  u2 = q + t - u2;
                  C(p, u2, u2 / 5);
                }
                for (T2 = 0; T2 < m3; T2++) {
                  B2 = d2[T2];
                  K2 = B2.labelPosition;
                  H2 = B2.dataLabel;
                  V = false === B2.visible ? "hidden" : "inherit";
                  R = u2 = K2.natural.y;
                  p && f(B2.distributeBox) && ("undefined" === typeof B2.distributeBox.pos ? V = "hidden" : (J = B2.distributeBox.size, R = F.radialDistributionY(B2)));
                  delete B2.positionIndex;
                  if (g2.justify)
                    M2 = F.justify(B2, w2, n3);
                  else
                    switch (g2.alignTo) {
                      case "connectors":
                        M2 = F.alignToConnectors(d2, h2, b, l);
                        break;
                      case "plotEdges":
                        M2 = F.alignToPlotEdges(H2, h2, b, l);
                        break;
                      default:
                        M2 = F.radialDistributionX(a3, B2, R, u2);
                    }
                  H2._attr = { visibility: V, align: K2.alignment };
                  aa = B2.options.dataLabels || {};
                  H2._pos = { x: M2 + r(aa.x, g2.x) + ({ left: c, right: -c }[K2.alignment] || 0), y: R + r(aa.y, g2.y) - H2.getBBox().height / 2 };
                  K2 && (K2.computed.x = M2, K2.computed.y = R);
                  r(g2.crop, true) && (D = H2.getBBox().width, u2 = null, M2 - D < c && 1 === h2 ? (u2 = Math.round(D - M2 + c), y3[3] = Math.max(u2, y3[3])) : M2 + D > b - c && 0 === h2 && (u2 = Math.round(M2 + D - b + c), y3[1] = Math.max(u2, y3[1])), 0 > R - J / 2 ? y3[0] = Math.max(Math.round(-R + J / 2), y3[0]) : R + J / 2 > k2 && (y3[2] = Math.max(Math.round(R + J / 2 - k2), y3[2])), H2.sideOverflow = u2);
                }
              }
            }), 0 === u(y3) || this.verifyDataLabelOverflow(y3)) && (this.placeDataLabels(), this.points.forEach(function(b2) {
              aa = h(g2, b2.options.dataLabels);
              if (E = r(aa.connectorWidth, 1)) {
                let c2;
                I = b2.connector;
                if ((H2 = b2.dataLabel) && H2._pos && b2.visible && 0 < b2.labelDistance) {
                  V = H2._attr.visibility;
                  if (c2 = !I)
                    b2.connector = I = e2.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + b2.colorIndex + (b2.className ? " " + b2.className : "")).add(a3.dataLabelsGroup), e2.styledMode || I.attr({ "stroke-width": E, stroke: aa.connectorColor || b2.color || "#666666" });
                  I[c2 ? "attr" : "animate"]({ d: b2.getConnectorPath() });
                  I.attr("visibility", V);
                } else
                  I && (b2.connector = I.destroy());
              }
            }));
          }
          function n2() {
            this.points.forEach(function(a3) {
              let d = a3.dataLabel, e2;
              d && a3.visible && ((e2 = d._pos) ? (d.sideOverflow && (d._attr.width = Math.max(d.getBBox().width - d.sideOverflow, 0), d.css({ width: d._attr.width + "px", textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis" }), d.shortened = true), d.attr(d._attr), d[d.moved ? "animate" : "attr"](e2), d.moved = true) : d && d.attr({ y: -9999 }));
              delete a3.distributeBox;
            }, this);
          }
          function y2(a3) {
            let d = this.center, e2 = this.options, f2 = e2.center, c = e2.minSize || 80, b, g2 = null !== e2.size;
            g2 || (null !== f2[0] ? b = Math.max(d[2] - Math.max(a3[1], a3[3]), c) : (b = Math.max(d[2] - a3[1] - a3[3], c), d[0] += (a3[3] - a3[1]) / 2), null !== f2[1] ? b = v(b, c, d[2] - Math.max(a3[0], a3[2])) : (b = v(b, c, d[2] - a3[0] - a3[2]), d[1] += (a3[0] - a3[2]) / 2), b < d[2] ? (d[2] = b, d[3] = Math.min(e2.thickness ? Math.max(0, b - 2 * e2.thickness) : Math.max(0, m(e2.innerSize || 0, b)), b), this.translate(d), this.drawDataLabels && this.drawDataLabels()) : g2 = true);
            return g2;
          }
          const z = [], e = { radialDistributionY: function(a3) {
            return a3.top + a3.distributeBox.pos;
          }, radialDistributionX: function(a3, d, e2, f2) {
            return a3.getX(e2 < d.top + 2 || e2 > d.bottom - 2 ? f2 : e2, d.half, d);
          }, justify: function(a3, d, e2) {
            return e2[0] + (a3.half ? -1 : 1) * (d + a3.labelDistance);
          }, alignToPlotEdges: function(a3, d, e2, f2) {
            a3 = a3.getBBox().width;
            return d ? a3 + f2 : e2 - a3 - f2;
          }, alignToConnectors: function(a3, d, e2, f2) {
            let c = 0, b;
            a3.forEach(function(a4) {
              b = a4.dataLabel.getBBox().width;
              b > c && (c = b);
            });
            return d ? c + f2 : e2 - c - f2;
          } };
          k.compose = function(f2) {
            a2.compose(A);
            B.pushUnique(z, f2) && (f2 = f2.prototype, f2.dataLabelPositioners = e, f2.alignDataLabel = w, f2.drawDataLabels = g, f2.placeDataLabels = n2, f2.verifyDataLabelOverflow = y2);
          };
        })(n || (n = {}));
        return n;
      });
      M(a, "Extensions/OverlappingDataLabels.js", [a["Core/Chart/Chart.js"], a["Core/Utilities.js"]], function(a2, y) {
        function w(a3, f) {
          let h, r = false;
          a3 && (h = a3.newOpacity, a3.oldOpacity !== h && (a3.alignAttr && a3.placed ? (a3[h ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), r = true, a3.alignAttr.opacity = h, a3[a3.isOld ? "animate" : "attr"](a3.alignAttr, null, function() {
            f.styledMode || a3.css({ pointerEvents: h ? "auto" : "none" });
          }), B(f, "afterHideOverlappingLabel")) : a3.attr({ opacity: h })), a3.isOld = true);
          return r;
        }
        const { addEvent: K, fireEvent: B, isArray: E, isNumber: C, objectEach: A, pick: u } = y;
        K(a2, "render", function() {
          let a3 = this, f = [];
          (this.labelCollectors || []).forEach(function(a4) {
            f = f.concat(a4());
          });
          (this.yAxis || []).forEach(function(a4) {
            a4.stacking && a4.options.stackLabels && !a4.options.stackLabels.allowOverlap && A(a4.stacking.stacks, function(a5) {
              A(a5, function(a6) {
                a6.label && f.push(a6.label);
              });
            });
          });
          (this.series || []).forEach(function(h) {
            var r = h.options.dataLabels;
            h.visible && (false !== r.enabled || h._hasPointLabels) && (r = (h2) => h2.forEach((h3) => {
              h3.visible && (E(h3.dataLabels) ? h3.dataLabels : h3.dataLabel ? [h3.dataLabel] : []).forEach(function(k) {
                const g = k.options;
                k.labelrank = u(g.labelrank, h3.labelrank, h3.shapeArgs && h3.shapeArgs.height);
                g.allowOverlap ? (k.oldOpacity = k.opacity, k.newOpacity = 1, w(k, a3)) : f.push(k);
              });
            }), r(h.nodes || []), r(h.points));
          });
          this.hideOverlappingLabels(f);
        });
        a2.prototype.hideOverlappingLabels = function(a3) {
          let f = this, h = a3.length, r = f.renderer;
          var m;
          let n;
          let k, g, u2, v = false;
          var z = function(a4) {
            let e, d;
            var f2;
            let g2 = a4.box ? 0 : a4.padding || 0, c = f2 = 0, b, h2;
            if (a4 && (!a4.alignAttr || a4.placed))
              return e = a4.alignAttr || { x: a4.attr("x"), y: a4.attr("y") }, d = a4.parentGroup, a4.width || (f2 = a4.getBBox(), a4.width = f2.width, a4.height = f2.height, f2 = r.fontMetrics(a4.element).h), b = a4.width - 2 * g2, (h2 = { left: "0", center: "0.5", right: "1" }[a4.alignValue]) ? c = +h2 * b : C(a4.x) && Math.round(a4.x) !== a4.translateX && (c = a4.x - a4.translateX), { x: e.x + (d.translateX || 0) + g2 - (c || 0), y: e.y + (d.translateY || 0) + g2 - f2, width: a4.width - 2 * g2, height: a4.height - 2 * g2 };
          };
          for (n = 0; n < h; n++)
            if (m = a3[n])
              m.oldOpacity = m.opacity, m.newOpacity = 1, m.absoluteBox = z(m);
          a3.sort(function(a4, f2) {
            return (f2.labelrank || 0) - (a4.labelrank || 0);
          });
          for (n = 0; n < h; n++)
            for (g = (z = a3[n]) && z.absoluteBox, m = n + 1; m < h; ++m)
              u2 = (k = a3[m]) && k.absoluteBox, !g || !u2 || z === k || 0 === z.newOpacity || 0 === k.newOpacity || "hidden" === z.visibility || "hidden" === k.visibility || u2.x >= g.x + g.width || u2.x + u2.width <= g.x || u2.y >= g.y + g.height || u2.y + u2.height <= g.y || ((z.labelrank < k.labelrank ? z : k).newOpacity = 0);
          a3.forEach(function(a4) {
            w(a4, f) && (v = true);
          });
          v && B(f, "afterHideAllOverlappingLabels");
        };
      });
      M(a, "Extensions/BorderRadius.js", [a["Core/Defaults.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function(a2, y, H, K, B, E) {
        const { defaultOptions: w } = a2;
        ({ seriesTypes: a2 } = H);
        const { addEvent: A, extend: u, isObject: v, merge: f, relativeLength: h } = E, r = { radius: 0, scope: "stack", where: void 0 }, m = (a3, h2) => {
          v(a3) || (a3 = { radius: a3 || 0 });
          return f(r, h2, a3);
        };
        if (-1 === K.symbolCustomAttribs.indexOf("borderRadius")) {
          K.symbolCustomAttribs.push(
            "borderRadius",
            "brBoxHeight",
            "brBoxY"
          );
          const f2 = B.prototype.symbols.arc;
          B.prototype.symbols.arc = function(a3, k2, m2, n, e = {}) {
            a3 = f2(a3, k2, m2, n, e);
            const { innerR: g = 0, r: d = m2, start: q = 0, end: r2 = 0 } = e;
            if (e.open || !e.borderRadius)
              return a3;
            m2 = r2 - q;
            k2 = Math.sin(m2 / 2);
            e = Math.max(Math.min(h(e.borderRadius || 0, d - g), (d - g) / 2, d * k2 / (1 + k2)), 0);
            m2 = Math.min(e, m2 / Math.PI * 2 * g);
            for (k2 = a3.length - 1; k2--; ) {
              {
                let d2 = void 0, f3 = void 0, g2 = void 0;
                n = a3;
                var c = k2, b = 1 < k2 ? m2 : e, p = n[c], l = n[c + 1];
                "Z" === l[0] && (l = n[0]);
                "M" !== p[0] && "L" !== p[0] || "A" !== l[0] ? "A" !== p[0] || "M" !== l[0] && "L" !== l[0] || (g2 = l, f3 = p) : (g2 = p, f3 = l, d2 = true);
                if (g2 && f3 && f3.params) {
                  p = f3[1];
                  var w2 = f3[5];
                  l = f3.params;
                  const { start: a4, end: e2, cx: h2, cy: k3 } = l;
                  var u2 = w2 ? p - b : p + b;
                  const m3 = u2 ? Math.asin(b / u2) : 0;
                  w2 = w2 ? m3 : -m3;
                  u2 *= Math.cos(m3);
                  d2 ? (l.start = a4 + w2, g2[1] = h2 + u2 * Math.cos(a4), g2[2] = k3 + u2 * Math.sin(a4), n.splice(c + 1, 0, ["A", b, b, 0, 0, 1, h2 + p * Math.cos(l.start), k3 + p * Math.sin(l.start)])) : (l.end = e2 - w2, f3[6] = h2 + p * Math.cos(l.end), f3[7] = k3 + p * Math.sin(l.end), n.splice(c + 1, 0, ["A", b, b, 0, 0, 1, h2 + u2 * Math.cos(e2), k3 + u2 * Math.sin(e2)]));
                  f3[4] = Math.abs(l.end - l.start) < Math.PI ? 0 : 1;
                }
              }
            }
            return a3;
          };
          const k = B.prototype.symbols.roundedRect;
          B.prototype.symbols.roundedRect = function(a3, f3, h2, m2, e = {}) {
            const g = k(a3, f3, h2, m2, e), { r: d = 0, brBoxHeight: n = m2, brBoxY: r2 = f3 } = e;
            var c = f3 - r2, b = r2 + n - (f3 + m2);
            e = -0.1 < c - d ? 0 : d;
            const p = -0.1 < b - d ? 0 : d;
            var l = Math.max(e && c, 0);
            const w2 = Math.max(p && b, 0);
            b = [a3 + e, f3];
            c = [a3 + h2 - e, f3];
            const u2 = [a3 + h2, f3 + e], v2 = [a3 + h2, f3 + m2 - p], z = [a3 + h2 - p, f3 + m2], y2 = [a3 + p, f3 + m2], A2 = [a3, f3 + m2 - p], B2 = [a3, f3 + e];
            if (l) {
              const a4 = Math.sqrt(Math.pow(e, 2) - Math.pow(e - l, 2));
              b[0] -= a4;
              c[0] += a4;
              u2[1] = B2[1] = f3 + e - l;
            }
            m2 < e - l && (l = Math.sqrt(Math.pow(e, 2) - Math.pow(e - l - m2, 2)), u2[0] = v2[0] = a3 + h2 - e + l, z[0] = Math.min(u2[0], z[0]), y2[0] = Math.max(v2[0], y2[0]), A2[0] = B2[0] = a3 + e - l, u2[1] = B2[1] = f3 + m2);
            w2 && (l = Math.sqrt(Math.pow(p, 2) - Math.pow(p - w2, 2)), z[0] += l, y2[0] -= l, v2[1] = A2[1] = f3 + m2 - p + w2);
            m2 < p - w2 && (m2 = Math.sqrt(Math.pow(p, 2) - Math.pow(p - w2 - m2, 2)), u2[0] = v2[0] = a3 + h2 - p + m2, c[0] = Math.min(u2[0], c[0]), b[0] = Math.max(v2[0], b[0]), A2[0] = B2[0] = a3 + p - m2, v2[1] = A2[1] = f3);
            g.length = 0;
            g.push(["M", ...b], ["L", ...c], ["A", e, e, 0, 0, 1, ...u2], ["L", ...v2], ["A", p, p, 0, 0, 1, ...z], ["L", ...y2], ["A", p, p, 0, 0, 1, ...A2], ["L", ...B2], ["A", e, e, 0, 0, 1, ...b], ["Z"]);
            return g;
          };
          A(a2.pie, "afterTranslate", function() {
            const a3 = m(this.options.borderRadius);
            for (const f3 of this.points) {
              const g = f3.shapeArgs;
              g && (g.borderRadius = h(a3.radius, (g.r || 0) - (g.innerR || 0)));
            }
          });
          A(y, "afterColumnTranslate", function() {
            var a3, f3;
            if (this.options.borderRadius && (!this.chart.is3d || !this.chart.is3d())) {
              const { options: g, yAxis: d } = this, q = "percent" === g.stacking;
              var k2 = null === (f3 = null === (a3 = w.plotOptions) || void 0 === a3 ? void 0 : a3[this.type]) || void 0 === f3 ? void 0 : f3.borderRadius;
              a3 = m(g.borderRadius, v(k2) ? k2 : {});
              f3 = d.options.reversed;
              for (const m2 of this.points)
                if ({ shapeArgs: k2 } = m2, "roundedRect" === m2.shapeType && k2) {
                  const { width: c = 0, height: b = 0, y: p = 0 } = k2;
                  var n = p, e = b;
                  "stack" === a3.scope && m2.stackTotal && (n = d.translate(q ? 100 : m2.stackTotal, false, true, false, true), e = d.translate(g.threshold || 0, false, true, false, true), e = this.crispCol(0, Math.min(n, e), 0, Math.abs(n - e)), n = e.y, e = e.height);
                  const l = -1 === (m2.negative ? -1 : 1) * (f3 ? -1 : 1);
                  let r2 = a3.where;
                  !r2 && this.is("waterfall") && Math.abs((m2.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (r2 = "all");
                  r2 || (r2 = "end");
                  const t = Math.min(h(a3.radius, c), c / 2, "all" === r2 ? b / 2 : Infinity) || 0;
                  "end" === r2 && (l && (n -= t), e += t);
                  u(k2, { brBoxHeight: e, brBoxY: n, r: t });
                }
            }
          }, { order: 9 });
        }
        y = { optionsToObject: m };
        "";
        return y;
      });
      M(a, "Core/Responsive.js", [a["Core/Utilities.js"]], function(a2) {
        const { extend: w, find: H, isArray: K, isObject: B, merge: E, objectEach: C, pick: A, splat: u, uniqueKey: v } = a2;
        var f;
        (function(f2) {
          function h(a3) {
            function f3(a4, h3, d, k2) {
              let e;
              C(a4, function(a5, b) {
                if (!k2 && -1 < g.collectionsWithUpdate.indexOf(b) && h3[b])
                  for (a5 = u(a5), d[b] = [], e = 0; e < Math.max(a5.length, h3[b].length); e++)
                    h3[b][e] && (void 0 === a5[e] ? d[b][e] = h3[b][e] : (d[b][e] = {}, f3(a5[e], h3[b][e], d[b][e], k2 + 1)));
                else
                  B(a5) ? (d[b] = K(a5) ? [] : {}, f3(a5, h3[b] || {}, d[b], k2 + 1)) : d[b] = "undefined" === typeof h3[b] ? null : h3[b];
              });
            }
            const g = this, h2 = {};
            f3(a3, this.options, h2, 0);
            return h2;
          }
          function m(a3, f3) {
            const g = a3.condition;
            (g.callback || function() {
              return this.chartWidth <= A(g.maxWidth, Number.MAX_VALUE) && this.chartHeight <= A(g.maxHeight, Number.MAX_VALUE) && this.chartWidth >= A(g.minWidth, 0) && this.chartHeight >= A(g.minHeight, 0);
            }).call(this) && f3.push(a3._id);
          }
          function n(a3, f3) {
            const g = this.options.responsive;
            var h2 = this.currentResponsive;
            let e = [];
            !f3 && g && g.rules && g.rules.forEach((a4) => {
              "undefined" === typeof a4._id && (a4._id = v());
              this.matchResponsiveRule(a4, e);
            }, this);
            f3 = E(...e.map((a4) => H((g || {}).rules || [], (d) => d._id === a4)).map((a4) => a4 && a4.chartOptions));
            f3.isResponsiveOptions = true;
            e = e.toString() || void 0;
            e !== (h2 && h2.ruleIds) && (h2 && this.update(h2.undoOptions, a3, true), e ? (h2 = this.currentOptions(f3), h2.isResponsiveOptions = true, this.currentResponsive = { ruleIds: e, mergedOptions: f3, undoOptions: h2 }, this.update(f3, a3, true)) : this.currentResponsive = void 0);
          }
          const k = [];
          f2.compose = function(f3) {
            a2.pushUnique(
              k,
              f3
            ) && w(f3.prototype, { currentOptions: h, matchResponsiveRule: m, setResponsive: n });
            return f3;
          };
        })(f || (f = {}));
        "";
        "";
        return f;
      });
      M(a, "masters/highcharts.src.js", [
        a["Core/Globals.js"],
        a["Core/Utilities.js"],
        a["Core/Defaults.js"],
        a["Core/Animation/Fx.js"],
        a["Core/Animation/AnimationUtilities.js"],
        a["Core/Renderer/HTML/AST.js"],
        a["Core/FormatUtilities.js"],
        a["Core/Renderer/RendererUtilities.js"],
        a["Core/Renderer/SVG/SVGElement.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Renderer/HTML/HTMLElement.js"],
        a["Core/Renderer/HTML/HTMLRenderer.js"],
        a["Core/Axis/Axis.js"],
        a["Core/Axis/DateTimeAxis.js"],
        a["Core/Axis/LogarithmicAxis.js"],
        a["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"],
        a["Core/Axis/Tick.js"],
        a["Core/Tooltip.js"],
        a["Core/Series/Point.js"],
        a["Core/Pointer.js"],
        a["Core/Legend/Legend.js"],
        a["Core/Chart/Chart.js"],
        a["Core/Axis/Stacking/StackingAxis.js"],
        a["Core/Axis/Stacking/StackItem.js"],
        a["Core/Series/Series.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Series/Column/ColumnSeries.js"],
        a["Series/Column/ColumnDataLabel.js"],
        a["Series/Pie/PieSeries.js"],
        a["Series/Pie/PieDataLabel.js"],
        a["Core/Series/DataLabel.js"],
        a["Core/Responsive.js"],
        a["Core/Color/Color.js"],
        a["Core/Time.js"]
      ], function(a2, y, H, K, B, E, C, A, u, v, f, h, r, m, n, k, g, I, F, z, e, t, d, q, x, c, b, p, l, L, M2, O, T2, S) {
        a2.animate = B.animate;
        a2.animObject = B.animObject;
        a2.getDeferredAnimation = B.getDeferredAnimation;
        a2.setAnimation = B.setAnimation;
        a2.stop = B.stop;
        a2.timers = K.timers;
        a2.AST = E;
        a2.Axis = r;
        a2.Chart = t;
        a2.chart = t.chart;
        a2.Fx = K;
        a2.Legend = e;
        a2.PlotLineOrBand = k;
        a2.Point = F;
        a2.Pointer = z;
        a2.Series = x;
        a2.StackItem = q;
        a2.SVGElement = u;
        a2.SVGRenderer = v;
        a2.Tick = g;
        a2.Time = S;
        a2.Tooltip = I;
        a2.Color = T2;
        a2.color = T2.parse;
        h.compose(v);
        f.compose(u);
        z.compose(t);
        e.compose(t);
        a2.defaultOptions = H.defaultOptions;
        a2.getOptions = H.getOptions;
        a2.time = H.defaultTime;
        a2.setOptions = H.setOptions;
        a2.dateFormat = C.dateFormat;
        a2.format = C.format;
        a2.numberFormat = C.numberFormat;
        a2.addEvent = y.addEvent;
        a2.arrayMax = y.arrayMax;
        a2.arrayMin = y.arrayMin;
        a2.attr = y.attr;
        a2.clearTimeout = y.clearTimeout;
        a2.correctFloat = y.correctFloat;
        a2.createElement = y.createElement;
        a2.css = y.css;
        a2.defined = y.defined;
        a2.destroyObjectProperties = y.destroyObjectProperties;
        a2.discardElement = y.discardElement;
        a2.distribute = A.distribute;
        a2.erase = y.erase;
        a2.error = y.error;
        a2.extend = y.extend;
        a2.extendClass = y.extendClass;
        a2.find = y.find;
        a2.fireEvent = y.fireEvent;
        a2.getMagnitude = y.getMagnitude;
        a2.getStyle = y.getStyle;
        a2.inArray = y.inArray;
        a2.isArray = y.isArray;
        a2.isClass = y.isClass;
        a2.isDOMElement = y.isDOMElement;
        a2.isFunction = y.isFunction;
        a2.isNumber = y.isNumber;
        a2.isObject = y.isObject;
        a2.isString = y.isString;
        a2.keys = y.keys;
        a2.merge = y.merge;
        a2.normalizeTickInterval = y.normalizeTickInterval;
        a2.objectEach = y.objectEach;
        a2.offset = y.offset;
        a2.pad = y.pad;
        a2.pick = y.pick;
        a2.pInt = y.pInt;
        a2.relativeLength = y.relativeLength;
        a2.removeEvent = y.removeEvent;
        a2.seriesType = c.seriesType;
        a2.splat = y.splat;
        a2.stableSort = y.stableSort;
        a2.syncTimeout = y.syncTimeout;
        a2.timeUnits = y.timeUnits;
        a2.uniqueKey = y.uniqueKey;
        a2.useSerialIds = y.useSerialIds;
        a2.wrap = y.wrap;
        p.compose(b);
        M2.compose(x);
        m.compose(r);
        n.compose(r);
        L.compose(l);
        k.compose(r);
        O.compose(t);
        d.compose(r, t, x);
        I.compose(z);
        return a2;
      });
      a["masters/highcharts.src.js"]._modules = a;
      return a["masters/highcharts.src.js"];
    });
  }
});
export default require_highcharts();
//# sourceMappingURL=highcharts.js.map
